__BRYTHON__.use_VFS = true
__BRYTHON__.VFS = {"keyword": [".py", "#! /usr/bin/env python3\n\n\"\"\"Keywords (from \"graminit.c\")\n\nThis file is automatically generated; please don't muck it up!\n\nTo update the symbols in this file, 'cd' to the top directory of\nthe python source tree after building the interpreter and run:\n\n    ./python Lib/keyword.py\n\"\"\"\n\n__all__=[\"iskeyword\",\"kwlist\"]\n\nkwlist=[\n\n'False',\n'None',\n'True',\n'and',\n'as',\n'assert',\n'break',\n'class',\n'continue',\n'def',\n'del',\n'elif',\n'else',\n'except',\n'finally',\n'for',\n'from',\n'global',\n'if',\n'import',\n'in',\n'is',\n'lambda',\n'nonlocal',\n'not',\n'or',\n'pass',\n'raise',\n'return',\n'try',\n'while',\n'with',\n'yield',\n\n]\n\niskeyword=frozenset(kwlist). __contains__\n\ndef main():\n import sys,re\n \n args=sys. argv[1:]\n iptfile=args and args[0]or\"Python/graminit.c\"\n if len(args)>1:optfile=args[1]\n else :optfile=\"Lib/keyword.py\"\n \n \n with open(iptfile)as fp:\n  strprog=re. compile('\"([^\"]+)\"')\n  lines=[]\n  for line in fp:\n   if'{1, \"'in line:\n    match=strprog. search(line)\n    if match:\n     lines. append(\"        '\"+match. group(1)+\"',\\n\")\n lines. sort()\n \n \n with open(optfile)as fp:\n  format=fp. readlines()\n  \n  \n try :\n  start=format. index(\"#--start keywords--\\n\")+1\n  end=format. index(\"#--end keywords--\\n\")\n  format[start:end]=lines\n except ValueError:\n  sys. stderr. write(\"target does not contain format markers\\n\")\n  sys. exit(1)\n  \n  \n fp=open(optfile,'w')\n fp. write(''. join(format))\n fp. close()\n \nif __name__ ==\"__main__\":\n main()\n"], "json": [".js", "var $module = (function($B){\n\nreturn  {\n    loads : function(json_obj){\n        return $B.jsobject2pyobject(JSON.parse(json_obj))\n    },\n    load : function(file_obj){\n        return $module.loads(file_obj.$content);\n    },\n    dumps : function(obj){return JSON.stringify($B.pyobject2jsobject(obj))},\n}\n\n})(__BRYTHON__)\n"], "browser.ajax": [".py", "from _ajax import *\n\nclass Ajax:\n ''\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,url,method=\"GET\",async=True ):\n  ''\n  self. req=ajax1()\n  self. req. open(method,url,async)\n  \n def send(self,data=None ):\n  if data is not None :\n   self. req. send(data)\n  else :\n   self. req. send()\n   \n def set_header(self,key,value):\n  self. req. set_header(key,value)\n  \n def set_timeout(self,seconds,func):\n  self. req. set_timeout(seconds,func)\n  \n  \n def uninitialized(self,f):\n  self. req. bind(\"uninitialized\",f)\n  return f\n  \n def loading(self,f):\n  self. req. bind(\"loading\",f)\n  return f\n  \n def loaded(self,f):\n  self. req. bind(\"loaded\",f)\n  return f\n  \n def interactive(self,f):\n  self. req. bind(\"interactive\",f)\n  return f\n  \n def complete(self,f):\n  self. req. bind(\"complete\",f)\n  return f\n  \n @property\n def status(self):\n  return self. req. status\n  \n @property\n def text(self):\n  return self. req. responseText"], "operator": [".py", "#!/usr/bin/env python3\n''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef lt(a,b):\n ''\n return a <b\n__lt__=lt\n\ndef le(a,b):\n ''\n return a <=b\n__le__=le\n\ndef eq(a,b):\n ''\n return a ==b\n__eq__=eq\n\ndef ne(a,b):\n ''\n return a !=b\n__ne__=ne\n\ndef ge(a,b):\n ''\n return a >=b\n__ge__=ge\n\ndef gt(a,b):\n ''\n return a >b\n__gt__=gt\n\ndef not_(a):\n ''\n return not a\n__not__=not_\n\ndef truth(a):\n ''\n \n return bool(a)\n \ndef is_(a,b):\n ''\n return a is b\n \n \n \n \n \n \n \n \n \n \n \n__abs__=abs\nabs=abs\n\n\ndef add(a,b):\n ''\n return a+b\n__add__=add\n\ndef and_(a,b):\n ''\n return a&b\n__and__=and_\n\ndef floordiv(a,b):\n ''\n return a //b\n__floordiv__=floordiv\n\ndef index(a):\n ''\n return a. __index__()\n__index__=index\n\ndef inv(a):\n ''\n return ~a\n \ninvert=__inv__=__invert__=inv\n\ndef lshift(a,b):\n ''\n return a <<b\n__lshift__=lshift\n\ndef mod(a,b):\n ''\n return a %b\n__mod__=mod\n\ndef mul(a,b):\n ''\n return a *b\n__mul__=mul\n\ndef neg(a):\n ''\n return -a\n__neg__=neg\n\ndef or_(a,b):\n ''\n return a |b\n__or__=or_\n\ndef pos(a):\n ''\n return +a\n \n__pos__=pos\n\ndef pow(a,b):\n ''\n return a **b\n__pow__=pow\n\ndef rshift(a,b):\n ''\n return a >>b\n__rshift__=rshift\n\ndef sub(a,b):\n ''\n return a -b\n__sub__=sub\n\ndef truediv(a,b):\n ''\n return a /b\n__truediv__=truediv\n\ndef xor(a,b):\n ''\n return a ^b\n__xor__=xor\n\ndef concat(a,b):\n ''\n if not (hasattr(a,'__getitem__')and hasattr(b,'__getitem__')):\n  raise TypeError('a and b must be sequences')\n return a+b\n__concat__=concat\n\ndef contains(a,b):\n ''\n return b in a\n__contains__=contains\n\ndef countOf(a,b):\n ''\n count=0\n for i in a:\n  if i ==b:\n   count +=1\n return count\n \ndef delitem(a,b):\n ''\n del a[b]\n__delitem__=delitem\n\ndef getitem(a,b):\n ''\n return a[b]\n__getitem__=getitem\n\n\ndef indexOf(a,b):\n ''\n \n for i,j in enumerate(a):\n  if j ==b:\n   return i\n else :\n  raise ValueError('b not found in a')\n  \ndef setitem(a,b,c):\n ''\n a[b]=c\n__setitem__=setitem\n\n\n\nclass attrgetter:\n ''\n\n\n\n\n\n \n def __init__(self,attr,*attrs):\n  self. _attrs=(attr,)\n  self. _attrs +=attrs\n  if any(not isinstance(attr,str)for attr in self. _attrs):\n   raise TypeError('attribute name must be a string')\n   \n @staticmethod\n def _resolve_attr(obj,attr):\n  for name in attr. split('.'):\n  \n   obj=getattr(obj,name)\n  return obj\n  \n def __call__(self,obj):\n  if len(self. _attrs)==1:\n   return self. _resolve_attr(obj,self. _attrs[0])\n  return tuple(self. _resolve_attr(obj,attr)for attr in self. _attrs)\n  \nclass itemgetter:\n ''\n\n\n\n \n def __init__(self,item,*items):\n  self. _items=(item,)\n  self. _items +=items\n  \n def __call__(self,obj):\n  if len(self. _items)==1:\n   return obj[self. _items[0]]\n  return tuple(obj[item]for item in self. _items)\n  \nclass methodcaller:\n ''\n\n\n\n\n \n \n def __init__(self,name,*args,**kwargs):\n  self. _name=name\n  self. _args=args\n  self. _kwargs=kwargs\n  \n def __call__(self,obj):\n  return getattr(obj,self. _name)(*self. _args,**self. _kwargs)\n  \n  \ndef iadd(a,b):\n ''\n a +=b\n return a\n__iadd__=iadd\n\ndef iand(a,b):\n ''\n a &=b\n return a\n__iand__=iand\n\ndef iconcat(a,b):\n ''\n if not (hasattr(a,'__getitem__')and hasattr(b,'__getitem__')):\n  raise TypeError('a and b must be sequences')\n a +=b\n return a\n__iconcat__=iconcat\n\ndef ifloordiv(a,b):\n ''\n a //=b\n return a\n__ifloordiv__=ifloordiv\n\ndef ilshift(a,b):\n ''\n a <<=b\n return a\n__ilshift__=ilshift\n\ndef imod(a,b):\n ''\n a %=b\n return a\n__imod__=imod\n\ndef imul(a,b):\n ''\n a *=b\n return a\n__imul__=imul\n\ndef ior(a,b):\n ''\n a |=b\n return a\n__ior__=ior\n\ndef ipow(a,b):\n ''\n a **=b\n return a\n__ipow__=ipow\n\ndef irshift(a,b):\n ''\n a >>=b\n return a\n__irshift__=irshift\n\ndef isub(a,b):\n ''\n a -=b\n return a\n__isub__=isub\n\ndef itruediv(a,b):\n ''\n a /=b\n return a\n__itruediv__=itruediv\n\ndef ixor(a,b):\n ''\n a ^=b\n return a\n__ixor__=ixor\n\ndef length_hint(obj,default=0):\n ''\n\n\n\n\n\n\n \n try :\n  return len(obj)\n except TypeError:\n  try :\n   val=obj. __length_hint__()\n   if val is NotImplemented:\n    raise TypeError\n  except (AttributeError,TypeError):\n   return default\n  else :\n   if not val >0:\n    raise ValueError('default must be > 0')\n   return val\n   \n   \n   \n   \n   \n   \n"], "_weakrefset": [".py", "\n\n\n\nfrom _weakref import ref\n\n__all__=['WeakSet']\n\n\nclass _IterationGuard:\n\n\n\n\n\n def __init__(self,weakcontainer):\n \n  self. weakcontainer=ref(weakcontainer)\n  \n def __enter__(self):\n  w=self. weakcontainer()\n  if w is not None :\n   w. _iterating. add(self)\n  return self\n  \n def __exit__(self,e,t,b):\n  w=self. weakcontainer()\n  if w is not None :\n   s=w. _iterating\n   s. remove(self)\n   if not s:\n    w. _commit_removals()\n    \n    \nclass WeakSet:\n def __init__(self,data=None ):\n  self. data=set()\n  def _remove(item,selfref=ref(self)):\n   self=selfref()\n   if self is not None :\n    if self. _iterating:\n     self. _pending_removals. append(item)\n    else :\n     self. data. discard(item)\n  self. _remove=_remove\n  \n  self. _pending_removals=[]\n  self. _iterating=set()\n  if data is not None :\n   self. update(data)\n   \n def _commit_removals(self):\n  l=self. _pending_removals\n  discard=self. data. discard\n  while l:\n   discard(l. pop())\n   \n def __iter__(self):\n  with _IterationGuard(self):\n   for itemref in self. data:\n    item=itemref()\n    if item is not None :\n     yield item\n     \n def __len__(self):\n  return len(self. data)-len(self. _pending_removals)\n  \n def __contains__(self,item):\n  try :\n   wr=ref(item)\n  except TypeError:\n   return False\n  return wr in self. data\n  \n def __reduce__(self):\n  return (self. __class__,(list(self),),\n  getattr(self,'__dict__',None ))\n  \n def add(self,item):\n  if self. _pending_removals:\n   self. _commit_removals()\n  self. data. add(ref(item,self. _remove))\n  \n def clear(self):\n  if self. _pending_removals:\n   self. _commit_removals()\n  self. data. clear()\n  \n def copy(self):\n  return self. __class__(self)\n  \n def pop(self):\n  if self. _pending_removals:\n   self. _commit_removals()\n  while True :\n   try :\n    itemref=self. data. pop()\n   except KeyError:\n    raise KeyError('pop from empty WeakSet')\n   item=itemref()\n   if item is not None :\n    return item\n    \n def remove(self,item):\n  if self. _pending_removals:\n   self. _commit_removals()\n  self. data. remove(ref(item))\n  \n def discard(self,item):\n  if self. _pending_removals:\n   self. _commit_removals()\n  self. data. discard(ref(item))\n  \n def update(self,other):\n  if self. _pending_removals:\n   self. _commit_removals()\n  for element in other:\n   self. add(element)\n   \n def __ior__(self,other):\n  self. update(other)\n  return self\n  \n def difference(self,other):\n  newset=self. copy()\n  newset. difference_update(other)\n  return newset\n __sub__=difference\n \n def difference_update(self,other):\n  self. __isub__(other)\n def __isub__(self,other):\n  if self. _pending_removals:\n   self. _commit_removals()\n  if self is other:\n   self. data. clear()\n  else :\n   self. data. difference_update(ref(item)for item in other)\n  return self\n  \n def intersection(self,other):\n  return self. __class__(item for item in other if item in self)\n __and__=intersection\n \n def intersection_update(self,other):\n  self. __iand__(other)\n def __iand__(self,other):\n  if self. _pending_removals:\n   self. _commit_removals()\n  self. data. intersection_update(ref(item)for item in other)\n  return self\n  \n def issubset(self,other):\n  return self. data. issubset(ref(item)for item in other)\n __le__=issubset\n \n def __lt__(self,other):\n  return self. data <set(ref(item)for item in other)\n  \n def issuperset(self,other):\n  return self. data. issuperset(ref(item)for item in other)\n __ge__=issuperset\n \n def __gt__(self,other):\n  return self. data >set(ref(item)for item in other)\n  \n def __eq__(self,other):\n  if not isinstance(other,self. __class__):\n   return NotImplemented\n  return self. data ==set(ref(item)for item in other)\n  \n def symmetric_difference(self,other):\n  newset=self. copy()\n  newset. symmetric_difference_update(other)\n  return newset\n __xor__=symmetric_difference\n \n def symmetric_difference_update(self,other):\n  self. __ixor__(other)\n def __ixor__(self,other):\n  if self. _pending_removals:\n   self. _commit_removals()\n  if self is other:\n   self. data. clear()\n  else :\n   self. data. symmetric_difference_update(ref(item,self. _remove)for item in other)\n  return self\n  \n def union(self,other):\n  return self. __class__(e for s in (self,other)for e in s)\n __or__=union\n \n def isdisjoint(self,other):\n  return len(self. intersection(other))==0\n"], "_dummy_thread": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=['error','start_new_thread','exit','get_ident','allocate_lock',\n'interrupt_main','LockType']\n\n\nTIMEOUT_MAX=2 **31\n\n\n\n\n\n\nerror=RuntimeError\n\ndef start_new_thread(function,args,kwargs={}):\n ''\n\n\n\n\n\n\n\n\n\n\n \n if type(args)!=type(tuple()):\n  raise TypeError(\"2nd arg must be a tuple\")\n if type(kwargs)!=type(dict()):\n  raise TypeError(\"3rd arg must be a dict\")\n global _main\n _main=False\n try :\n  function(*args,**kwargs)\n except SystemExit:\n  pass\n except :\n  import traceback\n  traceback. print_exc()\n _main=True\n global _interrupt\n if _interrupt:\n  _interrupt=False\n  raise KeyboardInterrupt\n  \ndef exit():\n ''\n raise SystemExit\n \ndef get_ident():\n ''\n\n\n\n\n \n return -1\n \ndef allocate_lock():\n ''\n return LockType()\n \ndef stack_size(size=None ):\n ''\n if size is not None :\n  raise error(\"setting thread stack size not supported\")\n return 0\n \nclass LockType(object):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self):\n  self. locked_status=False\n  \n def acquire(self,waitflag=None ,timeout=-1):\n  ''\n\n\n\n\n\n\n\n\n  \n  if waitflag is None or waitflag:\n   self. locked_status=True\n   return True\n  else :\n   if not self. locked_status:\n    self. locked_status=True\n    return True\n   else :\n    if timeout >0:\n     import time\n     time. sleep(timeout)\n    return False\n    \n __enter__=acquire\n \n def __exit__(self,typ,val,tb):\n  self. release()\n  \n def release(self):\n  ''\n  \n  \n  if not self. locked_status:\n   raise error\n  self. locked_status=False\n  return True\n  \n def locked(self):\n  return self. locked_status\n  \n  \n_interrupt=False\n\n_main=True\n\ndef interrupt_main():\n ''\n \n if _main:\n  raise KeyboardInterrupt\n else :\n  global _interrupt\n  _interrupt=True\n"], "reprlib": [".py", "''\n\n__all__=[\"Repr\",\"repr\",\"recursive_repr\"]\n\nimport builtins\nfrom itertools import islice\ntry :\n from _thread import get_ident\nexcept ImportError:\n from _dummy_thread import get_ident\n \ndef recursive_repr(fillvalue='...'):\n ''\n \n def decorating_function(user_function):\n  repr_running=set()\n  \n  def wrapper(self):\n   key=id(self),get_ident()\n   if key in repr_running:\n    return fillvalue\n   repr_running. add(key)\n   try :\n    result=user_function(self)\n   finally :\n    repr_running. discard(key)\n   return result\n   \n   \n  wrapper. __module__=getattr(user_function,'__module__')\n  wrapper. __doc__=getattr(user_function,'__doc__')\n  wrapper. __name__=getattr(user_function,'__name__')\n  wrapper. __annotations__=getattr(user_function,'__annotations__',{})\n  return wrapper\n  \n return decorating_function\n \nclass Repr:\n\n def __init__(self):\n  self. maxlevel=6\n  self. maxtuple=6\n  self. maxlist=6\n  self. maxarray=5\n  self. maxdict=4\n  self. maxset=6\n  self. maxfrozenset=6\n  self. maxdeque=6\n  self. maxstring=30\n  self. maxlong=40\n  self. maxother=30\n  \n def repr(self,x):\n  return self. repr1(x,self. maxlevel)\n  \n def repr1(self,x,level):\n  typename=type(x). __name__\n  if' 'in typename:\n   parts=typename. split()\n   typename='_'. join(parts)\n  if hasattr(self,'repr_'+typename):\n   return getattr(self,'repr_'+typename)(x,level)\n  else :\n   return self. repr_instance(x,level)\n   \n def _repr_iterable(self,x,level,left,right,maxiter,trail=''):\n  n=len(x)\n  if level <=0 and n:\n   s='...'\n  else :\n   newlevel=level -1\n   repr1=self. repr1\n   pieces=[repr1(elem,newlevel)for elem in islice(x,maxiter)]\n   if n >maxiter:pieces. append('...')\n   s=', '. join(pieces)\n   if n ==1 and trail:right=trail+right\n  return'%s%s%s'%(left,s,right)\n  \n def repr_tuple(self,x,level):\n  return self. _repr_iterable(x,level,'(',')',self. maxtuple,',')\n  \n def repr_list(self,x,level):\n  return self. _repr_iterable(x,level,'[',']',self. maxlist)\n  \n def repr_array(self,x,level):\n  header=\"array('%s', [\"%x. typecode\n  return self. _repr_iterable(x,level,header,'])',self. maxarray)\n  \n def repr_set(self,x,level):\n  x=_possibly_sorted(x)\n  return self. _repr_iterable(x,level,'set([','])',self. maxset)\n  \n def repr_frozenset(self,x,level):\n  x=_possibly_sorted(x)\n  return self. _repr_iterable(x,level,'frozenset([','])',\n  self. maxfrozenset)\n  \n def repr_deque(self,x,level):\n  return self. _repr_iterable(x,level,'deque([','])',self. maxdeque)\n  \n def repr_dict(self,x,level):\n  n=len(x)\n  if n ==0:return'{}'\n  if level <=0:return'{...}'\n  newlevel=level -1\n  repr1=self. repr1\n  pieces=[]\n  for key in islice(_possibly_sorted(x),self. maxdict):\n   keyrepr=repr1(key,newlevel)\n   valrepr=repr1(x[key],newlevel)\n   pieces. append('%s: %s'%(keyrepr,valrepr))\n  if n >self. maxdict:pieces. append('...')\n  s=', '. join(pieces)\n  return'{%s}'%(s,)\n  \n def repr_str(self,x,level):\n  s=builtins. repr(x[:self. maxstring])\n  if len(s)>self. maxstring:\n   i=max(0,(self. maxstring -3)//2)\n   j=max(0,self. maxstring -3 -i)\n   s=builtins. repr(x[:i]+x[len(x)-j:])\n   s=s[:i]+'...'+s[len(s)-j:]\n  return s\n  \n def repr_int(self,x,level):\n  s=builtins. repr(x)\n  if len(s)>self. maxlong:\n   i=max(0,(self. maxlong -3)//2)\n   j=max(0,self. maxlong -3 -i)\n   s=s[:i]+'...'+s[len(s)-j:]\n  return s\n  \n def repr_instance(self,x,level):\n  try :\n   s=builtins. repr(x)\n   \n   \n  except Exception:\n   return'<%s instance at %x>'%(x. __class__. __name__,id(x))\n  if len(s)>self. maxother:\n   i=max(0,(self. maxother -3)//2)\n   j=max(0,self. maxother -3 -i)\n   s=s[:i]+'...'+s[len(s)-j:]\n  return s\n  \n  \ndef _possibly_sorted(x):\n\n\n\n try :\n  return sorted(x)\n except Exception:\n  return list(x)\n  \naRepr=Repr()\nrepr=aRepr. repr\n"], "datetime": [".py", "''\n\n\n\n\n\nimport time as _time\nimport math as _math\n\ndef _cmp(x,y):\n return 0 if x ==y else 1 if x >y else -1\n \nMINYEAR=1\nMAXYEAR=9999\n_MAXORDINAL=3652059\n\n\n\n\n\n\n\n\n\n\n_DAYS_IN_MONTH=[None ,31,28,31,30,31,30,31,31,30,31,30,31]\n\n_DAYS_BEFORE_MONTH=[None ]\ndbm=0\nfor dim in _DAYS_IN_MONTH[1:]:\n _DAYS_BEFORE_MONTH. append(dbm)\n dbm +=dim\ndel dbm,dim\n\ndef _is_leap(year):\n ''\n return year %4 ==0 and (year %100 !=0 or year %400 ==0)\n \ndef _days_before_year(year):\n ''\n y=year -1\n return y *365+y //4 -y //100+y //400\n \ndef _days_in_month(year,month):\n ''\n assert 1 <=month <=12,month\n if month ==2 and _is_leap(year):\n  return 29\n return _DAYS_IN_MONTH[month]\n \ndef _days_before_month(year,month):\n ''\n assert 1 <=month <=12,'month must be in 1..12'\n return _DAYS_BEFORE_MONTH[month]+(month >2 and _is_leap(year))\n \ndef _ymd2ord(year,month,day):\n ''\n assert 1 <=month <=12,'month must be in 1..12'\n dim=_days_in_month(year,month)\n assert 1 <=day <=dim,('day must be in 1..%d'%dim)\n return (_days_before_year(year)+\n _days_before_month(year,month)+\n day)\n \n_DI400Y=_days_before_year(401)\n_DI100Y=_days_before_year(101)\n_DI4Y=_days_before_year(5)\n\n\n\nassert _DI4Y ==4 *365+1\n\n\n\nassert _DI400Y ==4 *_DI100Y+1\n\n\n\nassert _DI100Y ==25 *_DI4Y -1\n\ndef _ord2ymd(n):\n ''\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n n -=1\n n400,n=divmod(n,_DI400Y)\n year=n400 *400+1\n \n \n \n \n \n \n n100,n=divmod(n,_DI100Y)\n \n \n n4,n=divmod(n,_DI4Y)\n \n \n \n n1,n=divmod(n,365)\n \n year +=n100 *100+n4 *4+n1\n if n1 ==4 or n100 ==4:\n  assert n ==0\n  return year -1,12,31\n  \n  \n  \n leapyear=n1 ==3 and (n4 !=24 or n100 ==3)\n assert leapyear ==_is_leap(year)\n month=(n+50)>>5\n preceding=_DAYS_BEFORE_MONTH[month]+(month >2 and leapyear)\n if preceding >n:\n  month -=1\n  preceding -=_DAYS_IN_MONTH[month]+(month ==2 and leapyear)\n n -=preceding\n assert 0 <=n <_days_in_month(year,month)\n \n \n \n return year,month,n+1\n \n \n_MONTHNAMES=[None ,\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\n\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]\n_DAYNAMES=[None ,\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"]\n\n\ndef _build_struct_time(y,m,d,hh,mm,ss,dstflag):\n wday=(_ymd2ord(y,m,d)+6)%7\n dnum=_days_before_month(y,m)+d\n return _time. struct_time((y,m,d,hh,mm,ss,wday,dnum,dstflag))\n \ndef _format_time(hh,mm,ss,us):\n\n result=\"%02d:%02d:%02d\"%(hh,mm,ss)\n if us:\n  result +=\".%06d\"%us\n return result\n \n \ndef _wrap_strftime(object,format,timetuple):\n\n freplace=None\n zreplace=None\n Zreplace=None\n \n \n newformat=[]\n push=newformat. append\n i,n=0,len(format)\n while i <n:\n  ch=format[i]\n  i +=1\n  if ch =='%':\n   if i <n:\n    ch=format[i]\n    i +=1\n    if ch =='f':\n     if freplace is None :\n      freplace='%06d'%getattr(object,\n      'microsecond',0)\n     newformat. append(freplace)\n    elif ch =='z':\n     if zreplace is None :\n      zreplace=\"\"\n      if hasattr(object,\"utcoffset\"):\n       offset=object. utcoffset()\n       if offset is not None :\n        sign='+'\n        if offset. days <0:\n         offset=-offset\n         sign='-'\n        h,m=divmod(offset,timedelta(hours=1))\n        assert not m %timedelta(minutes=1),\"whole minute\"\n        m //=timedelta(minutes=1)\n        zreplace='%c%02d%02d'%(sign,h,m)\n     assert'%'not in zreplace\n     newformat. append(zreplace)\n    elif ch =='Z':\n     if Zreplace is None :\n      Zreplace=\"\"\n      if hasattr(object,\"tzname\"):\n       s=object. tzname()\n       if s is not None :\n       \n        Zreplace=s. replace('%','%%')\n     newformat. append(Zreplace)\n    else :\n     push('%')\n     push(ch)\n   else :\n    push('%')\n  else :\n   push(ch)\n newformat=\"\". join(newformat)\n return _time. strftime(newformat,timetuple)\n \ndef _call_tzinfo_method(tzinfo,methname,tzinfoarg):\n if tzinfo is None :\n  return None\n return getattr(tzinfo,methname)(tzinfoarg)\n \n \ndef _check_tzname(name):\n if name is not None and not isinstance(name,str):\n  raise TypeError(\"tzinfo.tzname() must return None or string, \"\n  \"not '%s'\"%type(name))\n  \n  \n  \n  \n  \n  \n  \ndef _check_utc_offset(name,offset):\n assert name in (\"utcoffset\",\"dst\")\n if offset is None :\n  return\n if not isinstance(offset,timedelta):\n  raise TypeError(\"tzinfo.%s() must return None \"\n  \"or timedelta, not '%s'\"%(name,type(offset)))\n if offset %timedelta(minutes=1)or offset. microseconds:\n  raise ValueError(\"tzinfo.%s() must return a whole number \"\n  \"of minutes, got %s\"%(name,offset))\n if not -timedelta(1)<offset <timedelta(1):\n  raise ValueError(\"%s()=%s, must be must be strictly between\"\n  \" -timedelta(hours=24) and timedelta(hours=24)\"\n  %(name,offset))\n  \ndef _check_date_fields(year,month,day):\n if not isinstance(year,int):\n  raise TypeError('int expected')\n if not MINYEAR <=year <=MAXYEAR:\n  raise ValueError('year must be in %d..%d'%(MINYEAR,MAXYEAR),year)\n if not 1 <=month <=12:\n  raise ValueError('month must be in 1..12',month)\n dim=_days_in_month(year,month)\n if not 1 <=day <=dim:\n  raise ValueError('day must be in 1..%d'%dim,day)\n  \ndef _check_time_fields(hour,minute,second,microsecond):\n if not isinstance(hour,int):\n  raise TypeError('int expected')\n if not 0 <=hour <=23:\n  raise ValueError('hour must be in 0..23',hour)\n if not 0 <=minute <=59:\n  raise ValueError('minute must be in 0..59',minute)\n if not 0 <=second <=59:\n  raise ValueError('second must be in 0..59',second)\n if not 0 <=microsecond <=999999:\n  raise ValueError('microsecond must be in 0..999999',microsecond)\n  \ndef _check_tzinfo_arg(tz):\n if tz is not None and not isinstance(tz,tzinfo):\n  raise TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")\n  \ndef _cmperror(x,y):\n raise TypeError(\"can't compare '%s' to '%s'\"%(\n type(x). __name__,type(y). __name__))\n \nclass timedelta:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n __slots__='_days','_seconds','_microseconds'\n \n def __new__(cls,days=0,seconds=0,microseconds=0,\n milliseconds=0,minutes=0,hours=0,weeks=0):\n \n \n \n \n \n \n \n \n \n \n \n \n  d=s=us=0\n  \n  \n  days +=weeks *7\n  seconds +=minutes *60+hours *3600\n  microseconds +=milliseconds *1000\n  \n  \n  \n  if isinstance(days,float):\n   dayfrac,days=_math. modf(days)\n   daysecondsfrac,daysecondswhole=_math. modf(dayfrac *(24. *3600.))\n   assert daysecondswhole ==int(daysecondswhole)\n   s=int(daysecondswhole)\n   assert days ==int(days)\n   d=int(days)\n  else :\n   daysecondsfrac=0.0\n   d=days\n  assert isinstance(daysecondsfrac,float)\n  assert abs(daysecondsfrac)<=1.0\n  assert isinstance(d,int)\n  assert abs(s)<=24 *3600\n  \n  \n  if isinstance(seconds,float):\n   secondsfrac,seconds=_math. modf(seconds)\n   assert seconds ==int(seconds)\n   seconds=int(seconds)\n   secondsfrac +=daysecondsfrac\n   assert abs(secondsfrac)<=2.0\n  else :\n   secondsfrac=daysecondsfrac\n   \n  assert isinstance(secondsfrac,float)\n  assert abs(secondsfrac)<=2.0\n  \n  assert isinstance(seconds,int)\n  days,seconds=divmod(seconds,24 *3600)\n  d +=days\n  s +=int(seconds)\n  assert isinstance(s,int)\n  assert abs(s)<=2 *24 *3600\n  \n  \n  usdouble=secondsfrac *1e6\n  assert abs(usdouble)<2.1e6\n  \n  \n  if isinstance(microseconds,float):\n   microseconds +=usdouble\n   microseconds=round(microseconds,0)\n   seconds,microseconds=divmod(microseconds,1e6)\n   assert microseconds ==int(microseconds)\n   assert seconds ==int(seconds)\n   days,seconds=divmod(seconds,24. *3600.)\n   assert days ==int(days)\n   assert seconds ==int(seconds)\n   d +=int(days)\n   s +=int(seconds)\n   assert isinstance(s,int)\n   assert abs(s)<=3 *24 *3600\n  else :\n   seconds,microseconds=divmod(microseconds,1000000)\n   days,seconds=divmod(seconds,24 *3600)\n   d +=days\n   s +=int(seconds)\n   assert isinstance(s,int)\n   assert abs(s)<=3 *24 *3600\n   microseconds=float(microseconds)\n   microseconds +=usdouble\n   microseconds=round(microseconds,0)\n  assert abs(s)<=3 *24 *3600\n  assert abs(microseconds)<3.1e6\n  \n  \n  assert isinstance(microseconds,float)\n  assert int(microseconds)==microseconds\n  us=int(microseconds)\n  seconds,us=divmod(us,1000000)\n  s +=seconds\n  assert isinstance(s,int)\n  days,s=divmod(s,24 *3600)\n  d +=days\n  \n  assert isinstance(d,int)\n  assert isinstance(s,int)and 0 <=s <24 *3600\n  assert isinstance(us,int)and 0 <=us <1000000\n  \n  self=object. __new__(cls)\n  \n  self. _days=d\n  self. _seconds=s\n  self. _microseconds=us\n  if abs(d)>999999999:\n   raise OverflowError(\"timedelta # of days is too large: %d\"%d)\n   \n  return self\n  \n def __repr__(self):\n  if self. _microseconds:\n   return\"%s(%d, %d, %d)\"%('datetime.'+self. __class__. __name__,\n   self. _days,\n   self. _seconds,\n   self. _microseconds)\n  if self. _seconds:\n   return\"%s(%d, %d)\"%('datetime.'+self. __class__. __name__,\n   self. _days,\n   self. _seconds)\n  return\"%s(%d)\"%('datetime.'+self. __class__. __name__,self. _days)\n  \n def __str__(self):\n  mm,ss=divmod(self. _seconds,60)\n  hh,mm=divmod(mm,60)\n  s=\"%d:%02d:%02d\"%(hh,mm,ss)\n  if self. _days:\n   def plural(n):\n    return n,abs(n)!=1 and\"s\"or\"\"\n   s=(\"%d day%s, \"%plural(self. _days))+s\n  if self. _microseconds:\n   s=s+\".%06d\"%self. _microseconds\n  return s\n  \n def total_seconds(self):\n  ''\n  return ((self. days *86400+self. seconds)*10 **6+\n  self. microseconds)/10 **6\n  \n  \n @property\n def days(self):\n  ''\n  return self. _days\n  \n @property\n def seconds(self):\n  ''\n  return self. _seconds\n  \n @property\n def microseconds(self):\n  ''\n  return self. _microseconds\n  \n def __add__(self,other):\n  if isinstance(other,timedelta):\n  \n  \n   return timedelta(self. _days+other. _days,\n   self. _seconds+other. _seconds,\n   self. _microseconds+other. _microseconds)\n  return NotImplemented\n  \n __radd__=__add__\n \n def __sub__(self,other):\n  if isinstance(other,timedelta):\n  \n  \n   return timedelta(self. _days -other. _days,\n   self. _seconds -other. _seconds,\n   self. _microseconds -other. _microseconds)\n  return NotImplemented\n  \n def __rsub__(self,other):\n  if isinstance(other,timedelta):\n   return -self+other\n  return NotImplemented\n  \n def __neg__(self):\n \n \n  return timedelta(-self. _days,\n  -self. _seconds,\n  -self. _microseconds)\n  \n def __pos__(self):\n  return self\n  \n def __abs__(self):\n  if self. _days <0:\n   return -self\n  else :\n   return self\n   \n def __mul__(self,other):\n  if isinstance(other,int):\n  \n  \n   return timedelta(self. _days *other,\n   self. _seconds *other,\n   self. _microseconds *other)\n  if isinstance(other,float):\n   a,b=other. as_integer_ratio()\n   return self *a /b\n  return NotImplemented\n  \n __rmul__=__mul__\n \n def _to_microseconds(self):\n  return ((self. _days *(24 *3600)+self. _seconds)*1000000+\n  self. _microseconds)\n  \n def __floordiv__(self,other):\n  if not isinstance(other,(int,timedelta)):\n   return NotImplemented\n  usec=self. _to_microseconds()\n  if isinstance(other,timedelta):\n   return usec //other. _to_microseconds()\n  if isinstance(other,int):\n   return timedelta(0,0,usec //other)\n   \n def __truediv__(self,other):\n  if not isinstance(other,(int,float,timedelta)):\n   return NotImplemented\n  usec=self. _to_microseconds()\n  if isinstance(other,timedelta):\n   return usec /other. _to_microseconds()\n  if isinstance(other,int):\n   return timedelta(0,0,usec /other)\n  if isinstance(other,float):\n   a,b=other. as_integer_ratio()\n   return timedelta(0,0,b *usec /a)\n   \n def __mod__(self,other):\n  if isinstance(other,timedelta):\n   r=self. _to_microseconds()%other. _to_microseconds()\n   return timedelta(0,0,r)\n  return NotImplemented\n  \n def __divmod__(self,other):\n  if isinstance(other,timedelta):\n   q,r=divmod(self. _to_microseconds(),\n   other. _to_microseconds())\n   return q,timedelta(0,0,r)\n  return NotImplemented\n  \n  \n  \n def __eq__(self,other):\n  if isinstance(other,timedelta):\n   return self. _cmp(other)==0\n  else :\n   return False\n   \n def __ne__(self,other):\n  if isinstance(other,timedelta):\n   return self. _cmp(other)!=0\n  else :\n   return True\n   \n def __le__(self,other):\n  if isinstance(other,timedelta):\n   return self. _cmp(other)<=0\n  else :\n   _cmperror(self,other)\n   \n def __lt__(self,other):\n  if isinstance(other,timedelta):\n   return self. _cmp(other)<0\n  else :\n   _cmperror(self,other)\n   \n def __ge__(self,other):\n  if isinstance(other,timedelta):\n   return self. _cmp(other)>=0\n  else :\n   _cmperror(self,other)\n   \n def __gt__(self,other):\n  if isinstance(other,timedelta):\n   return self. _cmp(other)>0\n  else :\n   _cmperror(self,other)\n   \n def _cmp(self,other):\n  assert isinstance(other,timedelta)\n  return _cmp(self. _getstate(),other. _getstate())\n  \n def __hash__(self):\n  return hash(self. _getstate())\n  \n def __bool__(self):\n  return (self. _days !=0 or\n  self. _seconds !=0 or\n  self. _microseconds !=0)\n  \n  \n  \n def _getstate(self):\n  return (self. _days,self. _seconds,self. _microseconds)\n  \n def __reduce__(self):\n  return (self. __class__,self. _getstate())\n  \ntimedelta. min=timedelta(-999999999)\ntimedelta. max=timedelta(days=999999999,hours=23,minutes=59,seconds=59,\nmicroseconds=999999)\ntimedelta. resolution=timedelta(microseconds=1)\n\nclass date:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n __slots__='_year','_month','_day'\n \n def __new__(cls,year,month=None ,day=None ):\n  ''\n\n\n\n\n  \n  if (isinstance(year,bytes)and len(year)==4 and\n  1 <=year[2]<=12 and month is None ):\n  \n   self=object. __new__(cls)\n   self. __setstate(year)\n   return self\n  _check_date_fields(year,month,day)\n  self=object. __new__(cls)\n  self. _year=year\n  self. _month=month\n  self. _day=day\n  return self\n  \n  \n  \n @classmethod\n def fromtimestamp(cls,t):\n  ''\n  y,m,d,hh,mm,ss,weekday,jday,dst=_time. localtime(t)\n  return cls(y,m,d)\n  \n @classmethod\n def today(cls):\n  ''\n  t=_time. time()\n  return cls. fromtimestamp(t)\n  \n @classmethod\n def fromordinal(cls,n):\n  ''\n\n\n\n  \n  y,m,d=_ord2ymd(n)\n  return cls(y,m,d)\n  \n  \n  \n def __repr__(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  return\"%s(%d, %d, %d)\"%('datetime.'+self. __class__. __name__,\n  self. _year,\n  self. _month,\n  self. _day)\n  \n  \n  \n  \n  \n  \n def ctime(self):\n  ''\n  weekday=self. toordinal()%7 or 7\n  return\"%s %s %2d 00:00:00 %04d\"%(\n  _DAYNAMES[weekday],\n  _MONTHNAMES[self. _month],\n  self. _day,self. _year)\n  \n def strftime(self,fmt):\n  ''\n  return _wrap_strftime(self,fmt,self. timetuple())\n  \n def __format__(self,fmt):\n  if len(fmt)!=0:\n   return self. strftime(fmt)\n  return str(self)\n  \n def isoformat(self):\n  ''\n\n\n\n\n\n\n  \n  return\"%04d-%02d-%02d\"%(self. _year,self. _month,self. _day)\n  \n __str__=isoformat\n \n \n @property\n def year(self):\n  ''\n  return self. _year\n  \n @property\n def month(self):\n  ''\n  return self. _month\n  \n @property\n def day(self):\n  ''\n  return self. _day\n  \n  \n  \n def timetuple(self):\n  ''\n  return _build_struct_time(self. _year,self. _month,self. _day,\n  0,0,0,-1)\n  \n def toordinal(self):\n  ''\n\n\n\n  \n  return _ymd2ord(self. _year,self. _month,self. _day)\n  \n def replace(self,year=None ,month=None ,day=None ):\n  ''\n  if year is None :\n   year=self. _year\n  if month is None :\n   month=self. _month\n  if day is None :\n   day=self. _day\n  _check_date_fields(year,month,day)\n  return date(year,month,day)\n  \n  \n  \n def __eq__(self,other):\n  if isinstance(other,date):\n   return self. _cmp(other)==0\n  return NotImplemented\n  \n def __ne__(self,other):\n  if isinstance(other,date):\n   return self. _cmp(other)!=0\n  return NotImplemented\n  \n def __le__(self,other):\n  if isinstance(other,date):\n   return self. _cmp(other)<=0\n  return NotImplemented\n  \n def __lt__(self,other):\n  if isinstance(other,date):\n   return self. _cmp(other)<0\n  return NotImplemented\n  \n def __ge__(self,other):\n  if isinstance(other,date):\n   return self. _cmp(other)>=0\n  return NotImplemented\n  \n def __gt__(self,other):\n  if isinstance(other,date):\n   return self. _cmp(other)>0\n  return NotImplemented\n  \n def _cmp(self,other):\n  assert isinstance(other,date)\n  y,m,d=self. _year,self. _month,self. _day\n  y2,m2,d2=other. _year,other. _month,other. _day\n  return _cmp((y,m,d),(y2,m2,d2))\n  \n def __hash__(self):\n  ''\n  return hash(self. _getstate())\n  \n  \n  \n def __add__(self,other):\n  ''\n  if isinstance(other,timedelta):\n   o=self. toordinal()+other. days\n   if 0 <o <=_MAXORDINAL:\n    return date. fromordinal(o)\n   raise OverflowError(\"result out of range\")\n  return NotImplemented\n  \n __radd__=__add__\n \n def __sub__(self,other):\n  ''\n  if isinstance(other,timedelta):\n   return self+timedelta(-other. days)\n  if isinstance(other,date):\n   days1=self. toordinal()\n   days2=other. toordinal()\n   return timedelta(days1 -days2)\n  return NotImplemented\n  \n def weekday(self):\n  ''\n  return (self. toordinal()+6)%7\n  \n  \n  \n def isoweekday(self):\n  ''\n  \n  return self. toordinal()%7 or 7\n  \n def isocalendar(self):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  year=self. _year\n  week1monday=_isoweek1monday(year)\n  today=_ymd2ord(self. _year,self. _month,self. _day)\n  \n  week,day=divmod(today -week1monday,7)\n  if week <0:\n   year -=1\n   week1monday=_isoweek1monday(year)\n   week,day=divmod(today -week1monday,7)\n  elif week >=52:\n   if today >=_isoweek1monday(year+1):\n    year +=1\n    week=0\n  return year,week+1,day+1\n  \n  \n  \n def _getstate(self):\n  yhi,ylo=divmod(self. _year,256)\n  return bytes([yhi,ylo,self. _month,self. _day]),\n  \n def __setstate(self,string):\n  if len(string)!=4 or not (1 <=string[2]<=12):\n   raise TypeError(\"not enough arguments\")\n  yhi,ylo,self. _month,self. _day=string\n  self. _year=yhi *256+ylo\n  \n def __reduce__(self):\n  return (self. __class__,self. _getstate())\n  \n_date_class=date\n\ndate. min=date(1,1,1)\ndate. max=date(9999,12,31)\ndate. resolution=timedelta(days=1)\n\nclass tzinfo:\n ''\n\n\n \n __slots__=()\n def tzname(self,dt):\n  ''\n  raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n  \n def utcoffset(self,dt):\n  ''\n  raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n  \n def dst(self,dt):\n  ''\n\n\n\n  \n  raise NotImplementedError(\"tzinfo subclass must override dst()\")\n  \n def fromutc(self,dt):\n  ''\n  \n  if not isinstance(dt,datetime):\n   raise TypeError(\"fromutc() requires a datetime argument\")\n  if dt. tzinfo is not self:\n   raise ValueError(\"dt.tzinfo is not self\")\n   \n  dtoff=dt. utcoffset()\n  if dtoff is None :\n   raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n   \"result\")\n   \n   \n   \n  dtdst=dt. dst()\n  if dtdst is None :\n   raise ValueError(\"fromutc() requires a non-None dst() result\")\n  delta=dtoff -dtdst\n  if delta:\n   dt +=delta\n   dtdst=dt. dst()\n   if dtdst is None :\n    raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n    \"results; cannot convert\")\n  return dt+dtdst\n  \n  \n  \n def __reduce__(self):\n  getinitargs=getattr(self,\"__getinitargs__\",None )\n  if getinitargs:\n   args=getinitargs()\n  else :\n   args=()\n  getstate=getattr(self,\"__getstate__\",None )\n  if getstate:\n   state=getstate()\n  else :\n   state=getattr(self,\"__dict__\",None )or None\n  if state is None :\n   return (self. __class__,args)\n  else :\n   return (self. __class__,args,state)\n   \n_tzinfo_class=tzinfo\n\nclass time:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __new__(cls,hour=0,minute=0,second=0,microsecond=0,tzinfo=None ):\n  ''\n\n\n\n\n\n\n  \n  self=object. __new__(cls)\n  if isinstance(hour,bytes)and len(hour)==6:\n  \n   self. __setstate(hour,minute or None )\n   return self\n  _check_tzinfo_arg(tzinfo)\n  _check_time_fields(hour,minute,second,microsecond)\n  self. _hour=hour\n  self. _minute=minute\n  self. _second=second\n  self. _microsecond=microsecond\n  self. _tzinfo=tzinfo\n  return self\n  \n  \n @property\n def hour(self):\n  ''\n  return self. _hour\n  \n @property\n def minute(self):\n  ''\n  return self. _minute\n  \n @property\n def second(self):\n  ''\n  return self. _second\n  \n @property\n def microsecond(self):\n  ''\n  return self. _microsecond\n  \n @property\n def tzinfo(self):\n  ''\n  return self. _tzinfo\n  \n  \n  \n  \n  \n def __eq__(self,other):\n  if isinstance(other,time):\n   return self. _cmp(other,allow_mixed=True )==0\n  else :\n   return False\n   \n def __ne__(self,other):\n  if isinstance(other,time):\n   return self. _cmp(other,allow_mixed=True )!=0\n  else :\n   return True\n   \n def __le__(self,other):\n  if isinstance(other,time):\n   return self. _cmp(other)<=0\n  else :\n   _cmperror(self,other)\n   \n def __lt__(self,other):\n  if isinstance(other,time):\n   return self. _cmp(other)<0\n  else :\n   _cmperror(self,other)\n   \n def __ge__(self,other):\n  if isinstance(other,time):\n   return self. _cmp(other)>=0\n  else :\n   _cmperror(self,other)\n   \n def __gt__(self,other):\n  if isinstance(other,time):\n   return self. _cmp(other)>0\n  else :\n   _cmperror(self,other)\n   \n def _cmp(self,other,allow_mixed=False ):\n  assert isinstance(other,time)\n  mytz=self. _tzinfo\n  ottz=other. _tzinfo\n  myoff=otoff=None\n  \n  if mytz is ottz:\n   base_compare=True\n  else :\n   myoff=self. utcoffset()\n   otoff=other. utcoffset()\n   base_compare=myoff ==otoff\n   \n  if base_compare:\n   return _cmp((self. _hour,self. _minute,self. _second,\n   self. _microsecond),\n   (other. _hour,other. _minute,other. _second,\n   other. _microsecond))\n  if myoff is None or otoff is None :\n   if allow_mixed:\n    return 2\n   else :\n    raise TypeError(\"cannot compare naive and aware times\")\n  myhhmm=self. _hour *60+self. _minute -myoff //timedelta(minutes=1)\n  othhmm=other. _hour *60+other. _minute -otoff //timedelta(minutes=1)\n  return _cmp((myhhmm,self. _second,self. _microsecond),\n  (othhmm,other. _second,other. _microsecond))\n  \n def __hash__(self):\n  ''\n  tzoff=self. utcoffset()\n  if not tzoff:\n   return hash(self. _getstate()[0])\n  h,m=divmod(timedelta(hours=self. hour,minutes=self. minute)-tzoff,\n  timedelta(hours=1))\n  assert not m %timedelta(minutes=1),\"whole minute\"\n  m //=timedelta(minutes=1)\n  if 0 <=h <24:\n   return hash(time(h,m,self. second,self. microsecond))\n  return hash((h,m,self. second,self. microsecond))\n  \n  \n  \n def _tzstr(self,sep=\":\"):\n  ''\n  off=self. utcoffset()\n  if off is not None :\n   if off. days <0:\n    sign=\"-\"\n    off=-off\n   else :\n    sign=\"+\"\n   hh,mm=divmod(off,timedelta(hours=1))\n   assert not mm %timedelta(minutes=1),\"whole minute\"\n   mm //=timedelta(minutes=1)\n   assert 0 <=hh <24\n   off=\"%s%02d%s%02d\"%(sign,hh,sep,mm)\n  return off\n  \n def __repr__(self):\n  ''\n  if self. _microsecond !=0:\n   s=\", %d, %d\"%(self. _second,self. _microsecond)\n  elif self. _second !=0:\n   s=\", %d\"%self. _second\n  else :\n   s=\"\"\n  s=\"%s(%d, %d%s)\"%('datetime.'+self. __class__. __name__,\n  self. _hour,self. _minute,s)\n  if self. _tzinfo is not None :\n   assert s[-1:]==\")\"\n   s=s[:-1]+\", tzinfo=%r\"%self. _tzinfo+\")\"\n  return s\n  \n def isoformat(self):\n  ''\n\n\n\n  \n  s=_format_time(self. _hour,self. _minute,self. _second,\n  self. _microsecond)\n  tz=self. _tzstr()\n  if tz:\n   s +=tz\n  return s\n  \n __str__=isoformat\n \n def strftime(self,fmt):\n  ''\n\n  \n  \n  \n  timetuple=(1900,1,1,\n  self. _hour,self. _minute,self. _second,\n  0,1,-1)\n  return _wrap_strftime(self,fmt,timetuple)\n  \n def __format__(self,fmt):\n  if len(fmt)!=0:\n   return self. strftime(fmt)\n  return str(self)\n  \n  \n  \n def utcoffset(self):\n  ''\n  \n  if self. _tzinfo is None :\n   return None\n  offset=self. _tzinfo. utcoffset(None )\n  _check_utc_offset(\"utcoffset\",offset)\n  return offset\n  \n def tzname(self):\n  ''\n\n\n\n\n  \n  if self. _tzinfo is None :\n   return None\n  name=self. _tzinfo. tzname(None )\n  _check_tzname(name)\n  return name\n  \n def dst(self):\n  ''\n\n\n\n\n\n\n  \n  if self. _tzinfo is None :\n   return None\n  offset=self. _tzinfo. dst(None )\n  _check_utc_offset(\"dst\",offset)\n  return offset\n  \n def replace(self,hour=None ,minute=None ,second=None ,microsecond=None ,\n tzinfo=True ):\n  ''\n  if hour is None :\n   hour=self. hour\n  if minute is None :\n   minute=self. minute\n  if second is None :\n   second=self. second\n  if microsecond is None :\n   microsecond=self. microsecond\n  if tzinfo is True :\n   tzinfo=self. tzinfo\n  _check_time_fields(hour,minute,second,microsecond)\n  _check_tzinfo_arg(tzinfo)\n  return time(hour,minute,second,microsecond,tzinfo)\n  \n def __bool__(self):\n  if self. second or self. microsecond:\n   return True\n  offset=self. utcoffset()or timedelta(0)\n  return timedelta(hours=self. hour,minutes=self. minute)!=offset\n  \n  \n  \n def _getstate(self):\n  us2,us3=divmod(self. _microsecond,256)\n  us1,us2=divmod(us2,256)\n  basestate=bytes([self. _hour,self. _minute,self. _second,\n  us1,us2,us3])\n  if self. _tzinfo is None :\n   return (basestate,)\n  else :\n   return (basestate,self. _tzinfo)\n   \n def __setstate(self,string,tzinfo):\n  if len(string)!=6 or string[0]>=24:\n   raise TypeError(\"an integer is required\")\n  (self. _hour,self. _minute,self. _second,\n  us1,us2,us3)=string\n  self. _microsecond=(((us1 <<8)|us2)<<8)|us3\n  if tzinfo is None or isinstance(tzinfo,_tzinfo_class):\n   self. _tzinfo=tzinfo\n  else :\n   raise TypeError(\"bad tzinfo state arg %r\"%tzinfo)\n   \n def __reduce__(self):\n  return (time,self. _getstate())\n  \n_time_class=time\n\ntime. min=time(0,0,0)\ntime. max=time(23,59,59,999999)\ntime. resolution=timedelta(microseconds=1)\n\nclass datetime(date):\n ''\n\n\n\n \n \n __slots__=date. __slots__+(\n '_hour','_minute','_second',\n '_microsecond','_tzinfo')\n def __new__(cls,year,month=None ,day=None ,hour=0,minute=0,second=0,\n microsecond=0,tzinfo=None ):\n  if isinstance(year,bytes)and len(year)==10:\n  \n   self=date. __new__(cls,year[:4])\n   self. __setstate(year,month)\n   return self\n  _check_tzinfo_arg(tzinfo)\n  _check_time_fields(hour,minute,second,microsecond)\n  self=date. __new__(cls,year,month,day)\n  self. _hour=hour\n  self. _minute=minute\n  self. _second=second\n  self. _microsecond=microsecond\n  self. _tzinfo=tzinfo\n  return self\n  \n  \n @property\n def hour(self):\n  ''\n  return self. _hour\n  \n @property\n def minute(self):\n  ''\n  return self. _minute\n  \n @property\n def second(self):\n  ''\n  return self. _second\n  \n @property\n def microsecond(self):\n  ''\n  return self. _microsecond\n  \n @property\n def tzinfo(self):\n  ''\n  return self. _tzinfo\n  \n @classmethod\n def fromtimestamp(cls,t,tz=None ):\n  ''\n\n\n  \n  \n  _check_tzinfo_arg(tz)\n  \n  converter=_time. localtime if tz is None else _time. gmtime\n  \n  t,frac=divmod(t,1.0)\n  us=int(frac *1e6)\n  \n  \n  \n  \n  \n  if us ==1000000:\n   t +=1\n   us=0\n  y,m,d,hh,mm,ss,weekday,jday,dst=converter(t)\n  ss=min(ss,59)\n  result=cls(y,m,d,hh,mm,ss,us,tz)\n  if tz is not None :\n   result=tz. fromutc(result)\n  return result\n  \n @classmethod\n def utcfromtimestamp(cls,t):\n  ''\n  t,frac=divmod(t,1.0)\n  us=int(frac *1e6)\n  \n  \n  \n  \n  \n  if us ==1000000:\n   t +=1\n   us=0\n  y,m,d,hh,mm,ss,weekday,jday,dst=_time. gmtime(t)\n  ss=min(ss,59)\n  return cls(y,m,d,hh,mm,ss,us)\n  \n  \n  \n  \n  \n  \n @classmethod\n def now(cls,tz=None ):\n  ''\n  t=_time. time()\n  return cls. fromtimestamp(t,tz)\n  \n @classmethod\n def utcnow(cls):\n  ''\n  t=_time. time()\n  return cls. utcfromtimestamp(t)\n  \n @classmethod\n def combine(cls,date,time):\n  ''\n  if not isinstance(date,_date_class):\n   raise TypeError(\"date argument must be a date instance\")\n  if not isinstance(time,_time_class):\n   raise TypeError(\"time argument must be a time instance\")\n  return cls(date. year,date. month,date. day,\n  time. hour,time. minute,time. second,time. microsecond,\n  time. tzinfo)\n  \n def timetuple(self):\n  ''\n  dst=self. dst()\n  if dst is None :\n   dst=-1\n  elif dst:\n   dst=1\n  else :\n   dst=0\n  return _build_struct_time(self. year,self. month,self. day,\n  self. hour,self. minute,self. second,\n  dst)\n  \n def timestamp(self):\n  ''\n  if self. _tzinfo is None :\n   return _time. mktime((self. year,self. month,self. day,\n   self. hour,self. minute,self. second,\n   -1,-1,-1))+self. microsecond /1e6\n  else :\n   return (self -_EPOCH). total_seconds()\n   \n def utctimetuple(self):\n  ''\n  offset=self. utcoffset()\n  if offset:\n   self -=offset\n  y,m,d=self. year,self. month,self. day\n  hh,mm,ss=self. hour,self. minute,self. second\n  return _build_struct_time(y,m,d,hh,mm,ss,0)\n  \n def date(self):\n  ''\n  return date(self. _year,self. _month,self. _day)\n  \n def time(self):\n  ''\n  return time(self. hour,self. minute,self. second,self. microsecond)\n  \n def timetz(self):\n  ''\n  return time(self. hour,self. minute,self. second,self. microsecond,\n  self. _tzinfo)\n  \n def replace(self,year=None ,month=None ,day=None ,hour=None ,\n minute=None ,second=None ,microsecond=None ,tzinfo=True ):\n  ''\n  if year is None :\n   year=self. year\n  if month is None :\n   month=self. month\n  if day is None :\n   day=self. day\n  if hour is None :\n   hour=self. hour\n  if minute is None :\n   minute=self. minute\n  if second is None :\n   second=self. second\n  if microsecond is None :\n   microsecond=self. microsecond\n  if tzinfo is True :\n   tzinfo=self. tzinfo\n  _check_date_fields(year,month,day)\n  _check_time_fields(hour,minute,second,microsecond)\n  _check_tzinfo_arg(tzinfo)\n  return datetime(year,month,day,hour,minute,second,\n  microsecond,tzinfo)\n  \n def astimezone(self,tz=None ):\n  if tz is None :\n   if self. tzinfo is None :\n    raise ValueError(\"astimezone() requires an aware datetime\")\n   ts=(self -_EPOCH)//timedelta(seconds=1)\n   localtm=_time. localtime(ts)\n   local=datetime(*localtm[:6])\n   try :\n   \n    gmtoff=localtm. tm_gmtoff\n    zone=localtm. tm_zone\n   except AttributeError:\n   \n   \n   \n    delta=local -datetime(*_time. gmtime(ts)[:6])\n    dst=_time. daylight and localtm. tm_isdst >0\n    gmtoff=-(_time. altzone if dst else _time. timezone)\n    if delta ==timedelta(seconds=gmtoff):\n     tz=timezone(delta,_time. tzname[dst])\n    else :\n     tz=timezone(delta)\n   else :\n    tz=timezone(timedelta(seconds=gmtoff),zone)\n    \n  elif not isinstance(tz,tzinfo):\n   raise TypeError(\"tz argument must be an instance of tzinfo\")\n   \n  mytz=self. tzinfo\n  if mytz is None :\n   raise ValueError(\"astimezone() requires an aware datetime\")\n   \n  if tz is mytz:\n   return self\n   \n   \n  myoffset=self. utcoffset()\n  if myoffset is None :\n   raise ValueError(\"astimezone() requires an aware datetime\")\n  utc=(self -myoffset). replace(tzinfo=tz)\n  \n  \n  return tz. fromutc(utc)\n  \n  \n  \n def ctime(self):\n  ''\n  weekday=self. toordinal()%7 or 7\n  return\"%s %s %2d %02d:%02d:%02d %04d\"%(\n  _DAYNAMES[weekday],\n  _MONTHNAMES[self. _month],\n  self. _day,\n  self. _hour,self. _minute,self. _second,\n  self. _year)\n  \n def isoformat(self,sep='T'):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  s=(\"%04d-%02d-%02d%c\"%(self. _year,self. _month,self. _day,\n  sep)+\n  _format_time(self. _hour,self. _minute,self. _second,\n  self. _microsecond))\n  off=self. utcoffset()\n  if off is not None :\n   if off. days <0:\n    sign=\"-\"\n    off=-off\n   else :\n    sign=\"+\"\n   hh,mm=divmod(off,timedelta(hours=1))\n   assert not mm %timedelta(minutes=1),\"whole minute\"\n   mm //=timedelta(minutes=1)\n   s +=\"%s%02d:%02d\"%(sign,hh,mm)\n  return s\n  \n def __repr__(self):\n  ''\n  L=[self. _year,self. _month,self. _day,\n  self. _hour,self. _minute,self. _second,self. _microsecond]\n  if L[-1]==0:\n   del L[-1]\n  if L[-1]==0:\n   del L[-1]\n  s=\", \". join(map(str,L))\n  s=\"%s(%s)\"%('datetime.'+self. __class__. __name__,s)\n  if self. _tzinfo is not None :\n   assert s[-1:]==\")\"\n   s=s[:-1]+\", tzinfo=%r\"%self. _tzinfo+\")\"\n  return s\n  \n def __str__(self):\n  ''\n  return self. isoformat(sep=' ')\n  \n @classmethod\n def strptime(cls,date_string,format):\n  ''\n  import _strptime\n  return _strptime. _strptime_datetime(cls,date_string,format)\n  \n def utcoffset(self):\n  ''\n  \n  if self. _tzinfo is None :\n   return None\n  offset=self. _tzinfo. utcoffset(self)\n  _check_utc_offset(\"utcoffset\",offset)\n  return offset\n  \n def tzname(self):\n  ''\n\n\n\n\n  \n  name=_call_tzinfo_method(self. _tzinfo,\"tzname\",self)\n  _check_tzname(name)\n  return name\n  \n def dst(self):\n  ''\n\n\n\n\n\n\n  \n  if self. _tzinfo is None :\n   return None\n  offset=self. _tzinfo. dst(self)\n  _check_utc_offset(\"dst\",offset)\n  return offset\n  \n  \n  \n def __eq__(self,other):\n  if isinstance(other,datetime):\n   return self. _cmp(other,allow_mixed=True )==0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   return False\n   \n def __ne__(self,other):\n  if isinstance(other,datetime):\n   return self. _cmp(other,allow_mixed=True )!=0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   return True\n   \n def __le__(self,other):\n  if isinstance(other,datetime):\n   return self. _cmp(other)<=0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   _cmperror(self,other)\n   \n def __lt__(self,other):\n  if isinstance(other,datetime):\n   return self. _cmp(other)<0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   _cmperror(self,other)\n   \n def __ge__(self,other):\n  if isinstance(other,datetime):\n   return self. _cmp(other)>=0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   _cmperror(self,other)\n   \n def __gt__(self,other):\n  if isinstance(other,datetime):\n   return self. _cmp(other)>0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   _cmperror(self,other)\n   \n def _cmp(self,other,allow_mixed=False ):\n  assert isinstance(other,datetime)\n  mytz=self. _tzinfo\n  ottz=other. _tzinfo\n  myoff=otoff=None\n  \n  if mytz is ottz:\n   base_compare=True\n  else :\n   myoff=self. utcoffset()\n   otoff=other. utcoffset()\n   base_compare=myoff ==otoff\n   \n  if base_compare:\n   return _cmp((self. _year,self. _month,self. _day,\n   self. _hour,self. _minute,self. _second,\n   self. _microsecond),\n   (other. _year,other. _month,other. _day,\n   other. _hour,other. _minute,other. _second,\n   other. _microsecond))\n  if myoff is None or otoff is None :\n   if allow_mixed:\n    return 2\n   else :\n    raise TypeError(\"cannot compare naive and aware datetimes\")\n    \n  diff=self -other\n  if diff. days <0:\n   return -1\n  return diff and 1 or 0\n  \n def __add__(self,other):\n  ''\n  if not isinstance(other,timedelta):\n   return NotImplemented\n  delta=timedelta(self. toordinal(),\n  hours=self. _hour,\n  minutes=self. _minute,\n  seconds=self. _second,\n  microseconds=self. _microsecond)\n  delta +=other\n  hour,rem=divmod(delta. seconds,3600)\n  minute,second=divmod(rem,60)\n  if 0 <delta. days <=_MAXORDINAL:\n   return datetime. combine(date. fromordinal(delta. days),\n   time(hour,minute,second,\n   delta. microseconds,\n   tzinfo=self. _tzinfo))\n  raise OverflowError(\"result out of range\")\n  \n __radd__=__add__\n \n def __sub__(self,other):\n  ''\n  if not isinstance(other,datetime):\n   if isinstance(other,timedelta):\n    return self+-other\n   return NotImplemented\n   \n  days1=self. toordinal()\n  days2=other. toordinal()\n  secs1=self. _second+self. _minute *60+self. _hour *3600\n  secs2=other. _second+other. _minute *60+other. _hour *3600\n  base=timedelta(days1 -days2,\n  secs1 -secs2,\n  self. _microsecond -other. _microsecond)\n  if self. _tzinfo is other. _tzinfo:\n   return base\n  myoff=self. utcoffset()\n  otoff=other. utcoffset()\n  if myoff ==otoff:\n   return base\n  if myoff is None or otoff is None :\n   raise TypeError(\"cannot mix naive and timezone-aware time\")\n  return base+otoff -myoff\n  \n def __hash__(self):\n  tzoff=self. utcoffset()\n  if tzoff is None :\n   return hash(self. _getstate()[0])\n  days=_ymd2ord(self. year,self. month,self. day)\n  seconds=self. hour *3600+self. minute *60+self. second\n  return hash(timedelta(days,seconds,self. microsecond)-tzoff)\n  \n  \n  \n def _getstate(self):\n  yhi,ylo=divmod(self. _year,256)\n  us2,us3=divmod(self. _microsecond,256)\n  us1,us2=divmod(us2,256)\n  basestate=bytes([yhi,ylo,self. _month,self. _day,\n  self. _hour,self. _minute,self. _second,\n  us1,us2,us3])\n  if self. _tzinfo is None :\n   return (basestate,)\n  else :\n   return (basestate,self. _tzinfo)\n   \n def __setstate(self,string,tzinfo):\n  (yhi,ylo,self. _month,self. _day,self. _hour,\n  self. _minute,self. _second,us1,us2,us3)=string\n  self. _year=yhi *256+ylo\n  self. _microsecond=(((us1 <<8)|us2)<<8)|us3\n  if tzinfo is None or isinstance(tzinfo,_tzinfo_class):\n   self. _tzinfo=tzinfo\n  else :\n   raise TypeError(\"bad tzinfo state arg %r\"%tzinfo)\n   \n def __reduce__(self):\n  return (self. __class__,self. _getstate())\n  \n  \ndatetime. min=datetime(1,1,1)\ndatetime. max=datetime(9999,12,31,23,59,59,999999)\ndatetime. resolution=timedelta(microseconds=1)\n\n\ndef _isoweek1monday(year):\n\n\n THURSDAY=3\n firstday=_ymd2ord(year,1,1)\n firstweekday=(firstday+6)%7\n week1monday=firstday -firstweekday\n if firstweekday >THURSDAY:\n  week1monday +=7\n return week1monday\n \nclass timezone(tzinfo):\n __slots__='_offset','_name'\n \n \n _Omitted=object()\n def __new__(cls,offset,name=_Omitted):\n  if not isinstance(offset,timedelta):\n   raise TypeError(\"offset must be a timedelta\")\n  if name is cls. _Omitted:\n   if not offset:\n    return cls. utc\n   name=None\n  elif not isinstance(name,str):\n   raise TypeError(\"name must be a string\")\n  if not cls. _minoffset <=offset <=cls. _maxoffset:\n   raise ValueError(\"offset must be a timedelta\"\n   \" strictly between -timedelta(hours=24) and\"\n   \" timedelta(hours=24).\")\n  if (offset. microseconds !=0 or\n  offset. seconds %60 !=0):\n   raise ValueError(\"offset must be a timedelta\"\n   \" representing a whole number of minutes\")\n  return cls. _create(offset,name)\n  \n @classmethod\n def _create(cls,offset,name=None ):\n  self=tzinfo. __new__(cls)\n  self. _offset=offset\n  self. _name=name\n  return self\n  \n def __getinitargs__(self):\n  ''\n  if self. _name is None :\n   return (self. _offset,)\n  return (self. _offset,self. _name)\n  \n def __eq__(self,other):\n  if type(other)!=timezone:\n   return False\n  return self. _offset ==other. _offset\n  \n def __hash__(self):\n  return hash(self. _offset)\n  \n def __repr__(self):\n  ''\n\n\n\n\n\n\n\n  \n  if self is self. utc:\n   return'datetime.timezone.utc'\n  if self. _name is None :\n   return\"%s(%r)\"%('datetime.'+self. __class__. __name__,\n   self. _offset)\n  return\"%s(%r, %r)\"%('datetime.'+self. __class__. __name__,\n  self. _offset,self. _name)\n  \n def __str__(self):\n  return self. tzname(None )\n  \n def utcoffset(self,dt):\n  if isinstance(dt,datetime)or dt is None :\n   return self. _offset\n  raise TypeError(\"utcoffset() argument must be a datetime instance\"\n  \" or None\")\n  \n def tzname(self,dt):\n  if isinstance(dt,datetime)or dt is None :\n   if self. _name is None :\n    return self. _name_from_offset(self. _offset)\n   return self. _name\n  raise TypeError(\"tzname() argument must be a datetime instance\"\n  \" or None\")\n  \n def dst(self,dt):\n  if isinstance(dt,datetime)or dt is None :\n   return None\n  raise TypeError(\"dst() argument must be a datetime instance\"\n  \" or None\")\n  \n def fromutc(self,dt):\n  if isinstance(dt,datetime):\n   if dt. tzinfo is not self:\n    raise ValueError(\"fromutc: dt.tzinfo \"\n    \"is not self\")\n   return dt+self. _offset\n  raise TypeError(\"fromutc() argument must be a datetime instance\"\n  \" or None\")\n  \n _maxoffset=timedelta(hours=23,minutes=59)\n _minoffset=-_maxoffset\n \n @staticmethod\n def _name_from_offset(delta):\n  if delta <timedelta(0):\n   sign='-'\n   delta=-delta\n  else :\n   sign='+'\n  hours,rest=divmod(delta,timedelta(hours=1))\n  minutes=rest //timedelta(minutes=1)\n  return'UTC{}{:02d}:{:02d}'. format(sign,hours,minutes)\n  \ntimezone. utc=timezone. _create(timedelta(0))\ntimezone. min=timezone. _create(timezone. _minoffset)\ntimezone. max=timezone. _create(timezone. _maxoffset)\n_EPOCH=datetime(1970,1,1,tzinfo=timezone. utc)\n''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"], "posixpath": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\nimport os\nimport sys\nimport stat\nimport genericpath\nfrom genericpath import *\n\n__all__=[\"normcase\",\"isabs\",\"join\",\"splitdrive\",\"split\",\"splitext\",\n\"basename\",\"dirname\",\"commonprefix\",\"getsize\",\"getmtime\",\n\"getatime\",\"getctime\",\"islink\",\"exists\",\"lexists\",\"isdir\",\"isfile\",\n\"ismount\",\"expanduser\",\"expandvars\",\"normpath\",\"abspath\",\n\"samefile\",\"sameopenfile\",\"samestat\",\n\"curdir\",\"pardir\",\"sep\",\"pathsep\",\"defpath\",\"altsep\",\"extsep\",\n\"devnull\",\"realpath\",\"supports_unicode_filenames\",\"relpath\"]\n\n\n\ncurdir='.'\npardir='..'\nextsep='.'\nsep='/'\npathsep=':'\ndefpath=':/bin:/usr/bin'\naltsep=None\ndevnull='/dev/null'\n\ndef _get_sep(path):\n if isinstance(path,bytes):\n  return b'/'\n else :\n  return'/'\n  \n  \n  \n  \n  \n  \ndef normcase(s):\n ''\n \n if not isinstance(s,(bytes,str)):\n  raise TypeError(\"normcase() argument must be str or bytes, \"\n  \"not '{}'\". format(s. __class__. __name__))\n return s\n \n \n \n \n \ndef isabs(s):\n ''\n sep=_get_sep(s)\n return s. startswith(sep)\n \n \n \n \n \n \ndef join(a,*p):\n ''\n\n\n \n sep=_get_sep(a)\n path=a\n try :\n  for b in p:\n   if b. startswith(sep):\n    path=b\n   elif not path or path. endswith(sep):\n    path +=b\n   else :\n    path +=sep+b\n except TypeError:\n  valid_types=all(isinstance(s,(str,bytes,bytearray))\n  for s in (a,)+p)\n  if valid_types:\n  \n   raise TypeError(\"Can't mix strings and bytes in path \"\n   \"components.\")from None\n  raise\n return path\n \n \n \n \n \n \n \ndef split(p):\n ''\n \n sep=_get_sep(p)\n i=p. rfind(sep)+1\n head,tail=p[:i],p[i:]\n if head and head !=sep *len(head):\n  head=head. rstrip(sep)\n return head,tail\n \n \n \n \n \n \n \ndef splitext(p):\n if isinstance(p,bytes):\n  sep=b'/'\n  extsep=b'.'\n else :\n  sep='/'\n  extsep='.'\n return genericpath. _splitext(p,sep,None ,extsep)\nsplitext. __doc__=genericpath. _splitext. __doc__\n\n\n\n\ndef splitdrive(p):\n ''\n \n return p[:0],p\n \n \n \n \ndef basename(p):\n ''\n sep=_get_sep(p)\n i=p. rfind(sep)+1\n return p[i:]\n \n \n \n \ndef dirname(p):\n ''\n sep=_get_sep(p)\n i=p. rfind(sep)+1\n head=p[:i]\n if head and head !=sep *len(head):\n  head=head. rstrip(sep)\n return head\n \n \n \n \n \ndef islink(path):\n ''\n try :\n  st=os. lstat(path)\n except (os. error,AttributeError):\n  return False\n return stat. S_ISLNK(st. st_mode)\n \n \n \ndef lexists(path):\n ''\n try :\n  os. lstat(path)\n except os. error:\n  return False\n return True\n \n \n \n \ndef samefile(f1,f2):\n ''\n s1=os. stat(f1)\n s2=os. stat(f2)\n return samestat(s1,s2)\n \n \n \n \n \ndef sameopenfile(fp1,fp2):\n ''\n s1=os. fstat(fp1)\n s2=os. fstat(fp2)\n return samestat(s1,s2)\n \n \n \n \n \ndef samestat(s1,s2):\n ''\n return s1. st_ino ==s2. st_ino and s1. st_dev ==s2. st_dev\n \n \n \n \n \ndef ismount(path):\n ''\n if islink(path):\n \n  return False\n try :\n  s1=os. lstat(path)\n  if isinstance(path,bytes):\n   parent=join(path,b'..')\n  else :\n   parent=join(path,'..')\n  s2=os. lstat(parent)\n except os. error:\n  return False\n dev1=s1. st_dev\n dev2=s2. st_dev\n if dev1 !=dev2:\n  return True\n ino1=s1. st_ino\n ino2=s2. st_ino\n if ino1 ==ino2:\n  return True\n return False\n \n \n \n \n \n \n \n \n \n \n \ndef expanduser(path):\n ''\n return path\n \n \n \n \n \n_varprog=None\n_varprogb=None\n\ndef expandvars(path):\n ''\n \n global _varprog,_varprogb\n if isinstance(path,bytes):\n  if b'$'not in path:\n   return path\n  if not _varprogb:\n   import re\n   _varprogb=re. compile(br'\\$(\\w+|\\{[^}]*\\})',re. ASCII)\n  search=_varprogb. search\n  start=b'{'\n  end=b'}'\n else :\n  if'$'not in path:\n   return path\n  if not _varprog:\n   import re\n   _varprog=re. compile(r'\\$(\\w+|\\{[^}]*\\})',re. ASCII)\n  search=_varprog. search\n  start='{'\n  end='}'\n i=0\n while True :\n  m=search(path,i)\n  if not m:\n   break\n  i,j=m. span(0)\n  name=m. group(1)\n  if name. startswith(start)and name. endswith(end):\n   name=name[1:-1]\n  if isinstance(name,bytes):\n   name=str(name,'ASCII')\n  if name in os. environ:\n   tail=path[j:]\n   value=os. environ[name]\n   if isinstance(path,bytes):\n    value=value. encode('ASCII')\n   path=path[:i]+value\n   i=len(path)\n   path +=tail\n  else :\n   i=j\n return path\n \n \n \n \n \n \ndef normpath(path):\n ''\n if isinstance(path,bytes):\n  sep=b'/'\n  empty=b''\n  dot=b'.'\n  dotdot=b'..'\n else :\n  sep='/'\n  empty=''\n  dot='.'\n  dotdot='..'\n if path ==empty:\n  return dot\n initial_slashes=path. startswith(sep)\n \n \n if (initial_slashes and\n path. startswith(sep *2)and not path. startswith(sep *3)):\n  initial_slashes=2\n comps=path. split(sep)\n new_comps=[]\n for comp in comps:\n  if comp in (empty,dot):\n   continue\n  if (comp !=dotdot or (not initial_slashes and not new_comps)or\n  (new_comps and new_comps[-1]==dotdot)):\n   new_comps. append(comp)\n  elif new_comps:\n   new_comps. pop()\n comps=new_comps\n path=sep. join(comps)\n if initial_slashes:\n  path=sep *initial_slashes+path\n return path or dot\n \n \ndef abspath(path):\n ''\n if not isabs(path):\n  if isinstance(path,bytes):\n   cwd=os. getcwdb()\n  else :\n   cwd=os. getcwd()\n  path=join(cwd,path)\n return normpath(path)\n \n \n \n \n \ndef realpath(filename):\n ''\n \n path,ok=_joinrealpath(filename[:0],filename,{})\n return abspath(path)\n \n \n \ndef _joinrealpath(path,rest,seen):\n if isinstance(path,bytes):\n  sep=b'/'\n  curdir=b'.'\n  pardir=b'..'\n else :\n  sep='/'\n  curdir='.'\n  pardir='..'\n  \n if isabs(rest):\n  rest=rest[1:]\n  path=sep\n  \n while rest:\n  name,_,rest=rest. partition(sep)\n  if not name or name ==curdir:\n  \n   continue\n  if name ==pardir:\n  \n   if path:\n    path,name=split(path)\n    if name ==pardir:\n     path=join(path,pardir,pardir)\n   else :\n    path=pardir\n   continue\n  newpath=join(path,name)\n  if not islink(newpath):\n   path=newpath\n   continue\n   \n  if newpath in seen:\n  \n   path=seen[newpath]\n   if path is not None :\n   \n    continue\n    \n    \n   return join(newpath,rest),False\n  seen[newpath]=None\n  path,ok=_joinrealpath(path,os. readlink(newpath),seen)\n  if not ok:\n   return join(path,rest),False\n  seen[newpath]=path\n  \n return path,True\n \n \nsupports_unicode_filenames=(sys. platform =='darwin')\n\ndef relpath(path,start=None ):\n ''\n \n if not path:\n  raise ValueError(\"no path specified\")\n  \n if isinstance(path,bytes):\n  curdir=b'.'\n  sep=b'/'\n  pardir=b'..'\n else :\n  curdir='.'\n  sep='/'\n  pardir='..'\n  \n if start is None :\n  start=curdir\n  \n start_list=[x for x in abspath(start). split(sep)if x]\n path_list=[x for x in abspath(path). split(sep)if x]\n \n \n i=len(commonprefix([start_list,path_list]))\n \n rel_list=[pardir]*(len(start_list)-i)+path_list[i:]\n if not rel_list:\n  return curdir\n return join(*rel_list)\n"], "_sre": [".py", "\n''\n\n\n\n\n\n\n\nMAXREPEAT=2147483648\n\n\nimport operator,sys\nfrom sre_constants import ATCODES,OPCODES,CHCODES\nfrom sre_constants import SRE_INFO_PREFIX,SRE_INFO_LITERAL\nfrom sre_constants import SRE_FLAG_UNICODE,SRE_FLAG_LOCALE\n\n\nimport sys\n\n\n\nMAGIC=20031017\n\n\n\n\n\n\n\n\n\n\n\n\n\nCODESIZE=4\n\ncopyright=\"_sre.py 2.4c Copyright 2005 by Nik Haldimann\"\n\n\ndef getcodesize():\n return CODESIZE\n \ndef compile(pattern,flags,code,groups=0,groupindex={},indexgroup=[None ]):\n ''\n \n return SRE_Pattern(pattern,flags,code,groups,groupindex,indexgroup)\n \ndef getlower(char_ord,flags):\n if (char_ord <128)or (flags&SRE_FLAG_UNICODE) or (flags&SRE_FLAG_LOCALE and char_ord <256):\n \n  return ord(chr(char_ord). lower())\n else :\n  return char_ord\n  \n  \nclass SRE_Pattern:\n\n def __init__(self,pattern,flags,code,groups=0,groupindex={},indexgroup=[None ]):\n  self. pattern=pattern\n  self. flags=flags\n  self. groups=groups\n  self. groupindex=groupindex\n  self. _indexgroup=indexgroup\n  self. _code=code\n  \n def match(self,string,pos=0,endpos=sys. maxsize):\n  ''\n\n  \n  state=_State(string,pos,endpos,self. flags)\n  if state. match(self. _code):\n   return SRE_Match(self,state)\n  return None\n  \n def search(self,string,pos=0,endpos=sys. maxsize):\n  ''\n\n\n  \n  state=_State(string,pos,endpos,self. flags)\n  if state. search(self. _code):\n   return SRE_Match(self,state)\n  else :\n   return None\n   \n def findall(self,string,pos=0,endpos=sys. maxsize):\n  ''\n  matchlist=[]\n  state=_State(string,pos,endpos,self. flags)\n  while state. start <=state. end:\n   state. reset()\n   state. string_position=state. start\n   if not state. search(self. _code):\n    break\n   match=SRE_Match(self,state)\n   if self. groups ==0 or self. groups ==1:\n    item=match. group(self. groups)\n   else :\n    item=match. groups(\"\")\n   matchlist. append(item)\n   if state. string_position ==state. start:\n    state. start +=1\n   else :\n    state. start=state. string_position\n  return matchlist\n  \n def _subx(self,template,string,count=0,subn=False ):\n  filter=template\n  if not callable(template)and\"\\\\\"in template:\n  \n  \n  \n  \n   import re as sre\n   filter=sre. _subx(self,template)\n  state=_State(string,0,sys. maxsize,self. flags)\n  sublist=[]\n  \n  n=last_pos=0\n  while not count or n <count:\n   state. reset()\n   state. string_position=state. start\n   if not state. search(self. _code):\n    break\n   if last_pos <state. start:\n    sublist. append(string[last_pos:state. start])\n   if not (last_pos ==state. start and\n   last_pos ==state. string_position and n >0):\n   \n    if callable(filter):\n     sublist. append(filter(SRE_Match(self,state)))\n    else :\n     sublist. append(filter)\n    last_pos=state. string_position\n    n +=1\n   if state. string_position ==state. start:\n    state. start +=1\n   else :\n    state. start=state. string_position\n    \n  if last_pos <state. end:\n   sublist. append(string[last_pos:state. end])\n  item=\"\". join(sublist)\n  if subn:\n   return item,n\n  else :\n   return item\n   \n def sub(self,repl,string,count=0):\n  ''\n  \n  return self. _subx(repl,string,count,False )\n  \n def subn(self,repl,string,count=0):\n  ''\n\n  \n  return self. _subx(repl,string,count,True )\n  \n def split(self,string,maxsplit=0):\n  ''\n  splitlist=[]\n  state=_State(string,0,sys. maxsize,self. flags)\n  n=0\n  last=state. start\n  while not maxsplit or n <maxsplit:\n   state. reset()\n   state. string_position=state. start\n   if not state. search(self. _code):\n    break\n   if state. start ==state. string_position:\n    if last ==state. end:\n     break\n    state. start +=1\n    continue\n   splitlist. append(string[last:state. start])\n   \n   if self. groups:\n    match=SRE_Match(self,state)\n    splitlist. extend(list(match. groups(None )))\n   n +=1\n   last=state. start=state. string_position\n  splitlist. append(string[last:state. end])\n  return splitlist\n  \n def finditer(self,string,pos=0,endpos=sys. maxsize):\n  ''\n  \n  _list=[]\n  _m=self. scanner(string,pos,endpos)\n  _re=SRE_Scanner(self,string,pos,endpos)\n  _m=_re. search()\n  while _m:\n   _list. append(_m)\n   _m=_re. search()\n  return _list\n  \n  \n def scanner(self,string,start=0,end=sys. maxsize):\n  return SRE_Scanner(self,string,start,end)\n  \n def __copy__(self):\n  raise TypeError(\"cannot copy this pattern object\")\n  \n def __deepcopy__(self):\n  raise TypeError(\"cannot copy this pattern object\")\n  \nclass SRE_Scanner:\n ''\n \n def __init__(self,pattern,string,start,end):\n  self. pattern=pattern\n  self. _state=_State(string,start,end,self. pattern. flags)\n  \n def _match_search(self,matcher):\n  state=self. _state\n  state. reset()\n  state. string_position=state. start\n  match=None\n  if matcher(self. pattern. _code):\n   match=SRE_Match(self. pattern,state)\n  if match is None or state. string_position ==state. start:\n   state. start +=1\n  else :\n   state. start=state. string_position\n  return match\n  \n def match(self):\n  return self. _match_search(self. _state. match)\n  \n def search(self):\n  return self. _match_search(self. _state. search)\n  \nclass SRE_Match:\n\n def __init__(self,pattern,state):\n  self. re=pattern\n  self. string=state. string\n  self. pos=state. pos\n  self. endpos=state. end\n  self. lastindex=state. lastindex\n  if self. lastindex <0:\n   self. lastindex=None\n  self. regs=self. _create_regs(state)\n  \n  \n  \n  if self. lastindex is not None and pattern. _indexgroup and 0 <=self. lastindex <len(pattern. _indexgroup):\n  \n  \n  \n  \n  \n   self. lastgroup=pattern. _indexgroup[self. lastindex]\n  else :\n   self. lastgroup=None\n   \n def _create_regs(self,state):\n  ''\n  regs=[(state. start,state. string_position)]\n  for group in range(self. re. groups):\n   mark_index=2 *group\n   if mark_index+1 <len(state. marks)   and state. marks[mark_index]is not None   and state. marks[mark_index+1]is not None :\n    regs. append((state. marks[mark_index],state. marks[mark_index+1]))\n   else :\n    regs. append((-1,-1))\n  return tuple(regs)\n  \n def _get_index(self,group):\n  if isinstance(group,int):\n   if group >=0 and group <=self. re. groups:\n    return group\n  else :\n   if group in self. re. groupindex:\n    return self. re. groupindex[group]\n  raise IndexError(\"no such group\")\n  \n def _get_slice(self,group,default):\n  group_indices=self. regs[group]\n  if group_indices[0]>=0:\n   return self. string[group_indices[0]:group_indices[1]]\n  else :\n   return default\n   \n def start(self,group=0):\n  ''\n\n  \n  return self. regs[self. _get_index(group)][0]\n  \n def end(self,group=0):\n  ''\n\n  \n  return self. regs[self. _get_index(group)][1]\n  \n def span(self,group=0):\n  ''\n  return self. start(group),self. end(group)\n  \n def expand(self,template):\n  ''\n  \n  import sre\n  return sre. _expand(self. re,self,template)\n  \n def groups(self,default=None ):\n  ''\n\n  \n  groups=[]\n  for indices in self. regs[1:]:\n   if indices[0]>=0:\n    groups. append(self. string[indices[0]:indices[1]])\n   else :\n    groups. append(default)\n  return tuple(groups)\n  \n def groupdict(self,default=None ):\n  ''\n\n  \n  groupdict={}\n  for key,value in self. re. groupindex. items():\n   groupdict[key]=self. _get_slice(value,default)\n  return groupdict\n  \n def group(self,*args):\n  ''\n  \n  if len(args)==0:\n   args=(0,)\n  grouplist=[]\n  for group in args:\n   grouplist. append(self. _get_slice(self. _get_index(group),None ))\n  if len(grouplist)==1:\n   return grouplist[0]\n  else :\n   return tuple(grouplist)\n   \n def __copy__():\n  raise TypeError(\"cannot copy this pattern object\")\n  \n def __deepcopy__():\n  raise TypeError(\"cannot copy this pattern object\")\n  \n  \nclass _State:\n\n def __init__(self,string,start,end,flags):\n  self. string=string\n  if start <0:\n   start=0\n  if end >len(string):\n   end=len(string)\n  self. start=start\n  self. string_position=self. start\n  self. end=end\n  self. pos=start\n  self. flags=flags\n  self. reset()\n  \n def reset(self):\n  self. marks=[]\n  self. lastindex=-1\n  self. marks_stack=[]\n  self. context_stack=[]\n  self. repeat=None\n  \n def match(self,pattern_codes):\n \n \n \n \n \n \n \n \n \n  dispatcher=_OpcodeDispatcher()\n  self. context_stack. append(_MatchContext(self,pattern_codes))\n  has_matched=None\n  while len(self. context_stack)>0:\n   context=self. context_stack[-1]\n   has_matched=dispatcher. match(context)\n   if has_matched is not None :\n    self. context_stack. pop()\n  return has_matched\n  \n def search(self,pattern_codes):\n  flags=0\n  if pattern_codes[0]==OPCODES[\"info\"]:\n  \n  \n   if pattern_codes[2]&SRE_INFO_PREFIX and pattern_codes[5]>1:\n    return self. fast_search(pattern_codes)\n   flags=pattern_codes[2]\n   pattern_codes=pattern_codes[pattern_codes[1]+1:]\n   \n  string_position=self. start\n  if pattern_codes[0]==OPCODES[\"literal\"]:\n  \n  \n   character=pattern_codes[1]\n   while True :\n    while string_position <self. end    and ord(self. string[string_position])!=character:\n     string_position +=1\n    if string_position >=self. end:\n     return False\n    self. start=string_position\n    string_position +=1\n    self. string_position=string_position\n    if flags&SRE_INFO_LITERAL:\n     return True\n    if self. match(pattern_codes[2:]):\n     return True\n   return False\n   \n   \n  while string_position <=self. end:\n   self. reset()\n   self. start=self. string_position=string_position\n   if self. match(pattern_codes):\n    return True\n   string_position +=1\n  return False\n  \n def fast_search(self,pattern_codes):\n  ''\n  \n  \n  \n  flags=pattern_codes[2]\n  prefix_len=pattern_codes[5]\n  prefix_skip=pattern_codes[6]\n  prefix=pattern_codes[7:7+prefix_len]\n  overlap=pattern_codes[7+prefix_len -1:pattern_codes[1]+1]\n  pattern_codes=pattern_codes[pattern_codes[1]+1:]\n  i=0\n  string_position=self. string_position\n  while string_position <self. end:\n   while True :\n    if ord(self. string[string_position])!=prefix[i]:\n     if i ==0:\n      break\n     else :\n      i=overlap[i]\n    else :\n     i +=1\n     if i ==prefix_len:\n     \n      self. start=string_position+1 -prefix_len\n      self. string_position=string_position+1      -prefix_len+prefix_skip\n      if flags&SRE_INFO_LITERAL:\n       return True\n      if self. match(pattern_codes[2 *prefix_skip:]):\n       return True\n      i=overlap[i]\n     break\n   string_position +=1\n  return False\n  \n def set_mark(self,mark_nr,position):\n  if mark_nr&1:\n  \n  \n  \n   self. lastindex=mark_nr //2+1\n  if mark_nr >=len(self. marks):\n   self. marks. extend([None ]*(mark_nr -len(self. marks)+1))\n  self. marks[mark_nr]=position\n  \n def get_marks(self,group_index):\n  marks_index=2 *group_index\n  if len(self. marks)>marks_index+1:\n   return self. marks[marks_index],self. marks[marks_index+1]\n  else :\n   return None ,None\n   \n def marks_push(self):\n  self. marks_stack. append((self. marks[:],self. lastindex))\n  \n def marks_pop(self):\n  self. marks,self. lastindex=self. marks_stack. pop()\n  \n def marks_pop_keep(self):\n  self. marks,self. lastindex=self. marks_stack[-1]\n  \n def marks_pop_discard(self):\n  self. marks_stack. pop()\n  \n def lower(self,char_ord):\n  return getlower(char_ord,self. flags)\n  \n  \nclass _MatchContext:\n\n def __init__(self,state,pattern_codes):\n  self. state=state\n  self. pattern_codes=pattern_codes\n  self. string_position=state. string_position\n  self. code_position=0\n  self. has_matched=None\n  \n def push_new_context(self,pattern_offset):\n  ''\n\n  \n  child_context=_MatchContext(self. state,\n  self. pattern_codes[self. code_position+pattern_offset:])\n  \n  \n  \n  \n  self. state. context_stack. append(child_context)\n  return child_context\n  \n def peek_char(self,peek=0):\n  return self. state. string[self. string_position+peek]\n  \n def skip_char(self,skip_count):\n  self. string_position +=skip_count\n  \n def remaining_chars(self):\n  return self. state. end -self. string_position\n  \n def peek_code(self,peek=0):\n  return self. pattern_codes[self. code_position+peek]\n  \n def skip_code(self,skip_count):\n  self. code_position +=skip_count\n  \n def remaining_codes(self):\n  return len(self. pattern_codes)-self. code_position\n  \n def at_beginning(self):\n  return self. string_position ==0\n  \n def at_end(self):\n  return self. string_position ==self. state. end\n  \n def at_linebreak(self):\n  return not self. at_end()and _is_linebreak(self. peek_char())\n  \n def at_boundary(self,word_checker):\n  if self. at_beginning()and self. at_end():\n   return False\n  that=not self. at_beginning()and word_checker(self. peek_char(-1))\n  this=not self. at_end()and word_checker(self. peek_char())\n  return this !=that\n  \n  \nclass _RepeatContext(_MatchContext):\n\n def __init__(self,context):\n  _MatchContext. __init__(self,context. state,\n  context. pattern_codes[context. code_position:])\n  self. count=-1\n  \n  self. previous=context. state. repeat\n  self. last_position=None\n  \n  \nclass _Dispatcher:\n\n DISPATCH_TABLE=None\n \n def dispatch(self,code,context):\n  method=self. DISPATCH_TABLE. get(code,self. __class__. unknown)\n  return method(self,context)\n  \n def unknown(self,code,ctx):\n  raise NotImplementedError()\n  \n def build_dispatch_table(cls,code_dict,method_prefix):\n  if cls. DISPATCH_TABLE is not None :\n   return\n  table={}\n  for key,value in code_dict. items():\n   if hasattr(cls,\"%s%s\"%(method_prefix,key)):\n    table[value]=getattr(cls,\"%s%s\"%(method_prefix,key))\n  cls. DISPATCH_TABLE=table\n  \n build_dispatch_table=classmethod(build_dispatch_table)\n \n \nclass _OpcodeDispatcher(_Dispatcher):\n\n def __init__(self):\n  self. executing_contexts={}\n  self. at_dispatcher=_AtcodeDispatcher()\n  self. ch_dispatcher=_ChcodeDispatcher()\n  self. set_dispatcher=_CharsetDispatcher()\n  \n def match(self,context):\n  ''\n\n  \n  while context. remaining_codes()>0 and context. has_matched is None :\n   opcode=context. peek_code()\n   if not self. dispatch(opcode,context):\n    return None\n  if context. has_matched is None :\n   context. has_matched=False\n  return context. has_matched\n  \n def dispatch(self,opcode,context):\n  ''\n  \n  \n  if id(context)in self. executing_contexts:\n   generator=self. executing_contexts[id(context)]\n   del self. executing_contexts[id(context)]\n   has_finished=next(generator)\n  else :\n   method=self. DISPATCH_TABLE. get(opcode,_OpcodeDispatcher. unknown)\n   has_finished=method(self,context)\n   if hasattr(has_finished,\"__next__\"):\n    generator=has_finished\n    has_finished=next(generator)\n  if not has_finished:\n   self. executing_contexts[id(context)]=generator\n  return has_finished\n  \n def op_success(self,ctx):\n \n \n  ctx. state. string_position=ctx. string_position\n  ctx. has_matched=True\n  return True\n  \n def op_failure(self,ctx):\n \n \n  ctx. has_matched=False\n  return True\n  \n def general_op_literal(self,ctx,compare,decorate=lambda x:x):\n \n  if ctx. at_end()or not compare(decorate(ord(ctx. peek_char())),\n  decorate(ctx. peek_code(1))):\n   ctx. has_matched=False\n  ctx. skip_code(2)\n  ctx. skip_char(1)\n  \n def op_literal(self,ctx):\n \n \n \n  self. general_op_literal(ctx,operator. eq)\n  return True\n  \n def op_not_literal(self,ctx):\n \n \n \n  self. general_op_literal(ctx,operator. ne)\n  return True\n  \n def op_literal_ignore(self,ctx):\n \n \n \n  self. general_op_literal(ctx,operator. eq,ctx. state. lower)\n  return True\n  \n def op_not_literal_ignore(self,ctx):\n \n \n \n  self. general_op_literal(ctx,operator. ne,ctx. state. lower)\n  return True\n  \n def op_at(self,ctx):\n \n \n \n  if not self. at_dispatcher. dispatch(ctx. peek_code(1),ctx):\n   ctx. has_matched=False\n   \n   return True\n  ctx. skip_code(2)\n  return True\n  \n def op_category(self,ctx):\n \n \n \n  if ctx. at_end()or not self. ch_dispatcher. dispatch(ctx. peek_code(1),ctx):\n   ctx. has_matched=False\n   \n   return True\n  ctx. skip_code(2)\n  ctx. skip_char(1)\n  return True\n  \n def op_any(self,ctx):\n \n \n \n  if ctx. at_end()or ctx. at_linebreak():\n   ctx. has_matched=False\n   \n   return True\n  ctx. skip_code(1)\n  ctx. skip_char(1)\n  return True\n  \n def op_any_all(self,ctx):\n \n \n \n  if ctx. at_end():\n   ctx. has_matched=False\n   \n   return True\n  ctx. skip_code(1)\n  ctx. skip_char(1)\n  return True\n  \n def general_op_in(self,ctx,decorate=lambda x:x):\n \n \n  if ctx. at_end():\n   ctx. has_matched=False\n   \n   return\n  skip=ctx. peek_code(1)\n  ctx. skip_code(2)\n  \n  \n  if not self. check_charset(ctx,decorate(ord(ctx. peek_char()))):\n  \n   ctx. has_matched=False\n   return\n  ctx. skip_code(skip -1)\n  ctx. skip_char(1)\n  \n  \n def op_in(self,ctx):\n \n \n \n  self. general_op_in(ctx)\n  return True\n  \n def op_in_ignore(self,ctx):\n \n \n \n  self. general_op_in(ctx,ctx. state. lower)\n  return True\n  \n def op_jump(self,ctx):\n \n \n \n  ctx. skip_code(ctx. peek_code(1)+1)\n  return True\n  \n  \n  \n op_info=op_jump\n \n def op_mark(self,ctx):\n \n \n \n  ctx. state. set_mark(ctx. peek_code(1),ctx. string_position)\n  ctx. skip_code(2)\n  return True\n  \n def op_branch(self,ctx):\n \n \n \n  ctx. state. marks_push()\n  ctx. skip_code(1)\n  current_branch_length=ctx. peek_code(0)\n  while current_branch_length:\n  \n  \n   if not (ctx. peek_code(1)==OPCODES[\"literal\"]and   (ctx. at_end()or ctx. peek_code(2)!=ord(ctx. peek_char()))):\n    ctx. state. string_position=ctx. string_position\n    child_context=ctx. push_new_context(1)\n    \n    yield False\n    if child_context. has_matched:\n     ctx. has_matched=True\n     yield True\n    ctx. state. marks_pop_keep()\n   ctx. skip_code(current_branch_length)\n   current_branch_length=ctx. peek_code(0)\n  ctx. state. marks_pop_discard()\n  ctx. has_matched=False\n  \n  yield True\n  \n def op_repeat_one(self,ctx):\n \n \n \n \n  mincount=ctx. peek_code(2)\n  maxcount=ctx. peek_code(3)\n  \n  \n  \n  if ctx. remaining_chars()<mincount:\n   ctx. has_matched=False\n   yield True\n  ctx. state. string_position=ctx. string_position\n  count=self. count_repetitions(ctx,maxcount)\n  ctx. skip_char(count)\n  if count <mincount:\n   ctx. has_matched=False\n   yield True\n  if ctx. peek_code(ctx. peek_code(1)+1)==OPCODES[\"success\"]:\n  \n   ctx. state. string_position=ctx. string_position\n   ctx. has_matched=True\n   yield True\n   \n  ctx. state. marks_push()\n  if ctx. peek_code(ctx. peek_code(1)+1)==OPCODES[\"literal\"]:\n  \n  \n   char=ctx. peek_code(ctx. peek_code(1)+2)\n   while True :\n    while count >=mincount and    (ctx. at_end()or ord(ctx. peek_char())!=char):\n     ctx. skip_char(-1)\n     count -=1\n    if count <mincount:\n     break\n    ctx. state. string_position=ctx. string_position\n    child_context=ctx. push_new_context(ctx. peek_code(1)+1)\n    \n    yield False\n    if child_context. has_matched:\n     ctx. has_matched=True\n     yield True\n    ctx. skip_char(-1)\n    count -=1\n    ctx. state. marks_pop_keep()\n    \n  else :\n  \n   while count >=mincount:\n    ctx. state. string_position=ctx. string_position\n    child_context=ctx. push_new_context(ctx. peek_code(1)+1)\n    yield False\n    if child_context. has_matched:\n     ctx. has_matched=True\n     yield True\n    ctx. skip_char(-1)\n    count -=1\n    ctx. state. marks_pop_keep()\n    \n  ctx. state. marks_pop_discard()\n  ctx. has_matched=False\n  \n  yield True\n  \n def op_min_repeat_one(self,ctx):\n \n \n  mincount=ctx. peek_code(2)\n  maxcount=ctx. peek_code(3)\n  \n  \n  if ctx. remaining_chars()<mincount:\n   ctx. has_matched=False\n   yield True\n  ctx. state. string_position=ctx. string_position\n  if mincount ==0:\n   count=0\n  else :\n   count=self. count_repetitions(ctx,mincount)\n   if count <mincount:\n    ctx. has_matched=False\n    \n    yield True\n   ctx. skip_char(count)\n  if ctx. peek_code(ctx. peek_code(1)+1)==OPCODES[\"success\"]:\n  \n   ctx. state. string_position=ctx. string_position\n   ctx. has_matched=True\n   yield True\n   \n  ctx. state. marks_push()\n  while maxcount ==MAXREPEAT or count <=maxcount:\n   ctx. state. string_position=ctx. string_position\n   child_context=ctx. push_new_context(ctx. peek_code(1)+1)\n   \n   yield False\n   if child_context. has_matched:\n    ctx. has_matched=True\n    yield True\n   ctx. state. string_position=ctx. string_position\n   if self. count_repetitions(ctx,1)==0:\n    break\n   ctx. skip_char(1)\n   count +=1\n   ctx. state. marks_pop_keep()\n   \n  ctx. state. marks_pop_discard()\n  ctx. has_matched=False\n  yield True\n  \n def op_repeat(self,ctx):\n \n \n \n \n \n \n \n \n \n  repeat=_RepeatContext(ctx)\n  ctx. state. repeat=repeat\n  ctx. state. string_position=ctx. string_position\n  child_context=ctx. push_new_context(ctx. peek_code(1)+1)\n  \n  \n  \n  \n  yield False\n  ctx. state. repeat=repeat. previous\n  ctx. has_matched=child_context. has_matched\n  yield True\n  \n def op_max_until(self,ctx):\n \n \n  repeat=ctx. state. repeat\n  \n  if repeat is None :\n  \n   raise RuntimeError(\"Internal re error: MAX_UNTIL without REPEAT.\")\n  mincount=repeat. peek_code(2)\n  maxcount=repeat. peek_code(3)\n  ctx. state. string_position=ctx. string_position\n  count=repeat. count+1\n  \n  \n  if count <mincount:\n  \n   repeat. count=count\n   child_context=repeat. push_new_context(4)\n   yield False\n   ctx. has_matched=child_context. has_matched\n   if not ctx. has_matched:\n    repeat. count=count -1\n    ctx. state. string_position=ctx. string_position\n   yield True\n   \n  if (count <maxcount or maxcount ==MAXREPEAT)  and ctx. state. string_position !=repeat. last_position:\n  \n   repeat. count=count\n   ctx. state. marks_push()\n   save_last_position=repeat. last_position\n   repeat. last_position=ctx. state. string_position\n   child_context=repeat. push_new_context(4)\n   yield False\n   repeat. last_position=save_last_position\n   if child_context. has_matched:\n    ctx. state. marks_pop_discard()\n    ctx. has_matched=True\n    yield True\n   ctx. state. marks_pop()\n   repeat. count=count -1\n   ctx. state. string_position=ctx. string_position\n   \n   \n  ctx. state. repeat=repeat. previous\n  child_context=ctx. push_new_context(1)\n  \n  yield False\n  ctx. has_matched=child_context. has_matched\n  if not ctx. has_matched:\n   ctx. state. repeat=repeat\n   ctx. state. string_position=ctx. string_position\n  yield True\n  \n def op_min_until(self,ctx):\n \n \n  repeat=ctx. state. repeat\n  if repeat is None :\n   raise RuntimeError(\"Internal re error: MIN_UNTIL without REPEAT.\")\n  mincount=repeat. peek_code(2)\n  maxcount=repeat. peek_code(3)\n  ctx. state. string_position=ctx. string_position\n  count=repeat. count+1\n  \n  \n  if count <mincount:\n  \n   repeat. count=count\n   child_context=repeat. push_new_context(4)\n   yield False\n   ctx. has_matched=child_context. has_matched\n   if not ctx. has_matched:\n    repeat. count=count -1\n    ctx. state. string_position=ctx. string_position\n   yield True\n   \n   \n  ctx. state. marks_push()\n  ctx. state. repeat=repeat. previous\n  child_context=ctx. push_new_context(1)\n  \n  yield False\n  if child_context. has_matched:\n   ctx. has_matched=True\n   yield True\n  ctx. state. repeat=repeat\n  ctx. state. string_position=ctx. string_position\n  ctx. state. marks_pop()\n  \n  \n  if count >=maxcount and maxcount !=MAXREPEAT:\n   ctx. has_matched=False\n   \n   yield True\n  repeat. count=count\n  child_context=repeat. push_new_context(4)\n  yield False\n  ctx. has_matched=child_context. has_matched\n  if not ctx. has_matched:\n   repeat. count=count -1\n   ctx. state. string_position=ctx. string_position\n  yield True\n  \n def general_op_groupref(self,ctx,decorate=lambda x:x):\n  group_start,group_end=ctx. state. get_marks(ctx. peek_code(1))\n  if group_start is None or group_end is None or group_end <group_start:\n   ctx. has_matched=False\n   return True\n  while group_start <group_end:\n   if ctx. at_end()or decorate(ord(ctx. peek_char()))   !=decorate(ord(ctx. state. string[group_start])):\n    ctx. has_matched=False\n    \n    return True\n   group_start +=1\n   ctx. skip_char(1)\n  ctx. skip_code(2)\n  return True\n  \n def op_groupref(self,ctx):\n \n \n \n  return self. general_op_groupref(ctx)\n  \n def op_groupref_ignore(self,ctx):\n \n \n \n  return self. general_op_groupref(ctx,ctx. state. lower)\n  \n def op_groupref_exists(self,ctx):\n \n \n  group_start,group_end=ctx. state. get_marks(ctx. peek_code(1))\n  if group_start is None or group_end is None or group_end <group_start:\n   ctx. skip_code(ctx. peek_code(2)+1)\n  else :\n   ctx. skip_code(3)\n  return True\n  \n def op_assert(self,ctx):\n \n \n \n  ctx. state. string_position=ctx. string_position -ctx. peek_code(2)\n  if ctx. state. string_position <0:\n   ctx. has_matched=False\n   yield True\n  child_context=ctx. push_new_context(3)\n  yield False\n  if child_context. has_matched:\n   ctx. skip_code(ctx. peek_code(1)+1)\n  else :\n   ctx. has_matched=False\n  yield True\n  \n def op_assert_not(self,ctx):\n \n \n \n  ctx. state. string_position=ctx. string_position -ctx. peek_code(2)\n  if ctx. state. string_position >=0:\n   child_context=ctx. push_new_context(3)\n   yield False\n   if child_context. has_matched:\n    ctx. has_matched=False\n    yield True\n  ctx. skip_code(ctx. peek_code(1)+1)\n  yield True\n  \n def unknown(self,ctx):\n \n  raise RuntimeError(\"Internal re error. Unknown opcode: %s\"%ctx. peek_code())\n  \n def check_charset(self,ctx,char):\n  ''\n  \n  self. set_dispatcher. reset(char)\n  save_position=ctx. code_position\n  result=None\n  while result is None :\n   result=self. set_dispatcher. dispatch(ctx. peek_code(),ctx)\n  ctx. code_position=save_position\n  \n  return result\n  \n def count_repetitions(self,ctx,maxcount):\n  ''\n\n  \n  count=0\n  real_maxcount=ctx. state. end -ctx. string_position\n  if maxcount <real_maxcount and maxcount !=MAXREPEAT:\n   real_maxcount=maxcount\n   \n   \n   \n  code_position=ctx. code_position\n  string_position=ctx. string_position\n  ctx. skip_code(4)\n  reset_position=ctx. code_position\n  while count <real_maxcount:\n  \n  \n   ctx. code_position=reset_position\n   self. dispatch(ctx. peek_code(),ctx)\n   \n   if ctx. has_matched is False :\n    break\n   count +=1\n  ctx. has_matched=None\n  ctx. code_position=code_position\n  ctx. string_position=string_position\n  return count\n  \n def _log(self,context,opname,*args):\n  arg_string=(\"%s \"*len(args))%args\n  _log(\"|%s|%s|%s %s\"%(context. pattern_codes,\n  context. string_position,opname,arg_string))\n  \n_OpcodeDispatcher. build_dispatch_table(OPCODES,\"op_\")\n\n\nclass _CharsetDispatcher(_Dispatcher):\n\n def __init__(self):\n  self. ch_dispatcher=_ChcodeDispatcher()\n  \n def reset(self,char):\n  self. char=char\n  self. ok=True\n  \n def set_failure(self,ctx):\n  return not self. ok\n def set_literal(self,ctx):\n \n  if ctx. peek_code(1)==self. char:\n   return self. ok\n  else :\n   ctx. skip_code(2)\n def set_category(self,ctx):\n \n  if self. ch_dispatcher. dispatch(ctx. peek_code(1),ctx):\n   return self. ok\n  else :\n   ctx. skip_code(2)\n def set_charset(self,ctx):\n \n  char_code=self. char\n  ctx. skip_code(1)\n  if CODESIZE ==2:\n   if char_code <256 and ctx. peek_code(char_code >>4)   &(1 <<(char_code&15)):\n    return self. ok\n   ctx. skip_code(16)\n  else :\n   if char_code <256 and ctx. peek_code(char_code >>5)   &(1 <<(char_code&31)):\n    return self. ok\n   ctx. skip_code(8)\n def set_range(self,ctx):\n \n  if ctx. peek_code(1)<=self. char <=ctx. peek_code(2):\n   return self. ok\n  ctx. skip_code(3)\n def set_negate(self,ctx):\n  self. ok=not self. ok\n  ctx. skip_code(1)\n  \n  \n def set_bigcharset(self,ctx):\n  raise NotImplementationError(\"_sre.py: set_bigcharset, array not implemented\")\n  \n  char_code=self. char\n  count=ctx. peek_code(1)\n  ctx. skip_code(2)\n  if char_code <65536:\n   block_index=char_code >>8\n   \n   a=array. array(\"B\")\n   a. fromstring(array. array(CODESIZE ==2 and\"H\"or\"I\",\n   [ctx. peek_code(block_index //CODESIZE)]). tostring())\n   block=a[block_index %CODESIZE]\n   ctx. skip_code(256 //CODESIZE)\n   block_value=ctx. peek_code(block *(32 //CODESIZE)\n   +((char_code&255)>>(CODESIZE ==2 and 4 or 5)))\n   if block_value&(1 <<(char_code&((8 *CODESIZE)-1))):\n    return self. ok\n  else :\n   ctx. skip_code(256 //CODESIZE)\n  ctx. skip_code(count *(32 //CODESIZE))\n  \n def unknown(self,ctx):\n  return False\n  \n_CharsetDispatcher. build_dispatch_table(OPCODES,\"set_\")\n\n\nclass _AtcodeDispatcher(_Dispatcher):\n\n def at_beginning(self,ctx):\n  return ctx. at_beginning()\n at_beginning_string=at_beginning\n def at_beginning_line(self,ctx):\n  return ctx. at_beginning()or _is_linebreak(ctx. peek_char(-1))\n def at_end(self,ctx):\n  return (ctx. remaining_chars()==1 and ctx. at_linebreak())or ctx. at_end()\n def at_end_line(self,ctx):\n  return ctx. at_linebreak()or ctx. at_end()\n def at_end_string(self,ctx):\n  return ctx. at_end()\n def at_boundary(self,ctx):\n  return ctx. at_boundary(_is_word)\n def at_non_boundary(self,ctx):\n  return not ctx. at_boundary(_is_word)\n def at_loc_boundary(self,ctx):\n  return ctx. at_boundary(_is_loc_word)\n def at_loc_non_boundary(self,ctx):\n  return not ctx. at_boundary(_is_loc_word)\n def at_uni_boundary(self,ctx):\n  return ctx. at_boundary(_is_uni_word)\n def at_uni_non_boundary(self,ctx):\n  return not ctx. at_boundary(_is_uni_word)\n def unknown(self,ctx):\n  return False\n  \n_AtcodeDispatcher. build_dispatch_table(ATCODES,\"\")\n\n\nclass _ChcodeDispatcher(_Dispatcher):\n\n def category_digit(self,ctx):\n  return _is_digit(ctx. peek_char())\n def category_not_digit(self,ctx):\n  return not _is_digit(ctx. peek_char())\n def category_space(self,ctx):\n  return _is_space(ctx. peek_char())\n def category_not_space(self,ctx):\n  return not _is_space(ctx. peek_char())\n def category_word(self,ctx):\n  return _is_word(ctx. peek_char())\n def category_not_word(self,ctx):\n  return not _is_word(ctx. peek_char())\n def category_linebreak(self,ctx):\n  return _is_linebreak(ctx. peek_char())\n def category_not_linebreak(self,ctx):\n  return not _is_linebreak(ctx. peek_char())\n def category_loc_word(self,ctx):\n  return _is_loc_word(ctx. peek_char())\n def category_loc_not_word(self,ctx):\n  return not _is_loc_word(ctx. peek_char())\n def category_uni_digit(self,ctx):\n  return ctx. peek_char(). isdigit()\n def category_uni_not_digit(self,ctx):\n  return not ctx. peek_char(). isdigit()\n def category_uni_space(self,ctx):\n  return ctx. peek_char(). isspace()\n def category_uni_not_space(self,ctx):\n  return not ctx. peek_char(). isspace()\n def category_uni_word(self,ctx):\n  return _is_uni_word(ctx. peek_char())\n def category_uni_not_word(self,ctx):\n  return not _is_uni_word(ctx. peek_char())\n def category_uni_linebreak(self,ctx):\n  return ord(ctx. peek_char())in _uni_linebreaks\n def category_uni_not_linebreak(self,ctx):\n  return ord(ctx. peek_char())not in _uni_linebreaks\n def unknown(self,ctx):\n  return False\n  \n_ChcodeDispatcher. build_dispatch_table(CHCODES,\"\")\n\n\n_ascii_char_info=[0,0,0,0,0,0,0,0,0,2,6,2,\n2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,25,25,25,25,25,25,25,25,\n25,25,0,0,0,0,0,0,0,24,24,24,24,24,24,24,24,24,24,\n24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,0,0,\n0,0,16,0,24,24,24,24,24,24,24,24,24,24,24,24,24,24,\n24,24,24,24,24,24,24,24,24,24,24,24,0,0,0,0,0]\n\ndef _is_digit(char):\n code=ord(char)\n return code <128 and _ascii_char_info[code]&1\n \ndef _is_space(char):\n code=ord(char)\n return code <128 and _ascii_char_info[code]&2\n \ndef _is_word(char):\n\n code=ord(char)\n return code <128 and _ascii_char_info[code]&16\n \ndef _is_loc_word(char):\n return (not (ord(char)&~255)and char. isalnum())or char =='_'\n \ndef _is_uni_word(char):\n\n\n return chr(ord(char)). isalnum()or char =='_'\n \ndef _is_linebreak(char):\n return char ==\"\\n\"\n \n \n_uni_linebreaks=[10,13,28,29,30,133,8232,8233]\n\ndef _log(message):\n if 0:\n  print(message)\n"], "copyreg": [".py", "''\n\n\n\n\n\n__all__=[\"pickle\",\"constructor\",\n\"add_extension\",\"remove_extension\",\"clear_extension_cache\"]\n\ndispatch_table={}\n\ndef pickle(ob_type,pickle_function,constructor_ob=None ):\n if not callable(pickle_function):\n  raise TypeError(\"reduction functions must be callable\")\n dispatch_table[ob_type]=pickle_function\n \n \n \n if constructor_ob is not None :\n  constructor(constructor_ob)\n  \ndef constructor(object):\n if not callable(object):\n  raise TypeError(\"constructors must be callable\")\n  \n  \n  \ntry :\n complex\nexcept NameError:\n pass\nelse :\n\n def pickle_complex(c):\n  return complex,(c. real,c. imag)\n  \n pickle(complex,pickle_complex,complex)\n \n \n \ndef _reconstructor(cls,base,state):\n if base is object:\n  obj=object. __new__(cls)\n else :\n  obj=base. __new__(cls,state)\n  if base. __init__ !=object. __init__:\n   base. __init__(obj,state)\n return obj\n \n_HEAPTYPE=1 <<9\n\n\n\ndef _reduce_ex(self,proto):\n assert proto <2\n for base in self. __class__. __mro__:\n  if hasattr(base,'__flags__')and not base. __flags__&_HEAPTYPE:\n   break\n else :\n  base=object\n if base is object:\n  state=None\n else :\n  if base is self. __class__:\n   raise TypeError(\"can't pickle %s objects\"%base. __name__)\n  state=base(self)\n args=(self. __class__,base,state)\n try :\n  getstate=self. __getstate__\n except AttributeError:\n  if getattr(self,\"__slots__\",None ):\n   raise TypeError(\"a class that defines __slots__ without \"\n   \"defining __getstate__ cannot be pickled\")\n  try :\n   dict=self. __dict__\n  except AttributeError:\n   dict=None\n else :\n  dict=getstate()\n if dict:\n  return _reconstructor,args,dict\n else :\n  return _reconstructor,args\n  \n  \n  \ndef __newobj__(cls,*args):\n return cls. __new__(cls,*args)\n \ndef _slotnames(cls):\n ''\n\n\n\n\n\n\n\n \n \n \n names=cls. __dict__. get(\"__slotnames__\")\n if names is not None :\n  return names\n  \n  \n names=[]\n if not hasattr(cls,\"__slots__\"):\n \n  pass\n else :\n \n  for c in cls. __mro__:\n   if\"__slots__\"in c. __dict__:\n    slots=c. __dict__['__slots__']\n    \n    if isinstance(slots,str):\n     slots=(slots,)\n    for name in slots:\n    \n     if name in (\"__dict__\",\"__weakref__\"):\n      continue\n      \n     elif name. startswith('__')and not name. endswith('__'):\n      names. append('_%s%s'%(c. __name__,name))\n     else :\n      names. append(name)\n      \n      \n try :\n  cls. __slotnames__=names\n except :\n  pass\n  \n return names\n \n \n \n \n \n \n \n \n \n \n_extension_registry={}\n_inverted_registry={}\n_extension_cache={}\n\n\n\ndef add_extension(module,name,code):\n ''\n code=int(code)\n if not 1 <=code <=0x7fffffff:\n  raise ValueError(\"code out of range\")\n key=(module,name)\n if (_extension_registry. get(key)==code and\n _inverted_registry. get(code)==key):\n  return\n if key in _extension_registry:\n  raise ValueError(\"key %s is already registered with code %s\"%\n  (key,_extension_registry[key]))\n if code in _inverted_registry:\n  raise ValueError(\"code %s is already in use for key %s\"%\n  (code,_inverted_registry[code]))\n _extension_registry[key]=code\n _inverted_registry[code]=key\n \ndef remove_extension(module,name,code):\n ''\n key=(module,name)\n if (_extension_registry. get(key)!=code or\n _inverted_registry. get(code)!=key):\n  raise ValueError(\"key %s is not registered with code %s\"%\n  (key,code))\n del _extension_registry[key]\n del _inverted_registry[code]\n if code in _extension_cache:\n  del _extension_cache[code]\n  \ndef clear_extension_cache():\n _extension_cache. clear()\n \n \n \n \n \n \n \n \n \n \n \n \n \n"], "stat": [".py", "''\n\n\n\n\n\n\nST_MODE=0\nST_INO=1\nST_DEV=2\nST_NLINK=3\nST_UID=4\nST_GID=5\nST_SIZE=6\nST_ATIME=7\nST_MTIME=8\nST_CTIME=9\n\n\n\ndef S_IMODE(mode):\n ''\n\n \n return mode&0o7777\n \ndef S_IFMT(mode):\n ''\n\n \n return mode&0o170000\n \n \n \n \nS_IFDIR=0o040000\nS_IFCHR=0o020000\nS_IFBLK=0o060000\nS_IFREG=0o100000\nS_IFIFO=0o010000\nS_IFLNK=0o120000\nS_IFSOCK=0o140000\n\n\n\ndef S_ISDIR(mode):\n ''\n return S_IFMT(mode)==S_IFDIR\n \ndef S_ISCHR(mode):\n ''\n return S_IFMT(mode)==S_IFCHR\n \ndef S_ISBLK(mode):\n ''\n return S_IFMT(mode)==S_IFBLK\n \ndef S_ISREG(mode):\n ''\n return S_IFMT(mode)==S_IFREG\n \ndef S_ISFIFO(mode):\n ''\n return S_IFMT(mode)==S_IFIFO\n \ndef S_ISLNK(mode):\n ''\n return S_IFMT(mode)==S_IFLNK\n \ndef S_ISSOCK(mode):\n ''\n return S_IFMT(mode)==S_IFSOCK\n \n \n \nS_ISUID=0o4000\nS_ISGID=0o2000\nS_ENFMT=S_ISGID\nS_ISVTX=0o1000\nS_IREAD=0o0400\nS_IWRITE=0o0200\nS_IEXEC=0o0100\nS_IRWXU=0o0700\nS_IRUSR=0o0400\nS_IWUSR=0o0200\nS_IXUSR=0o0100\nS_IRWXG=0o0070\nS_IRGRP=0o0040\nS_IWGRP=0o0020\nS_IXGRP=0o0010\nS_IRWXO=0o0007\nS_IROTH=0o0004\nS_IWOTH=0o0002\nS_IXOTH=0o0001\n\n\n\nUF_NODUMP=0x00000001\nUF_IMMUTABLE=0x00000002\nUF_APPEND=0x00000004\nUF_OPAQUE=0x00000008\nUF_NOUNLINK=0x00000010\nUF_COMPRESSED=0x00000020\nUF_HIDDEN=0x00008000\nSF_ARCHIVED=0x00010000\nSF_IMMUTABLE=0x00020000\nSF_APPEND=0x00040000\nSF_NOUNLINK=0x00100000\nSF_SNAPSHOT=0x00200000\n\n\n_filemode_table=(\n((S_IFLNK,\"l\"),\n(S_IFREG,\"-\"),\n(S_IFBLK,\"b\"),\n(S_IFDIR,\"d\"),\n(S_IFCHR,\"c\"),\n(S_IFIFO,\"p\")),\n\n((S_IRUSR,\"r\"),),\n((S_IWUSR,\"w\"),),\n((S_IXUSR |S_ISUID,\"s\"),\n(S_ISUID,\"S\"),\n(S_IXUSR,\"x\")),\n\n((S_IRGRP,\"r\"),),\n((S_IWGRP,\"w\"),),\n((S_IXGRP |S_ISGID,\"s\"),\n(S_ISGID,\"S\"),\n(S_IXGRP,\"x\")),\n\n((S_IROTH,\"r\"),),\n((S_IWOTH,\"w\"),),\n((S_IXOTH |S_ISVTX,\"t\"),\n(S_ISVTX,\"T\"),\n(S_IXOTH,\"x\"))\n)\n\ndef filemode(mode):\n ''\n perm=[]\n for table in _filemode_table:\n  for bit,char in table:\n   if mode&bit ==bit:\n    perm. append(char)\n    break\n  else :\n   perm. append(\"-\")\n return\"\". join(perm)\n"], "abc": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n\nfrom _weakrefset import WeakSet\n\ndef abstractmethod(funcobj):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n funcobj. __isabstractmethod__=True\n return funcobj\n \n \nclass abstractclassmethod(classmethod):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __isabstractmethod__=True\n \n def __init__(self,callable):\n  callable. __isabstractmethod__=True\n  super(). __init__(callable)\n  \n  \nclass abstractstaticmethod(staticmethod):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __isabstractmethod__=True\n \n def __init__(self,callable):\n  callable. __isabstractmethod__=True\n  super(). __init__(callable)\n  \n  \nclass abstractproperty(property):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __isabstractmethod__=True\n \n \nclass ABCMeta(type):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n _abc_invalidation_counter=0\n \n def __new__(mcls,name,bases,namespace):\n  cls=super(). __new__(mcls,name,bases,namespace)\n  \n  abstracts={name\n  for name,value in namespace. items()\n  if getattr(value,\"__isabstractmethod__\",False )}\n  for base in bases:\n   for name in getattr(base,\"__abstractmethods__\",set()):\n    value=getattr(cls,name,None )\n    if getattr(value,\"__isabstractmethod__\",False ):\n     abstracts. add(name)\n  cls. __abstractmethods__=frozenset(abstracts)\n  \n  cls. _abc_registry=WeakSet()\n  cls. _abc_cache=WeakSet()\n  cls. _abc_negative_cache=WeakSet()\n  cls. _abc_negative_cache_version=ABCMeta. _abc_invalidation_counter\n  return cls\n  \n def register(cls,subclass):\n  ''\n\n\n  \n  if not isinstance(subclass,type):\n   raise TypeError(\"Can only register classes\")\n  if issubclass(subclass,cls):\n   return subclass\n   \n   \n  if issubclass(cls,subclass):\n  \n   raise RuntimeError(\"Refusing to create an inheritance cycle\")\n  cls. _abc_registry. add(subclass)\n  ABCMeta. _abc_invalidation_counter +=1\n  return subclass\n  \n def _dump_registry(cls,file=None ):\n  ''\n  print(\"Class: %s.%s\"%(cls. __module__,cls. __name__),file=file)\n  print(\"Inv.counter: %s\"%ABCMeta. _abc_invalidation_counter,file=file)\n  for name in sorted(cls. __dict__. keys()):\n   if name. startswith(\"_abc_\"):\n    value=getattr(cls,name)\n    print(\"%s: %r\"%(name,value),file=file)\n    \n def __instancecheck__(cls,instance):\n  ''\n  \n  subclass=instance. __class__\n  if subclass in cls. _abc_cache:\n   return True\n  subtype=type(instance)\n  if subtype is subclass:\n   if (cls. _abc_negative_cache_version ==\n   ABCMeta. _abc_invalidation_counter and\n   subclass in cls. _abc_negative_cache):\n    return False\n    \n   return cls. __subclasscheck__(subclass)\n  return any(cls. __subclasscheck__(c)for c in {subclass,subtype})\n  \n def __subclasscheck__(cls,subclass):\n  ''\n  \n  if subclass in cls. _abc_cache:\n   return True\n   \n  if cls. _abc_negative_cache_version <ABCMeta. _abc_invalidation_counter:\n  \n   cls. _abc_negative_cache=WeakSet()\n   cls. _abc_negative_cache_version=ABCMeta. _abc_invalidation_counter\n  elif subclass in cls. _abc_negative_cache:\n   return False\n   \n  ok=cls. __subclasshook__(subclass)\n  if ok is not NotImplemented:\n   assert isinstance(ok,bool)\n   if ok:\n    cls. _abc_cache. add(subclass)\n   else :\n    cls. _abc_negative_cache. add(subclass)\n   return ok\n   \n  if cls in getattr(subclass,'__mro__',()):\n   cls. _abc_cache. add(subclass)\n   return True\n   \n  for rcls in cls. _abc_registry:\n   if issubclass(subclass,rcls):\n    cls. _abc_cache. add(subclass)\n    return True\n    \n  for scls in cls. __subclasses__():\n   if issubclass(subclass,scls):\n    cls. _abc_cache. add(subclass)\n    return True\n    \n  cls. _abc_negative_cache. add(subclass)\n  return False\n"], "codecs": [".py", "''\n\n\n\n\n\n\n\n\nimport builtins,sys\n\n\n\ntry :\n from _codecs import *\nexcept ImportError as why:\n raise SystemError('Failed to load the builtin codecs: %s'%why)\n \n__all__=[\"register\",\"lookup\",\"open\",\"EncodedFile\",\"BOM\",\"BOM_BE\",\n\"BOM_LE\",\"BOM32_BE\",\"BOM32_LE\",\"BOM64_BE\",\"BOM64_LE\",\n\"BOM_UTF8\",\"BOM_UTF16\",\"BOM_UTF16_LE\",\"BOM_UTF16_BE\",\n\"BOM_UTF32\",\"BOM_UTF32_LE\",\"BOM_UTF32_BE\",\n\"strict_errors\",\"ignore_errors\",\"replace_errors\",\n\"xmlcharrefreplace_errors\",\n\"register_error\",\"lookup_error\"]\n\n\n\n\n\n\n\n\n\n\nBOM_UTF8=b'\\xef\\xbb\\xbf'\n\n\nBOM_LE=BOM_UTF16_LE=b'\\xff\\xfe'\n\n\nBOM_BE=BOM_UTF16_BE=b'\\xfe\\xff'\n\n\nBOM_UTF32_LE=b'\\xff\\xfe\\x00\\x00'\n\n\nBOM_UTF32_BE=b'\\x00\\x00\\xfe\\xff'\n\nif sys. byteorder =='little':\n\n\n BOM=BOM_UTF16=BOM_UTF16_LE\n \n \n BOM_UTF32=BOM_UTF32_LE\n \nelse :\n\n\n BOM=BOM_UTF16=BOM_UTF16_BE\n \n \n BOM_UTF32=BOM_UTF32_BE\n \n \nBOM32_LE=BOM_UTF16_LE\nBOM32_BE=BOM_UTF16_BE\nBOM64_LE=BOM_UTF32_LE\nBOM64_BE=BOM_UTF32_BE\n\n\n\n\nclass CodecInfo(tuple):\n\n def __new__(cls,encode,decode,streamreader=None ,streamwriter=None ,\n incrementalencoder=None ,incrementaldecoder=None ,name=None ):\n  self=tuple. __new__(cls,(encode,decode,streamreader,streamwriter))\n  self. name=name\n  self. encode=encode\n  self. decode=decode\n  self. incrementalencoder=incrementalencoder\n  self. incrementaldecoder=incrementaldecoder\n  self. streamwriter=streamwriter\n  self. streamreader=streamreader\n  return self\n  \n def __repr__(self):\n  return\"<%s.%s object for encoding %s at 0x%x>\"%  (self. __class__. __module__,self. __class__. __name__,\n  self. name,id(self))\n  \nclass Codec:\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def encode(self,input,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError\n  \n def decode(self,input,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError\n  \nclass IncrementalEncoder(object):\n ''\n\n\n\n \n def __init__(self,errors='strict'):\n  ''\n\n\n\n\n\n  \n  self. errors=errors\n  self. buffer=\"\"\n  \n def encode(self,input,final=False ):\n  ''\n\n  \n  raise NotImplementedError\n  \n def reset(self):\n  ''\n\n  \n  \n def getstate(self):\n  ''\n\n  \n  return 0\n  \n def setstate(self,state):\n  ''\n\n\n  \n  \nclass BufferedIncrementalEncoder(IncrementalEncoder):\n ''\n\n\n\n \n def __init__(self,errors='strict'):\n  IncrementalEncoder. __init__(self,errors)\n  \n  self. buffer=\"\"\n  \n def _buffer_encode(self,input,errors,final):\n \n \n  raise NotImplementedError\n  \n def encode(self,input,final=False ):\n \n  data=self. buffer+input\n  (result,consumed)=self. _buffer_encode(data,self. errors,final)\n  \n  self. buffer=data[consumed:]\n  return result\n  \n def reset(self):\n  IncrementalEncoder. reset(self)\n  self. buffer=\"\"\n  \n def getstate(self):\n  return self. buffer or 0\n  \n def setstate(self,state):\n  self. buffer=state or\"\"\n  \nclass IncrementalDecoder(object):\n ''\n\n\n\n \n def __init__(self,errors='strict'):\n  ''\n\n\n\n\n\n  \n  self. errors=errors\n  \n def decode(self,input,final=False ):\n  ''\n\n  \n  raise NotImplementedError\n  \n def reset(self):\n  ''\n\n  \n  \n def getstate(self):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  return (b\"\",0)\n  \n def setstate(self,state):\n  ''\n\n\n\n\n  \n  \nclass BufferedIncrementalDecoder(IncrementalDecoder):\n ''\n\n\n\n \n def __init__(self,errors='strict'):\n  IncrementalDecoder. __init__(self,errors)\n  \n  self. buffer=b\"\"\n  \n def _buffer_decode(self,input,errors,final):\n \n \n  raise NotImplementedError\n  \n def decode(self,input,final=False ):\n \n  data=self. buffer+input\n  (result,consumed)=self. _buffer_decode(data,self. errors,final)\n  \n  self. buffer=data[consumed:]\n  return result\n  \n def reset(self):\n  IncrementalDecoder. reset(self)\n  self. buffer=b\"\"\n  \n def getstate(self):\n \n  return (self. buffer,0)\n  \n def setstate(self,state):\n \n  self. buffer=state[0]\n  \n  \n  \n  \n  \n  \n  \n  \nclass StreamWriter(Codec):\n\n def __init__(self,stream,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self. stream=stream\n  self. errors=errors\n  \n def write(self,object):\n \n  ''\n  \n  data,consumed=self. encode(object,self. errors)\n  self. stream. write(data)\n  \n def writelines(self,list):\n \n  ''\n\n  \n  self. write(''. join(list))\n  \n def reset(self):\n \n  ''\n\n\n\n\n\n\n  \n  pass\n  \n def seek(self,offset,whence=0):\n  self. stream. seek(offset,whence)\n  if whence ==0 and offset ==0:\n   self. reset()\n   \n def __getattr__(self,name,\n getattr=getattr):\n \n  ''\n  \n  return getattr(self. stream,name)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,type,value,tb):\n  self. stream. close()\n  \n  \n  \nclass StreamReader(Codec):\n\n charbuffertype=str\n \n def __init__(self,stream,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self. stream=stream\n  self. errors=errors\n  self. bytebuffer=b\"\"\n  self. _empty_charbuffer=self. charbuffertype()\n  self. charbuffer=self. _empty_charbuffer\n  self. linebuffer=None\n  \n def decode(self,input,errors='strict'):\n  raise NotImplementedError\n  \n def read(self,size=-1,chars=-1,firstline=False ):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if self. linebuffer:\n   self. charbuffer=self. _empty_charbuffer. join(self. linebuffer)\n   self. linebuffer=None\n   \n   \n  while True :\n  \n   if chars <0:\n    if size <0:\n     if self. charbuffer:\n      break\n    elif len(self. charbuffer)>=size:\n     break\n   else :\n    if len(self. charbuffer)>=chars:\n     break\n     \n   if size <0:\n    newdata=self. stream. read()\n   else :\n    newdata=self. stream. read(size)\n    \n   data=self. bytebuffer+newdata\n   try :\n    newchars,decodedbytes=self. decode(data,self. errors)\n   except UnicodeDecodeError as exc:\n    if firstline:\n     newchars,decodedbytes=     self. decode(data[:exc. start],self. errors)\n     lines=newchars. splitlines(keepends=True )\n     if len(lines)<=1:\n      raise\n    else :\n     raise\n     \n   self. bytebuffer=data[decodedbytes:]\n   \n   self. charbuffer +=newchars\n   \n   if not newdata:\n    break\n  if chars <0:\n  \n   result=self. charbuffer\n   self. charbuffer=self. _empty_charbuffer\n  else :\n  \n   result=self. charbuffer[:chars]\n   self. charbuffer=self. charbuffer[chars:]\n  return result\n  \n def readline(self,size=None ,keepends=True ):\n \n  ''\n\n\n\n\n\n  \n  \n  \n  if self. linebuffer:\n   line=self. linebuffer[0]\n   del self. linebuffer[0]\n   if len(self. linebuffer)==1:\n   \n   \n    self. charbuffer=self. linebuffer[0]\n    self. linebuffer=None\n   if not keepends:\n    line=line. splitlines(keepends=False )[0]\n   return line\n   \n  readsize=size or 72\n  line=self. _empty_charbuffer\n  \n  while True :\n   data=self. read(readsize,firstline=True )\n   if data:\n   \n   \n   \n    if (isinstance(data,str)and data. endswith(\"\\r\"))or    (isinstance(data,bytes)and data. endswith(b\"\\r\")):\n     data +=self. read(size=1,chars=1)\n     \n   line +=data\n   lines=line. splitlines(keepends=True )\n   if lines:\n    if len(lines)>1:\n    \n    \n     line=lines[0]\n     del lines[0]\n     if len(lines)>1:\n     \n      lines[-1]+=self. charbuffer\n      self. linebuffer=lines\n      self. charbuffer=None\n     else :\n     \n      self. charbuffer=lines[0]+self. charbuffer\n     if not keepends:\n      line=line. splitlines(keepends=False )[0]\n     break\n    line0withend=lines[0]\n    line0withoutend=lines[0]. splitlines(keepends=False )[0]\n    if line0withend !=line0withoutend:\n    \n     self. charbuffer=self. _empty_charbuffer. join(lines[1:])+     self. charbuffer\n     if keepends:\n      line=line0withend\n     else :\n      line=line0withoutend\n     break\n     \n   if not data or size is not None :\n    if line and not keepends:\n     line=line. splitlines(keepends=False )[0]\n    break\n   if readsize <8000:\n    readsize *=2\n  return line\n  \n def readlines(self,sizehint=None ,keepends=True ):\n \n  ''\n\n\n\n\n\n\n\n\n  \n  data=self. read()\n  return data. splitlines(keepends)\n  \n def reset(self):\n \n  ''\n\n\n\n\n\n  \n  self. bytebuffer=b\"\"\n  self. charbuffer=self. _empty_charbuffer\n  self. linebuffer=None\n  \n def seek(self,offset,whence=0):\n  ''\n\n\n  \n  self. stream. seek(offset,whence)\n  self. reset()\n  \n def __next__(self):\n \n  ''\n  line=self. readline()\n  if line:\n   return line\n  raise StopIteration\n  \n def __iter__(self):\n  return self\n  \n def __getattr__(self,name,\n getattr=getattr):\n \n  ''\n  \n  return getattr(self. stream,name)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,type,value,tb):\n  self. stream. close()\n  \n  \n  \nclass StreamReaderWriter:\n\n ''\n\n\n\n\n\n\n \n \n encoding='unknown'\n \n def __init__(self,stream,Reader,Writer,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n  \n  self. stream=stream\n  self. reader=Reader(stream,errors)\n  self. writer=Writer(stream,errors)\n  self. errors=errors\n  \n def read(self,size=-1):\n \n  return self. reader. read(size)\n  \n def readline(self,size=None ):\n \n  return self. reader. readline(size)\n  \n def readlines(self,sizehint=None ):\n \n  return self. reader. readlines(sizehint)\n  \n def __next__(self):\n \n  ''\n  return next(self. reader)\n  \n def __iter__(self):\n  return self\n  \n def write(self,data):\n \n  return self. writer. write(data)\n  \n def writelines(self,list):\n \n  return self. writer. writelines(list)\n  \n def reset(self):\n \n  self. reader. reset()\n  self. writer. reset()\n  \n def seek(self,offset,whence=0):\n  self. stream. seek(offset,whence)\n  self. reader. reset()\n  if whence ==0 and offset ==0:\n   self. writer. reset()\n   \n def __getattr__(self,name,\n getattr=getattr):\n \n  ''\n  \n  return getattr(self. stream,name)\n  \n  \n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,type,value,tb):\n  self. stream. close()\n  \n  \n  \nclass StreamRecoder:\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n data_encoding='unknown'\n file_encoding='unknown'\n \n def __init__(self,stream,encode,decode,Reader,Writer,\n errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self. stream=stream\n  self. encode=encode\n  self. decode=decode\n  self. reader=Reader(stream,errors)\n  self. writer=Writer(stream,errors)\n  self. errors=errors\n  \n def read(self,size=-1):\n \n  data=self. reader. read(size)\n  data,bytesencoded=self. encode(data,self. errors)\n  return data\n  \n def readline(self,size=None ):\n \n  if size is None :\n   data=self. reader. readline()\n  else :\n   data=self. reader. readline(size)\n  data,bytesencoded=self. encode(data,self. errors)\n  return data\n  \n def readlines(self,sizehint=None ):\n \n  data=self. reader. read()\n  data,bytesencoded=self. encode(data,self. errors)\n  return data. splitlines(keepends=True )\n  \n def __next__(self):\n \n  ''\n  data=next(self. reader)\n  data,bytesencoded=self. encode(data,self. errors)\n  return data\n  \n def __iter__(self):\n  return self\n  \n def write(self,data):\n \n  data,bytesdecoded=self. decode(data,self. errors)\n  return self. writer. write(data)\n  \n def writelines(self,list):\n \n  data=''. join(list)\n  data,bytesdecoded=self. decode(data,self. errors)\n  return self. writer. write(data)\n  \n def reset(self):\n \n  self. reader. reset()\n  self. writer. reset()\n  \n def __getattr__(self,name,\n getattr=getattr):\n \n  ''\n  \n  return getattr(self. stream,name)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,type,value,tb):\n  self. stream. close()\n  \n  \n  \ndef open(filename,mode='rb',encoding=None ,errors='strict',buffering=1):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if encoding is not None and 'b'not in mode:\n \n  mode=mode+'b'\n file=builtins. open(filename,mode,buffering)\n if encoding is None :\n  return file\n info=lookup(encoding)\n srw=StreamReaderWriter(file,info. streamreader,info. streamwriter,errors)\n \n srw. encoding=encoding\n return srw\n \ndef EncodedFile(file,data_encoding,file_encoding=None ,errors='strict'):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if file_encoding is None :\n  file_encoding=data_encoding\n data_info=lookup(data_encoding)\n file_info=lookup(file_encoding)\n sr=StreamRecoder(file,data_info. encode,data_info. decode,\n file_info. streamreader,file_info. streamwriter,errors)\n \n sr. data_encoding=data_encoding\n sr. file_encoding=file_encoding\n return sr\n \n \n \ndef getencoder(encoding):\n\n ''\n\n\n\n\n \n return lookup(encoding). encode\n \ndef getdecoder(encoding):\n\n ''\n\n\n\n\n \n return lookup(encoding). decode\n \ndef getincrementalencoder(encoding):\n\n ''\n\n\n\n\n\n \n encoder=lookup(encoding). incrementalencoder\n if encoder is None :\n  raise LookupError(encoding)\n return encoder\n \ndef getincrementaldecoder(encoding):\n\n ''\n\n\n\n\n\n \n decoder=lookup(encoding). incrementaldecoder\n if decoder is None :\n  raise LookupError(encoding)\n return decoder\n \ndef getreader(encoding):\n\n ''\n\n\n\n\n \n return lookup(encoding). streamreader\n \ndef getwriter(encoding):\n\n ''\n\n\n\n\n \n return lookup(encoding). streamwriter\n \ndef iterencode(iterator,encoding,errors='strict',**kwargs):\n ''\n\n\n\n\n\n\n \n encoder=getincrementalencoder(encoding)(errors,**kwargs)\n for input in iterator:\n  output=encoder. encode(input)\n  if output:\n   yield output\n output=encoder. encode(\"\",True )\n if output:\n  yield output\n  \ndef iterdecode(iterator,encoding,errors='strict',**kwargs):\n ''\n\n\n\n\n\n\n \n decoder=getincrementaldecoder(encoding)(errors,**kwargs)\n for input in iterator:\n  output=decoder. decode(input)\n  if output:\n   yield output\n output=decoder. decode(b\"\",True )\n if output:\n  yield output\n  \n  \n  \ndef make_identity_dict(rng):\n\n ''\n\n\n\n\n \n return {i:i for i in rng}\n \ndef make_encoding_map(decoding_map):\n\n ''\n\n\n\n\n\n\n\n\n\n \n m={}\n for k,v in decoding_map. items():\n  if not v in m:\n   m[v]=k\n  else :\n   m[v]=None\n return m\n \n \n \ntry :\n strict_errors=lookup_error(\"strict\")\n ignore_errors=lookup_error(\"ignore\")\n replace_errors=lookup_error(\"replace\")\n xmlcharrefreplace_errors=lookup_error(\"xmlcharrefreplace\")\n backslashreplace_errors=lookup_error(\"backslashreplace\")\nexcept LookupError:\n\n strict_errors=None\n ignore_errors=None\n replace_errors=None\n xmlcharrefreplace_errors=None\n backslashreplace_errors=None\n \n \n \n_false=0\nif _false:\n import encodings\n \n \n \nif __name__ =='__main__':\n\n\n sys. stdout=EncodedFile(sys. stdout,'latin-1','utf-8')\n \n \n sys. stdin=EncodedFile(sys. stdin,'utf-8','latin-1')\n"], "collections": [".py", "\n\nfrom _collections import deque,defaultdict\n\n\n\n__all__=['deque','defaultdict','namedtuple','UserDict','UserList',\n'UserString','Counter','OrderedDict']\n\n\n\n\n\n\nfrom _abcoll import MutableMapping\n\n\n\nfrom collections. abc import *\nimport collections. abc\n__all__ +=collections. abc. __all__\n\nfrom _collections import deque,defaultdict,namedtuple\nfrom operator import itemgetter as _itemgetter\nfrom keyword import iskeyword as _iskeyword\nimport sys as _sys\nimport heapq as _heapq\n\n\nfrom itertools import repeat as _repeat,chain as _chain,starmap as _starmap\nfrom reprlib import recursive_repr as _recursive_repr\n\nclass Set(set):\n pass\n \nclass Sequence(list):\n pass\n \ndef _proxy(obj):\n return obj\n \n \n \n \n \nclass _Link(object):\n __slots__='prev','next','key','__weakref__'\n \nclass OrderedDict(dict):\n ''\n \n \n \n \n \n \n \n \n \n \n \n \n \n def __init__(self,*args,**kwds):\n  ''\n\n\n\n  \n  if len(args)>1:\n   raise TypeError('expected at most 1 arguments, got %d'%len(args))\n  try :\n   self. __root\n  except AttributeError:\n   self. __hardroot=_Link()\n   self. __root=root=_proxy(self. __hardroot)\n   root. prev=root. next=root\n   self. __map={}\n  self. __update(*args,**kwds)\n  \n def __setitem__(self,key,value,\n dict_setitem=dict. __setitem__,proxy=_proxy,Link=_Link):\n  ''\n  \n  \n  if key not in self:\n   self. __map[key]=link=Link()\n   root=self. __root\n   last=root. prev\n   link. prev,link. next,link. key=last,root,key\n   last. next=link\n   root. prev=proxy(link)\n  dict_setitem(self,key,value)\n  \n def __delitem__(self,key,dict_delitem=dict. __delitem__):\n  ''\n  \n  \n  dict_delitem(self,key)\n  link=self. __map. pop(key)\n  link_prev=link. prev\n  link_next=link. next\n  link_prev. next=link_next\n  link_next. prev=link_prev\n  \n def __iter__(self):\n  ''\n  \n  root=self. __root\n  curr=root. next\n  while curr is not root:\n   yield curr. key\n   curr=curr. next\n   \n def __reversed__(self):\n  ''\n  \n  root=self. __root\n  curr=root. prev\n  while curr is not root:\n   yield curr. key\n   curr=curr. prev\n   \n def clear(self):\n  ''\n  root=self. __root\n  root. prev=root. next=root\n  self. __map. clear()\n  dict. clear(self)\n  \n def popitem(self,last=True ):\n  ''\n\n\n  \n  if not self:\n   raise KeyError('dictionary is empty')\n  root=self. __root\n  if last:\n   link=root. prev\n   link_prev=link. prev\n   link_prev. next=root\n   root. prev=link_prev\n  else :\n   link=root. next\n   link_next=link. next\n   root. next=link_next\n   link_next. prev=root\n  key=link. key\n  del self. __map[key]\n  value=dict. pop(self,key)\n  return key,value\n  \n def move_to_end(self,key,last=True ):\n  ''\n\n\n\n\n  \n  link=self. __map[key]\n  link_prev=link. prev\n  link_next=link. next\n  link_prev. next=link_next\n  link_next. prev=link_prev\n  root=self. __root\n  if last:\n   last=root. prev\n   link. prev=last\n   link. next=root\n   last. next=root. prev=link\n  else :\n   first=root. next\n   link. prev=root\n   link. next=first\n   root. next=first. prev=link\n   \n def __sizeof__(self):\n  sizeof=_sys. getsizeof\n  n=len(self)+1\n  size=sizeof(self. __dict__)\n  size +=sizeof(self. __map)*2\n  size +=sizeof(self. __hardroot)*n\n  size +=sizeof(self. __root)*n\n  return size\n  \n  \n update=__update=MutableMapping. update\n keys=MutableMapping. keys\n values=MutableMapping. values\n items=MutableMapping. items\n __ne__=MutableMapping. __ne__\n \n __marker=object()\n \n def pop(self,key,default=__marker):\n  ''\n\n\n\n  \n  if key in self:\n   result=self[key]\n   del self[key]\n   return result\n  if default is self. __marker:\n   raise KeyError(key)\n  return default\n  \n def setdefault(self,key,default=None ):\n  ''\n  if key in self:\n   return self[key]\n  self[key]=default\n  return default\n  \n  \n  \n def __repr__(self):\n  ''\n  if not self:\n   return'%s()'%(self. __class__. __name__,)\n  return'%s(%r)'%(self. __class__. __name__,list(self. items()))\n  \n def __reduce__(self):\n  ''\n  items=[[k,self[k]]for k in self]\n  inst_dict=vars(self). copy()\n  for k in vars(OrderedDict()):\n   inst_dict. pop(k,None )\n  if inst_dict:\n   return (self. __class__,(items,),inst_dict)\n  return self. __class__,(items,)\n  \n def copy(self):\n  ''\n  return self. __class__(self)\n  \n @classmethod\n def fromkeys(cls,iterable,value=None ):\n  ''\n\n\n  \n  self=cls()\n  for key in iterable:\n   self[key]=value\n  return self\n  \n def __eq__(self,other):\n  ''\n\n\n  \n  if isinstance(other,OrderedDict):\n   return len(self)==len(other)and   all(p ==q for p,q in zip(self. items(),other. items()))\n  return dict. __eq__(self,other)\n  \n  \n  \n  \n  \n  \n  \ndef _count_elements(mapping,iterable):\n ''\n mapping_get=mapping. get\n for elem in iterable:\n  mapping[elem]=mapping_get(elem,0)+1\n  \n  \n  \n  \n  \n  \nclass Counter(dict):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n def __init__(self,iterable=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  dict. __init__(self)\n  self. update(iterable,**kwds)\n  \n def __missing__(self,key):\n  ''\n  \n  return 0\n  \n def most_common(self,n=None ):\n  ''\n\n\n\n\n\n  \n  \n  if n is None :\n   return sorted(self. items(),key=_itemgetter(1),reverse=True )\n  return _heapq. nlargest(n,self. items(),key=_itemgetter(1))\n  \n def elements(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  return _chain. from_iterable(_starmap(_repeat,self. items()))\n  \n  \n  \n @classmethod\n def fromkeys(cls,iterable,v=None ):\n \n \n  raise NotImplementedError(\n  'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')\n  \n def update(self,iterable=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  if iterable is not None :\n   if isinstance(iterable,Mapping):\n    if self:\n     self_get=self. get\n     for elem,count in iterable. items():\n      self[elem]=count+self_get(elem,0)\n    else :\n     super(). update(iterable)\n   else :\n    _count_elements(self,iterable)\n  if kwds:\n   self. update(kwds)\n   \n def subtract(self,iterable=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if iterable is not None :\n   self_get=self. get\n   if isinstance(iterable,Mapping):\n    for elem,count in iterable. items():\n     self[elem]=self_get(elem,0)-count\n   else :\n    for elem in iterable:\n     self[elem]=self_get(elem,0)-1\n  if kwds:\n   self. subtract(kwds)\n   \n def copy(self):\n  ''\n  return self. __class__(self)\n  \n def __reduce__(self):\n  return self. __class__,(dict(self),)\n  \n def __delitem__(self,elem):\n  ''\n  if elem in self:\n   super(). __delitem__(elem)\n   \n def __repr__(self):\n  if not self:\n   return'%s()'%self. __class__. __name__\n  try :\n   items=', '. join(map('%r: %r'. __mod__,self. most_common()))\n   return'%s({%s})'%(self. __class__. __name__,items)\n  except TypeError:\n  \n   return'{0}({1!r})'. format(self. __class__. __name__,dict(self))\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def __add__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self. items():\n   newcount=count+other[elem]\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other. items():\n   if elem not in self and count >0:\n    result[elem]=count\n  return result\n  \n def __sub__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self. items():\n   newcount=count -other[elem]\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other. items():\n   if elem not in self and count <0:\n    result[elem]=0 -count\n  return result\n  \n def __or__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self. items():\n   other_count=other[elem]\n   newcount=other_count if count <other_count else count\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other. items():\n   if elem not in self and count >0:\n    result[elem]=count\n  return result\n  \n def __and__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self. items():\n   other_count=other[elem]\n   newcount=count if count <other_count else other_count\n   if newcount >0:\n    result[elem]=newcount\n  return result\n  \n  \n  \n  \n  \n  \nclass ChainMap(MutableMapping):\n ''\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*maps):\n  ''\n\n\n  \n  self. maps=list(maps)or [{}]\n  \n def __missing__(self,key):\n  raise KeyError(key)\n  \n def __getitem__(self,key):\n  for mapping in self. maps:\n   try :\n    return mapping[key]\n   except KeyError:\n    pass\n  return self. __missing__(key)\n  \n def get(self,key,default=None ):\n  return self[key]if key in self else default\n  \n def __len__(self):\n  return len(set(). union(*self. maps))\n  \n def __iter__(self):\n  return iter(set(). union(*self. maps))\n  \n def __contains__(self,key):\n  return any(key in m for m in self. maps)\n  \n def __bool__(self):\n  return any(self. maps)\n  \n  \n  \n def __repr__(self):\n  return'{0.__class__.__name__}({1})'. format(\n  self,', '. join(map(repr,self. maps)))\n  \n def __repr__(self):\n  return','. join(str(_map)for _map in self. maps)\n  \n @classmethod\n def fromkeys(cls,iterable,*args):\n  ''\n  return cls(dict. fromkeys(iterable,*args))\n  \n def copy(self):\n  ''\n  return self. __class__(self. maps[0]. copy(),*self. maps[1:])\n  \n __copy__=copy\n \n def new_child(self):\n  ''\n  return self. __class__({},*self. maps)\n  \n @property\n def parents(self):\n  ''\n  return self. __class__(*self. maps[1:])\n  \n def __setitem__(self,key,value):\n  self. maps[0][key]=value\n  \n def __delitem__(self,key):\n  try :\n   del self. maps[0][key]\n  except KeyError:\n   raise KeyError('Key not found in the first mapping: {!r}'. format(key))\n   \n def popitem(self):\n  ''\n  try :\n   return self. maps[0]. popitem()\n  except KeyError:\n   raise KeyError('No keys found in the first mapping.')\n   \n def pop(self,key,*args):\n  ''\n  try :\n   return self. maps[0]. pop(key,*args)\n  except KeyError:\n  \n   raise KeyError('Key not found in the first mapping: %s'%key)\n   \n def clear(self):\n  ''\n  self. maps[0]. clear()\n  \n  \n  \n  \n  \n  \nclass UserDict(MutableMapping):\n\n\n def __init__(self,dict=None ,**kwargs):\n  self. data={}\n  if dict is not None :\n   self. update(dict)\n  if len(kwargs):\n   self. update(kwargs)\n def __len__(self):return len(self. data)\n def __getitem__(self,key):\n  if key in self. data:\n   return self. data[key]\n  if hasattr(self. __class__,\"__missing__\"):\n   return self. __class__. __missing__(self,key)\n  raise KeyError(key)\n def __setitem__(self,key,item):self. data[key]=item\n def __delitem__(self,key):del self. data[key]\n def __iter__(self):\n  return iter(self. data)\n  \n  \n def __contains__(self,key):\n  return key in self. data\n  \n  \n def __repr__(self):return repr(self. data)\n def copy(self):\n  if self. __class__ is UserDict:\n   return UserDict(self. data. copy())\n  import copy\n  data=self. data\n  try :\n   self. data={}\n   c=copy. copy(self)\n  finally :\n   self. data=data\n  c. update(self)\n  return c\n @classmethod\n def fromkeys(cls,iterable,value=None ):\n  d=cls()\n  for key in iterable:\n   d[key]=value\n  return d\n  \n  \n  \n  \n  \nclass UserList(MutableSequence):\n ''\n def __init__(self,initlist=None ):\n  self. data=[]\n  if initlist is not None :\n  \n   if type(initlist)==type(self. data):\n    self. data[:]=initlist\n   elif isinstance(initlist,UserList):\n    self. data[:]=initlist. data[:]\n   else :\n    self. data=list(initlist)\n def __repr__(self):return repr(self. data)\n def __lt__(self,other):return self. data <self. __cast(other)\n def __le__(self,other):return self. data <=self. __cast(other)\n def __eq__(self,other):return self. data ==self. __cast(other)\n def __ne__(self,other):return self. data !=self. __cast(other)\n def __gt__(self,other):return self. data >self. __cast(other)\n def __ge__(self,other):return self. data >=self. __cast(other)\n def __cast(self,other):\n  return other. data if isinstance(other,UserList)else other\n def __contains__(self,item):return item in self. data\n def __len__(self):return len(self. data)\n def __getitem__(self,i):return self. data[i]\n def __setitem__(self,i,item):self. data[i]=item\n def __delitem__(self,i):del self. data[i]\n def __add__(self,other):\n  if isinstance(other,UserList):\n   return self. __class__(self. data+other. data)\n  elif isinstance(other,type(self. data)):\n   return self. __class__(self. data+other)\n  return self. __class__(self. data+list(other))\n def __radd__(self,other):\n  if isinstance(other,UserList):\n   return self. __class__(other. data+self. data)\n  elif isinstance(other,type(self. data)):\n   return self. __class__(other+self. data)\n  return self. __class__(list(other)+self. data)\n def __iadd__(self,other):\n  if isinstance(other,UserList):\n   self. data +=other. data\n  elif isinstance(other,type(self. data)):\n   self. data +=other\n  else :\n   self. data +=list(other)\n  return self\n def __mul__(self,n):\n  return self. __class__(self. data *n)\n __rmul__=__mul__\n def __imul__(self,n):\n  self. data *=n\n  return self\n def append(self,item):self. data. append(item)\n def insert(self,i,item):self. data. insert(i,item)\n def pop(self,i=-1):return self. data. pop(i)\n def remove(self,item):self. data. remove(item)\n def clear(self):self. data. clear()\n def copy(self):return self. __class__(self)\n def count(self,item):return self. data. count(item)\n def index(self,item,*args):return self. data. index(item,*args)\n def reverse(self):self. data. reverse()\n def sort(self,*args,**kwds):self. data. sort(*args,**kwds)\n def extend(self,other):\n  if isinstance(other,UserList):\n   self. data. extend(other. data)\n  else :\n   self. data. extend(other)\n   \n   \n   \n   \n   \n   \n   \nclass UserString(Sequence):\n def __init__(self,seq):\n  if isinstance(seq,str):\n   self. data=seq\n  elif isinstance(seq,UserString):\n   self. data=seq. data[:]\n  else :\n   self. data=str(seq)\n def __str__(self):return str(self. data)\n def __repr__(self):return repr(self. data)\n def __int__(self):return int(self. data)\n def __float__(self):return float(self. data)\n def __complex__(self):return complex(self. data)\n def __hash__(self):return hash(self. data)\n \n def __eq__(self,string):\n  if isinstance(string,UserString):\n   return self. data ==string. data\n  return self. data ==string\n def __ne__(self,string):\n  if isinstance(string,UserString):\n   return self. data !=string. data\n  return self. data !=string\n def __lt__(self,string):\n  if isinstance(string,UserString):\n   return self. data <string. data\n  return self. data <string\n def __le__(self,string):\n  if isinstance(string,UserString):\n   return self. data <=string. data\n  return self. data <=string\n def __gt__(self,string):\n  if isinstance(string,UserString):\n   return self. data >string. data\n  return self. data >string\n def __ge__(self,string):\n  if isinstance(string,UserString):\n   return self. data >=string. data\n  return self. data >=string\n  \n def __contains__(self,char):\n  if isinstance(char,UserString):\n   char=char. data\n  return char in self. data\n  \n def __len__(self):return len(self. data)\n def __getitem__(self,index):return self. __class__(self. data[index])\n def __add__(self,other):\n  if isinstance(other,UserString):\n   return self. __class__(self. data+other. data)\n  elif isinstance(other,str):\n   return self. __class__(self. data+other)\n  return self. __class__(self. data+str(other))\n def __radd__(self,other):\n  if isinstance(other,str):\n   return self. __class__(other+self. data)\n  return self. __class__(str(other)+self. data)\n def __mul__(self,n):\n  return self. __class__(self. data *n)\n __rmul__=__mul__\n def __mod__(self,args):\n  return self. __class__(self. data %args)\n  \n  \n def capitalize(self):return self. __class__(self. data. capitalize())\n def center(self,width,*args):\n  return self. __class__(self. data. center(width,*args))\n def count(self,sub,start=0,end=_sys. maxsize):\n  if isinstance(sub,UserString):\n   sub=sub. data\n  return self. data. count(sub,start,end)\n def encode(self,encoding=None ,errors=None ):\n  if encoding:\n   if errors:\n    return self. __class__(self. data. encode(encoding,errors))\n   return self. __class__(self. data. encode(encoding))\n  return self. __class__(self. data. encode())\n def endswith(self,suffix,start=0,end=_sys. maxsize):\n  return self. data. endswith(suffix,start,end)\n def expandtabs(self,tabsize=8):\n  return self. __class__(self. data. expandtabs(tabsize))\n def find(self,sub,start=0,end=_sys. maxsize):\n  if isinstance(sub,UserString):\n   sub=sub. data\n  return self. data. find(sub,start,end)\n def format(self,*args,**kwds):\n  return self. data. format(*args,**kwds)\n def index(self,sub,start=0,end=_sys. maxsize):\n  return self. data. index(sub,start,end)\n def isalpha(self):return self. data. isalpha()\n def isalnum(self):return self. data. isalnum()\n def isdecimal(self):return self. data. isdecimal()\n def isdigit(self):return self. data. isdigit()\n def isidentifier(self):return self. data. isidentifier()\n def islower(self):return self. data. islower()\n def isnumeric(self):return self. data. isnumeric()\n def isspace(self):return self. data. isspace()\n def istitle(self):return self. data. istitle()\n def isupper(self):return self. data. isupper()\n def join(self,seq):return self. data. join(seq)\n def ljust(self,width,*args):\n  return self. __class__(self. data. ljust(width,*args))\n def lower(self):return self. __class__(self. data. lower())\n def lstrip(self,chars=None ):return self. __class__(self. data. lstrip(chars))\n def partition(self,sep):\n  return self. data. partition(sep)\n def replace(self,old,new,maxsplit=-1):\n  if isinstance(old,UserString):\n   old=old. data\n  if isinstance(new,UserString):\n   new=new. data\n  return self. __class__(self. data. replace(old,new,maxsplit))\n def rfind(self,sub,start=0,end=_sys. maxsize):\n  if isinstance(sub,UserString):\n   sub=sub. data\n  return self. data. rfind(sub,start,end)\n def rindex(self,sub,start=0,end=_sys. maxsize):\n  return self. data. rindex(sub,start,end)\n def rjust(self,width,*args):\n  return self. __class__(self. data. rjust(width,*args))\n def rpartition(self,sep):\n  return self. data. rpartition(sep)\n def rstrip(self,chars=None ):\n  return self. __class__(self. data. rstrip(chars))\n def split(self,sep=None ,maxsplit=-1):\n  return self. data. split(sep,maxsplit)\n def rsplit(self,sep=None ,maxsplit=-1):\n  return self. data. rsplit(sep,maxsplit)\n def splitlines(self,keepends=False ):return self. data. splitlines(keepends)\n def startswith(self,prefix,start=0,end=_sys. maxsize):\n  return self. data. startswith(prefix,start,end)\n def strip(self,chars=None ):return self. __class__(self. data. strip(chars))\n def swapcase(self):return self. __class__(self. data. swapcase())\n def title(self):return self. __class__(self. data. title())\n def translate(self,*args):\n  return self. __class__(self. data. translate(*args))\n def upper(self):return self. __class__(self. data. upper())\n def zfill(self,width):return self. __class__(self. data. zfill(width))\n", 1], "time": [".py", "from browser import window\n\n\ndate=window. Date. new\n\nnow=window. Date. now\n\n\n\n\n\n\n\n_STRUCT_TM_ITEMS=9\n\n\n\n\n\ndef _get_day_of_year(arg):\n ''\n\n\n\n\n\n\n\n\n\n \n ml=[31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4 ==0:\n  ml[1]+=1\n i=1\n yday=0\n while i <arg[1]:\n  yday +=ml[i -1]\n  i +=1\n yday +=arg[2]\n return yday\n \ndef _get_week_of_year(arg):\n ''\n\n\n\n\n\n\n\n\n\n\n \n d1=date(arg[0],arg[1]-1,arg[2])\n d0=date(arg[0],0,1)\n firstday=d0. getDay()\n if firstday ==0:firstday=7\n firstweek=8 -firstday\n doy=arg[7]\n if firstday !=1:\n  doy=doy -firstweek\n if doy %7 ==0:\n  week_number=doy //7\n else :\n  week_number=doy //7+1\n return week_number\n \ndef _check_struct_time(t):\n mm=t[1]\n if mm ==0:mm=1\n if -1 >mm >13:raise ValueError(\"month out of range\")\n \n dd=t[2]\n if dd ==0:dd=1\n if -1 >dd >32:raise ValueError(\"day of month out of range\")\n \n hh=t[3]\n if -1 >hh >24:raise ValueError(\"hour out of range\")\n \n minu=t[4]\n if -1 >minu >60:raise ValueError(\"minute out of range\")\n \n ss=t[5]\n if -1 >ss >62:raise ValueError(\"seconds out of range\")\n \n wd=t[6]%7\n if wd <-2:raise ValueError(\"day of week out of range\")\n \n dy=t[7]\n if dy ==0:dy=1\n if -1 >dy >367:raise ValueError(\"day of year out of range\")\n \n return t[0],mm,dd,hh,minu,ss,wd,dy,t[-1]\n \n \ndef _is_dst(secs=None ):\n ''\n d=date()\n if secs is not None :\n  d=date(secs *1000)\n  \n  \n jan=date(d. getFullYear(),0,1)\n jul=date(d. getFullYear(),6,1)\n dst=int(d. getTimezoneOffset()<max(abs(jan. getTimezoneOffset()),abs(jul. getTimezoneOffset())))\n return dst\n \ndef _get_tzname():\n ''\n d=date()\n d=d. toTimeString()\n try :\n  d=d. split('(')[1]. split(')')[0]\n  return (d,'NotAvailable')\n except :\n  return ('','')\n  \ndef _set_altzone():\n d=date()\n jan=date(d. getFullYear(),0,1)\n jul=date(d. getFullYear(),6,1)\n result=timezone -(jan. getTimezoneOffset()-jul. getTimezoneOffset())*60\n return result\n \ndef _check_input(t):\n if t and isinstance(t,struct_time)and len(t. args)==9:\n  t=t. args\n elif t and isinstance(t,tuple)and len(t)==9:\n  t=t\n elif t and isinstance(t,struct_time)and len(t. args)!=9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\". format(len(t. args)))\n elif t and isinstance(t,tuple)and len(t)!=9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\". format(len(t)))\n elif t and not isinstance(t,(tuple,struct_time)):\n  raise TypeError(\"Tuple or struct_time argument required\")\n else :\n  t=localtime(). args\n return t\n \n \n \n \n \ndaylight=_is_dst()\ntimezone=date(). getTimezoneOffset()*60\ntzname=_get_tzname()\naltzone=_set_altzone()if daylight else timezone\n\n\ndef asctime(t=None ):\n weekdays={0:\"Mon\",1:\"Tue\",2:\"Wed\",3:\"Thu\",\n 4:\"Fri\",5:\"Sat\",6:\"Sun\"}\n months={1:'Jan',2:'Feb',3:'Mar',4:'Apr',5:'May',6:'Jun',\n 7:'Jul',8:'Aug',9:'Sep',10:'Oct',11:'Nov',12:'Dec'}\n \n t=_check_input(t)\n t=_check_struct_time(t)\n \n result=\"%s %s %2d %02d:%02d:%02d %d\"%(\n weekdays[t[6]],months[t[1]],t[2],t[3],t[4],t[5],t[0])\n return result\n \ndef ctime(timestamp=None ):\n return asctime(localtime(timestamp))\n \ndef gmtime(secs=None ):\n d=date()\n if secs is not None :\n  d=date(secs *1000)\n wday=d. getUTCDay()-1 if d. getUTCDay()-1 >=0 else 6\n tmp=struct_time([d. getUTCFullYear(),\n d. getUTCMonth()+1,d. getUTCDate(),\n d. getUTCHours(),d. getUTCMinutes(),d. getUTCSeconds(),\n wday,0,0])\n tmp. args[7]=_get_day_of_year(tmp. args)\n return tmp\n \ndef localtime(secs=None ):\n d=date()\n if secs is not None :\n  d=date(secs *1000)\n dst=_is_dst(secs)\n wday=d. getDay()-1 if d. getDay()-1 >=0 else 6\n tmp=struct_time([d. getFullYear(),\n d. getMonth()+1,d. getDate(),\n d. getHours(),d. getMinutes(),d. getSeconds(),\n wday,0,dst])\n tmp. args[7]=_get_day_of_year(tmp. args)\n return tmp\n \ndef mktime(t):\n if isinstance(t,struct_time):\n  d1=date(t. tm_year,t. tm_mon -1,t. tm_mday,\n  t. tm_hour,t. tm_min,t. tm_sec,0). getTime()\n elif isinstance(t,tuple):\n  d1=date(t[0],t[1]-1,t[2],t[3],t[4],t[5],0). getTime()\n else :\n  raise ValueError(\"Tuple or struct_time argument required\")\n d2=date(0). getTime()\n return (d1 -d2)/1000.\n \ndef monotonic():\n return now()/1000.\n \ndef perf_counter():\n return now()/1000.\n \ndef process_time():\n return now()/1000.\n \ndef time():\n return float(date(). getTime()/1000)\n \ndef sleep(secs):\n ''\n\n \n \n \n \n raise NotImplementedError(\"Blocking functions like time.sleep() are not \"\n \"supported in the browser. Use functions in module browser.timer \"\n \"instead.\")\n \ndef strftime(_format,t=None ):\n\n def ns(t,nb):\n \n  res=str(t)\n  while len(res)<nb:\n   res='0'+res\n  return res\n  \n t=_check_input(t)\n t=_check_struct_time(t)\n \n YY=ns(t[0],4)\n yy=ns(t[0],4)[2:]\n mm=ns(t[1],2)\n dd=ns(t[2],2)\n HH=t[3]\n HH24=ns(HH,2)\n HH12=ns(HH %12,2)\n if HH12 ==0:HH12=12\n AMPM='AM'if 0 <=HH <12 else'PM'\n MM=ns(t[4],2)\n SS=ns(t[5],2)\n DoY=ns(t[7],3)\n w=t[6]+1 if t[6]<6 else 0\n W=ns(_get_week_of_year(t),2)\n \n abb_weekdays=['Sun','Mon','Tue','Wed','Thu','Fri','Sat']\n full_weekdays=['Sunday','Monday','Tuesday','Wednesday',\n 'Thursday','Friday','Saturday']\n abb_months=['Jan','Feb','Mar','Apr','May','Jun',\n 'Jul','Aug','Sep','Oct','Nov','Dec']\n full_months=['January','February','March','April','May','June',\n 'July','August','September','October','November','December']\n \n res=_format\n res=res. replace(\"%H\",HH24)\n res=res. replace(\"%I\",HH12)\n res=res. replace(\"%p\",AMPM)\n res=res. replace(\"%M\",MM)\n res=res. replace(\"%S\",SS)\n res=res. replace(\"%Y\",YY)\n res=res. replace(\"%y\",yy)\n res=res. replace(\"%m\",mm)\n res=res. replace(\"%d\",dd)\n res=res. replace(\"%a\",abb_weekdays[w])\n res=res. replace(\"%A\",full_weekdays[w])\n res=res. replace(\"%b\",abb_months[int(mm)-1])\n res=res. replace(\"%B\",full_months[int(mm)-1])\n res=res. replace(\"%j\",DoY)\n res=res. replace(\"%w\",str(w))\n res=res. replace(\"%W\",W)\n res=res. replace(\"%x\",mm+'/'+dd+'/'+yy)\n res=res. replace(\"%X\",HH24+':'+MM+':'+SS)\n res=res. replace(\"%c\",abb_weekdays[w]+' '+abb_months[int(mm)-1]+\n ' '+dd+' '+HH24+':'+MM+':'+SS+' '+YY)\n res=res. replace(\"%%\",'%')\n \n return res\n \nclass struct_time:\n\n def __init__(self,args):\n \n  if len(args)!=9:\n   raise TypeError(\"time.struct_time() takes a 9-sequence (%s-sequence given)\"%len(args))\n   \n  self. args=args\n  \n @property\n def tm_year(self):\n  return self. args[0]\n  \n @property\n def tm_mon(self):\n  return self. args[1]\n  \n @property\n def tm_mday(self):\n  return self. args[2]\n  \n @property\n def tm_hour(self):\n  return self. args[3]\n  \n @property\n def tm_min(self):\n  return self. args[4]\n  \n @property\n def tm_sec(self):\n  return self. args[5]\n  \n @property\n def tm_wday(self):\n  return self. args[6]\n  \n @property\n def tm_yday(self):\n  return self. args[7]\n  \n @property\n def tm_isdst(self):\n  return self. args[8]\n  \n def __getitem__(self,i):\n  return self. args[i]\n  \n def __iter__(self):\n  return iter(self. args)\n  \n def __repr__(self):\n  return (\"time.structime(tm_year={}, tm_mon={}, tm_day={}, \"+  \"tm_hour={}, tm_min={}, tm_sec={}, tm_wday={}, \"+  \"tm_yday={}, tm_isdst={})\"). format(*self. args)\n  \n def __str__(self):\n  return self. __repr__()\n  \ndef to_struct_time(*arg):\n arg=list(arg)\n \n \n ml=[31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4 ==0:\n  ml[1]+=1\n  \n i=1\n yday=0\n while i <arg[1]:\n  yday +=ml[i -1]\n  i +=1\n yday +=arg[2]\n arg. append(yday)\n arg. append(-1)\n return struct_time(tuple(arg))\n \ndef wait(secs):\n\n pass\n \ndef strptime(string,_format):\n import _strptime\n return _strptime. _strptime_datetime(to_struct_time,string,_format)\n \n \n \n_clock_msg=\"\"\"Browser cannot access CPU. See '%s'\"\"\"\ndef _clock_xx(url):\n raise NotImplementedError(_clock_msg %url)\nclock=time\nclock_getres=lambda :_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_getres\")\nclock_gettime=lambda :_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_gettime\")\nclock_settime=lambda :_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_settime\")\nCLOCK_HIGHRES=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_HIGHRES\"\nCLOCK_MONOTONIC=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC\"\nCLOCK_MONOTONIC_RAW=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC_RAW\"\nCLOCK_PROCESS_CPUTIME_ID=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_PROCESS_CPUTIME_ID\"\nCLOCK_REALTIME=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_REALTIME\"\nCLOCK_THREAD_CPUTIME_ID=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_THREAD_CPUTIME_ID\"\n\n\ndef get_clock_info(cl):\n from collections import namedtuple\n ClockInfo=namedtuple('ClockInfo',['adjustable','implementation','monotonic','resolution'])\n \n if cl =='monotonic':\n  return ClockInfo(adjustable=False ,\n  implementation='window.performance.now',\n  monotonic=True ,\n  resolution=0.000001)\n elif cl =='perf_counter'or cl =='process_time':\n  return ClockInfo(adjustable=False ,\n  implementation='date.getTime',\n  monotonic=False ,\n  resolution=0.001)\n else :\n  _clock_xx(\"https://docs.python.org/3/library/time.html#time.get_clock_info\")\n  \ndef tzset():\n raise NotImplementedError()\n"], "heapq": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__about__=\"\"\"Heap queues\n\n[explanation by Fran\u00e7ois Pinard]\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nThe strange invariant above is meant to be an efficient memory\nrepresentation for a tournament.  The numbers below are `k', not a[k]:\n\n                                   0\n\n                  1                                 2\n\n          3               4                5               6\n\n      7       8       9       10      11      12      13      14\n\n    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\n\nIn the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\nan usual binary tournament we see in sports, each cell is the winner\nover the two cells it tops, and we can trace the winner down the tree\nto see all opponents s/he had.  However, in many computer applications\nof such tournaments, we do not need to trace the history of a winner.\nTo be more memory efficient, when a winner is promoted, we try to\nreplace it by something else at a lower level, and the rule becomes\nthat a cell and the two cells it tops contain three different items,\nbut the top cell \"wins\" over the two topped cells.\n\nIf this heap invariant is protected at all time, index 0 is clearly\nthe overall winner.  The simplest algorithmic way to remove it and\nfind the \"next\" winner is to move some loser (let's say cell 30 in the\ndiagram above) into the 0 position, and then percolate this new 0 down\nthe tree, exchanging values, until the invariant is re-established.\nThis is clearly logarithmic on the total number of items in the tree.\nBy iterating over all items, you get an O(n ln n) sort.\n\nA nice feature of this sort is that you can efficiently insert new\nitems while the sort is going on, provided that the inserted items are\nnot \"better\" than the last 0'th element you extracted.  This is\nespecially useful in simulation contexts, where the tree holds all\nincoming events, and the \"win\" condition means the smallest scheduled\ntime.  When an event schedule other events for execution, they are\nscheduled into the future, so they can easily go into the heap.  So, a\nheap is a good structure for implementing schedulers (this is what I\nused for my MIDI sequencer :-).\n\nVarious structures for implementing schedulers have been extensively\nstudied, and heaps are good for this, as they are reasonably speedy,\nthe speed is almost constant, and the worst case is not much different\nthan the average case.  However, there are other representations which\nare more efficient overall, yet the worst cases might be terrible.\n\nHeaps are also very useful in big disk sorts.  You most probably all\nknow that a big sort implies producing \"runs\" (which are pre-sorted\nsequences, which size is usually related to the amount of CPU memory),\nfollowed by a merging passes for these runs, which merging is often\nvery cleverly organised[1].  It is very important that the initial\nsort produces the longest runs possible.  Tournaments are a good way\nto that.  If, using all the memory available to hold a tournament, you\nreplace and percolate items that happen to fit the current run, you'll\nproduce runs which are twice the size of the memory for random input,\nand much better for input fuzzily ordered.\n\nMoreover, if you output the 0'th item on disk and get an input which\nmay not fit in the current tournament (because the value \"wins\" over\nthe last output value), it cannot fit in the heap, so the size of the\nheap decreases.  The freed memory could be cleverly reused immediately\nfor progressively building a second heap, which grows at exactly the\nsame rate the first heap is melting.  When the first heap completely\nvanishes, you switch heaps and start a new run.  Clever and quite\neffective!\n\nIn a word, heaps are useful memory structures to know.  I use them in\na few applications, and I think it is good to keep a `heap' module\naround. :-)\n\n--------------------\n[1] The disk balancing algorithms which are current, nowadays, are\nmore annoying than clever, and this is a consequence of the seeking\ncapabilities of the disks.  On devices which cannot seek, like big\ntape drives, the story was quite different, and one had to be very\nclever to ensure (far in advance) that each tape movement will be the\nmost effective possible (that is, will best participate at\n\"progressing\" the merge).  Some tapes were even able to read\nbackwards, and this was also used to avoid the rewinding time.\nBelieve me, real good tape sorts were quite spectacular to watch!\nFrom all times, sorting has always been a Great Art! :-)\n\"\"\"\n\n__all__=['heappush','heappop','heapify','heapreplace','merge',\n'nlargest','nsmallest','heappushpop']\n\nfrom itertools import islice,count,tee,chain\n\ndef heappush(heap,item):\n ''\n heap. append(item)\n _siftdown(heap,0,len(heap)-1)\n \ndef heappop(heap):\n ''\n lastelt=heap. pop()\n if heap:\n  returnitem=heap[0]\n  heap[0]=lastelt\n  _siftup(heap,0)\n else :\n  returnitem=lastelt\n return returnitem\n \ndef heapreplace(heap,item):\n ''\n\n\n\n\n\n\n\n\n \n returnitem=heap[0]\n heap[0]=item\n _siftup(heap,0)\n return returnitem\n \ndef heappushpop(heap,item):\n ''\n if heap and heap[0]<item:\n  item,heap[0]=heap[0],item\n  _siftup(heap,0)\n return item\n \ndef heapify(x):\n ''\n n=len(x)\n \n \n \n \n \n for i in reversed(range(n //2)):\n  _siftup(x,i)\n  \ndef _heappushpop_max(heap,item):\n ''\n if heap and item <heap[0]:\n  item,heap[0]=heap[0],item\n  _siftup_max(heap,0)\n return item\n \ndef _heapify_max(x):\n ''\n n=len(x)\n for i in reversed(range(n //2)):\n  _siftup_max(x,i)\n  \ndef nlargest(n,iterable):\n ''\n\n\n \n if n <0:\n  return []\n it=iter(iterable)\n result=list(islice(it,n))\n if not result:\n  return result\n heapify(result)\n _heappushpop=heappushpop\n for elem in it:\n  _heappushpop(result,elem)\n result. sort(reverse=True )\n return result\n \ndef nsmallest(n,iterable):\n ''\n\n\n \n if n <0:\n  return []\n it=iter(iterable)\n result=list(islice(it,n))\n if not result:\n  return result\n _heapify_max(result)\n _heappushpop=_heappushpop_max\n for elem in it:\n  _heappushpop(result,elem)\n result. sort()\n return result\n \n \n \n \ndef _siftdown(heap,startpos,pos):\n newitem=heap[pos]\n \n \n while pos >startpos:\n  parentpos=(pos -1)>>1\n  parent=heap[parentpos]\n  if newitem <parent:\n   heap[pos]=parent\n   pos=parentpos\n   continue\n  break\n heap[pos]=newitem\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef _siftup(heap,pos):\n endpos=len(heap)\n startpos=pos\n newitem=heap[pos]\n \n childpos=2 *pos+1\n while childpos <endpos:\n \n  rightpos=childpos+1\n  if rightpos <endpos and not heap[childpos]<heap[rightpos]:\n   childpos=rightpos\n   \n  heap[pos]=heap[childpos]\n  pos=childpos\n  childpos=2 *pos+1\n  \n  \n heap[pos]=newitem\n _siftdown(heap,startpos,pos)\n \ndef _siftdown_max(heap,startpos,pos):\n ''\n newitem=heap[pos]\n \n \n while pos >startpos:\n  parentpos=(pos -1)>>1\n  parent=heap[parentpos]\n  if parent <newitem:\n   heap[pos]=parent\n   pos=parentpos\n   continue\n  break\n heap[pos]=newitem\n \ndef _siftup_max(heap,pos):\n ''\n endpos=len(heap)\n startpos=pos\n newitem=heap[pos]\n \n childpos=2 *pos+1\n while childpos <endpos:\n \n  rightpos=childpos+1\n  if rightpos <endpos and not heap[rightpos]<heap[childpos]:\n   childpos=rightpos\n   \n  heap[pos]=heap[childpos]\n  pos=childpos\n  childpos=2 *pos+1\n  \n  \n heap[pos]=newitem\n _siftdown_max(heap,startpos,pos)\n \n \n \n \n \n \n \n \ndef merge(*iterables):\n ''\n\n\n\n\n\n\n\n\n \n _heappop,_heapreplace,_StopIteration=heappop,heapreplace,StopIteration\n _len=len\n \n h=[]\n h_append=h. append\n for itnum,it in enumerate(map(iter,iterables)):\n  try :\n   next=it. __next__\n   h_append([next(),itnum,next])\n  except _StopIteration:\n   pass\n heapify(h)\n \n while _len(h)>1:\n  try :\n   while True :\n    v,itnum,next=s=h[0]\n    yield v\n    s[0]=next()\n    _heapreplace(h,s)\n  except _StopIteration:\n   _heappop(h)\n if h:\n \n  v,itnum,next=h[0]\n  yield v\n  yield from next. __self__\n  \n  \n_nsmallest=nsmallest\ndef nsmallest(n,iterable,key=None ):\n ''\n\n\n \n \n if n ==1:\n  it=iter(iterable)\n  head=list(islice(it,1))\n  if not head:\n   return []\n  if key is None :\n   return [min(chain(head,it))]\n  return [min(chain(head,it),key=key)]\n  \n  \n try :\n  size=len(iterable)\n except (TypeError,AttributeError):\n  pass\n else :\n  if n >=size:\n   return sorted(iterable,key=key)[:n]\n   \n   \n if key is None :\n  it=zip(iterable,count())\n  result=_nsmallest(n,it)\n  return [r[0]for r in result]\n  \n  \n in1,in2=tee(iterable)\n it=zip(map(key,in1),count(),in2)\n result=_nsmallest(n,it)\n return [r[2]for r in result]\n \n_nlargest=nlargest\ndef nlargest(n,iterable,key=None ):\n ''\n\n\n \n \n \n if n ==1:\n  it=iter(iterable)\n  head=list(islice(it,1))\n  if not head:\n   return []\n  if key is None :\n   return [max(chain(head,it))]\n  return [max(chain(head,it),key=key)]\n  \n  \n try :\n  size=len(iterable)\n except (TypeError,AttributeError):\n  pass\n else :\n  if n >=size:\n   return sorted(iterable,key=key,reverse=True )[:n]\n   \n   \n if key is None :\n  it=zip(iterable,count(0,-1))\n  result=_nlargest(n,it)\n  return [r[0]for r in result]\n  \n  \n in1,in2=tee(iterable)\n it=zip(map(key,in1),count(0,-1),in2)\n result=_nlargest(n,it)\n return [r[2]for r in result]\n \nif __name__ ==\"__main__\":\n\n heap=[]\n data=[1,3,5,7,9,2,4,6,8,0]\n for item in data:\n  heappush(heap,item)\n sort=[]\n while heap:\n  sort. append(heappop(heap))\n print(sort)\n \n import doctest\n doctest. testmod()\n"], "re": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nr\"\"\"Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode whitespace characters.\n    \\S       Matches any non-whitespace character; equivalent to [^\\s].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.\n\n\"\"\"\n\nimport sre_compile\nimport sre_parse\n\n\n__all__=[\"match\",\"search\",\"sub\",\"subn\",\"split\",\"findall\",\n\"compile\",\"purge\",\"template\",\"escape\",\"A\",\"I\",\"L\",\"M\",\"S\",\"X\",\n\"U\",\"ASCII\",\"IGNORECASE\",\"LOCALE\",\"MULTILINE\",\"DOTALL\",\"VERBOSE\",\n\"UNICODE\",\"error\"]\n\n__version__=\"2.2.1\"\n\n\nA=ASCII=sre_compile. SRE_FLAG_ASCII\nI=IGNORECASE=sre_compile. SRE_FLAG_IGNORECASE\nL=LOCALE=sre_compile. SRE_FLAG_LOCALE\nU=UNICODE=sre_compile. SRE_FLAG_UNICODE\nM=MULTILINE=sre_compile. SRE_FLAG_MULTILINE\nS=DOTALL=sre_compile. SRE_FLAG_DOTALL\nX=VERBOSE=sre_compile. SRE_FLAG_VERBOSE\n\n\nT=TEMPLATE=sre_compile. SRE_FLAG_TEMPLATE\nDEBUG=sre_compile. SRE_FLAG_DEBUG\n\n\nerror=sre_compile. error\n\n\n\n\ndef match(pattern,string,flags=0):\n ''\n \n return _compile(pattern,flags). match(string)\n \ndef search(pattern,string,flags=0):\n ''\n \n return _compile(pattern,flags). search(string)\n \ndef sub(pattern,repl,string,count=0,flags=0):\n ''\n\n\n\n\n \n return _compile(pattern,flags). sub(repl,string,count)\n \ndef subn(pattern,repl,string,count=0,flags=0):\n ''\n\n\n\n\n\n\n \n return _compile(pattern,flags). subn(repl,string,count)\n \ndef split(pattern,string,maxsplit=0,flags=0):\n ''\n\n\n\n\n\n \n return _compile(pattern,flags). split(string,maxsplit)\n \ndef findall(pattern,string,flags=0):\n ''\n\n\n\n\n\n \n return _compile(pattern,flags). findall(string)\n \ndef finditer(pattern,string,flags=0):\n ''\n\n\n \n return _compile(pattern,flags). finditer(string)\n \ndef compile(pattern,flags=0):\n ''\n \n return _compile(pattern,flags)\n \ndef purge():\n ''\n _cache. clear()\n _cache_repl. clear()\n \ndef template(pattern,flags=0):\n ''\n return _compile(pattern,flags |T)\n \n_alphanum_str=frozenset(\n\"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890\")\n_alphanum_bytes=frozenset(\nb\"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890\")\n\ndef escape(pattern):\n ''\n\n \n if isinstance(pattern,str):\n  alphanum=_alphanum_str\n  s=list(pattern)\n  for i,c in enumerate(pattern):\n   if c not in alphanum:\n    if c ==\"\\000\":\n     s[i]=\"\\\\000\"\n    else :\n     s[i]=\"\\\\\"+c\n  return\"\". join(s)\n else :\n  alphanum=_alphanum_bytes\n  s=[]\n  esc=ord(b\"\\\\\")\n  for c in pattern:\n   if c in alphanum:\n    s. append(c)\n   else :\n    if c ==0:\n     s. extend(b\"\\\\000\")\n    else :\n     s. append(esc)\n     s. append(c)\n  return bytes(s)\n  \n  \n  \n  \n_cache={}\n_cache_repl={}\n\n_pattern_type=type(sre_compile. compile(\"\",0))\n\n_MAXCACHE=512\ndef _compile(pattern,flags):\n\n try :\n \n \n  return _cache[\"%s:%s:%s\"%(type(pattern),pattern,flags)]\n except KeyError:\n  pass\n  \n if isinstance(pattern,_pattern_type):\n  if flags:\n   raise ValueError(\n   \"Cannot process flags argument with a compiled pattern\")\n  return pattern\n if not sre_compile. isstring(pattern):\n  raise TypeError(\"first argument must be string or compiled pattern\")\n p=sre_compile. compile(pattern,flags)\n \n if len(_cache)>=_MAXCACHE:\n  _cache. clear()\n  \n  \n _cache[\"%s:%s:%s\"%(type(pattern),pattern,flags)]=p\n return p\n \ndef _compile_repl(repl,pattern):\n\n try :\n \n \n  return _cache_repl[\"%s:%s\"%(repl,pattern)]\n except KeyError:\n  pass\n p=sre_parse. parse_template(repl,pattern)\n if len(_cache_repl)>=_MAXCACHE:\n  _cache_repl. clear()\n _cache_repl[\"%s:%s\"%(repl,pattern)]=p\n \n \n return p\n \ndef _expand(pattern,match,template):\n\n template=sre_parse. parse_template(template,pattern)\n return sre_parse. expand_template(template,match)\n \ndef _subx(pattern,template):\n\n template=_compile_repl(template,pattern)\n if not template[0]and len(template[1])==1:\n \n  return template[1][0]\n def filter(match,template=template):\n  return sre_parse. expand_template(template,match)\n return filter\n \n \n \nimport copyreg\n\ndef _pickle(p):\n return _compile,(p. pattern,p. flags)\n \ncopyreg. pickle(_pattern_type,_pickle,_compile)\n\n\n\n\nclass Scanner:\n def __init__(self,lexicon,flags=0):\n  from sre_constants import BRANCH,SUBPATTERN\n  self. lexicon=lexicon\n  \n  p=[]\n  s=sre_parse. Pattern()\n  s. flags=flags\n  for phrase,action in lexicon:\n   p. append(sre_parse. SubPattern(s,[\n   (SUBPATTERN,(len(p)+1,sre_parse. parse(phrase,flags))),\n   ]))\n  s. groups=len(p)+1\n  p=sre_parse. SubPattern(s,[(BRANCH,(None ,p))])\n  self. scanner=sre_compile. compile(p)\n def scan(self,string):\n  result=[]\n  append=result. append\n  match=self. scanner. scanner(string). match\n  i=0\n  while 1:\n   m=match()\n   if not m:\n    break\n   j=m. end()\n   if i ==j:\n    break\n   action=self. lexicon[m. lastindex -1][1]\n   if callable(action):\n    self. match=m\n    action=action(self,m. group())\n   if action is not None :\n    append(action)\n   i=j\n  return result,string[i:]\n"], "collections.abc": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) for collections, according to PEP 3119.\n\nUnit tests are in test_collections.\n\"\"\"\n\nfrom abc import ABCMeta,abstractmethod\nimport sys\n\n__all__=[\"Hashable\",\"Iterable\",\"Iterator\",\n\"Sized\",\"Container\",\"Callable\",\n\"Set\",\"MutableSet\",\n\"Mapping\",\"MutableMapping\",\n\"MappingView\",\"KeysView\",\"ItemsView\",\"ValuesView\",\n\"Sequence\",\"MutableSequence\",\n\"ByteString\",\n]\n\n\n\n\n\n\n\n\nbytes_iterator=type(iter(b''))\nbytearray_iterator=type(iter(bytearray()))\n\ndict_keyiterator=type(iter({}. keys()))\ndict_valueiterator=type(iter({}. values()))\ndict_itemiterator=type(iter({}. items()))\nlist_iterator=type(iter([]))\nlist_reverseiterator=type(iter(reversed([])))\nrange_iterator=type(iter(range(0)))\nset_iterator=type(iter(set()))\nstr_iterator=type(iter(\"\"))\ntuple_iterator=type(iter(()))\nzip_iterator=type(iter(zip()))\n\ndict_keys=type({}. keys())\ndict_values=type({}. values())\ndict_items=type({}. items())\n\nmappingproxy=type(type. __dict__)\n\n\n\n\nclass Hashable(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __hash__(self):\n  return 0\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Hashable:\n   for B in C. __mro__:\n    if\"__hash__\"in B. __dict__:\n     if B. __dict__[\"__hash__\"]:\n      return True\n     break\n  return NotImplemented\n  \n  \nclass Iterable(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __iter__(self):\n  while False :\n   yield None\n   \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Iterable:\n   if any(\"__iter__\"in B. __dict__ for B in C. __mro__):\n    return True\n  return NotImplemented\n  \n  \nclass Iterator(Iterable):\n\n __slots__=()\n \n @abstractmethod\n def __next__(self):\n  raise StopIteration\n  \n def __iter__(self):\n  return self\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Iterator:\n   if (any(\"__next__\"in B. __dict__ for B in C. __mro__)and\n   any(\"__iter__\"in B. __dict__ for B in C. __mro__)):\n    return True\n  return NotImplemented\n  \nIterator. register(bytes_iterator)\nIterator. register(bytearray_iterator)\n\nIterator. register(dict_keyiterator)\nIterator. register(dict_valueiterator)\nIterator. register(dict_itemiterator)\nIterator. register(list_iterator)\nIterator. register(list_reverseiterator)\nIterator. register(range_iterator)\nIterator. register(set_iterator)\nIterator. register(str_iterator)\nIterator. register(tuple_iterator)\nIterator. register(zip_iterator)\n\nclass Sized(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __len__(self):\n  return 0\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Sized:\n   if any(\"__len__\"in B. __dict__ for B in C. __mro__):\n    return True\n  return NotImplemented\n  \n  \nclass Container(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __contains__(self,x):\n  return False\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Container:\n   if any(\"__contains__\"in B. __dict__ for B in C. __mro__):\n    return True\n  return NotImplemented\n  \n  \nclass Callable(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __call__(self,*args,**kwds):\n  return False\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Callable:\n   if any(\"__call__\"in B. __dict__ for B in C. __mro__):\n    return True\n  return NotImplemented\n  \n  \n  \n  \n  \nclass Set(Sized,Iterable,Container):\n\n ''\n\n\n\n\n\n\n\n \n \n __slots__=()\n \n def __le__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  if len(self)>len(other):\n   return False\n  for elem in self:\n   if elem not in other:\n    return False\n  return True\n  \n def __lt__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  return len(self)<len(other)and self. __le__(other)\n  \n def __gt__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  return other <self\n  \n def __ge__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  return other <=self\n  \n def __eq__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  return len(self)==len(other)and self. __le__(other)\n  \n def __ne__(self,other):\n  return not (self ==other)\n  \n @classmethod\n def _from_iterable(cls,it):\n  ''\n\n\n\n  \n  return cls(it)\n  \n def __and__(self,other):\n  if not isinstance(other,Iterable):\n   return NotImplemented\n  return self. _from_iterable(value for value in other if value in self)\n  \n def isdisjoint(self,other):\n  for value in other:\n   if value in self:\n    return False\n  return True\n  \n def __or__(self,other):\n  if not isinstance(other,Iterable):\n   return NotImplemented\n  chain=(e for s in (self,other)for e in s)\n  return self. _from_iterable(chain)\n  \n def __sub__(self,other):\n  if not isinstance(other,Set):\n   if not isinstance(other,Iterable):\n    return NotImplemented\n   other=self. _from_iterable(other)\n  return self. _from_iterable(value for value in self\n  if value not in other)\n  \n def __xor__(self,other):\n  if not isinstance(other,Set):\n   if not isinstance(other,Iterable):\n    return NotImplemented\n   other=self. _from_iterable(other)\n  return (self -other)|(other -self)\n  \n def _hash(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  MAX=sys. maxsize\n  MASK=2 *MAX+1\n  n=len(self)\n  h=1927868237 *(n+1)\n  h &=MASK\n  for x in self:\n   hx=hash(x)\n   h ^=(hx ^(hx <<16)^89869747)*3644798167\n   h &=MASK\n  h=h *69069+907133923\n  h &=MASK\n  if h >MAX:\n   h -=MASK+1\n  if h ==-1:\n   h=590923713\n  return h\n  \nSet. register(frozenset)\n\n\nclass MutableSet(Set):\n\n __slots__=()\n \n @abstractmethod\n def add(self,value):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def discard(self,value):\n  ''\n  raise NotImplementedError\n  \n def remove(self,value):\n  ''\n  if value not in self:\n   raise KeyError(value)\n  self. discard(value)\n  \n def pop(self):\n  ''\n  it=iter(self)\n  try :\n   value=next(it)\n  except StopIteration:\n   raise KeyError\n  self. discard(value)\n  return value\n  \n def clear(self):\n  ''\n  try :\n   while True :\n    self. pop()\n  except KeyError:\n   pass\n   \n def __ior__(self,it):\n  for value in it:\n   self. add(value)\n  return self\n  \n def __iand__(self,it):\n  for value in (self -it):\n   self. discard(value)\n  return self\n  \n def __ixor__(self,it):\n  if it is self:\n   self. clear()\n  else :\n   if not isinstance(it,Set):\n    it=self. _from_iterable(it)\n   for value in it:\n    if value in self:\n     self. discard(value)\n    else :\n     self. add(value)\n  return self\n  \n def __isub__(self,it):\n  if it is self:\n   self. clear()\n  else :\n   for value in it:\n    self. discard(value)\n  return self\n  \nMutableSet. register(set)\n\n\n\n\n\nclass Mapping(Sized,Iterable,Container):\n\n __slots__=()\n \n @abstractmethod\n def __getitem__(self,key):\n  raise KeyError\n  \n def get(self,key,default=None ):\n  try :\n   return self[key]\n  except KeyError:\n   return default\n   \n def __contains__(self,key):\n  try :\n   self[key]\n  except KeyError:\n   return False\n  else :\n   return True\n   \n def keys(self):\n  return KeysView(self)\n  \n def items(self):\n  return ItemsView(self)\n  \n def values(self):\n  return ValuesView(self)\n  \n def __eq__(self,other):\n  if not isinstance(other,Mapping):\n   return NotImplemented\n  return dict(self. items())==dict(other. items())\n  \n def __ne__(self,other):\n  return not (self ==other)\n  \nMapping. register(mappingproxy)\n\n\nclass MappingView(Sized):\n\n def __init__(self,mapping):\n  self. _mapping=mapping\n  \n def __len__(self):\n  return len(self. _mapping)\n  \n def __repr__(self):\n  return'{0.__class__.__name__}({0._mapping!r})'. format(self)\n  \n  \nclass KeysView(MappingView,Set):\n\n @classmethod\n def _from_iterable(self,it):\n  return set(it)\n  \n def __contains__(self,key):\n  return key in self. _mapping\n  \n def __iter__(self):\n  for key in self. _mapping:\n   yield key\n   \nKeysView. register(dict_keys)\n\n\nclass ItemsView(MappingView,Set):\n\n @classmethod\n def _from_iterable(self,it):\n  return set(it)\n  \n def __contains__(self,item):\n  key,value=item\n  try :\n   v=self. _mapping[key]\n  except KeyError:\n   return False\n  else :\n   return v ==value\n   \n def __iter__(self):\n  for key in self. _mapping:\n   yield (key,self. _mapping[key])\n   \nItemsView. register(dict_items)\n\n\nclass ValuesView(MappingView):\n\n def __contains__(self,value):\n  for key in self. _mapping:\n   if value ==self. _mapping[key]:\n    return True\n  return False\n  \n def __iter__(self):\n  for key in self. _mapping:\n   yield self. _mapping[key]\n   \nValuesView. register(dict_values)\n\n\nclass MutableMapping(Mapping):\n\n __slots__=()\n \n @abstractmethod\n def __setitem__(self,key,value):\n  raise KeyError\n  \n @abstractmethod\n def __delitem__(self,key):\n  raise KeyError\n  \n __marker=object()\n \n def pop(self,key,default=__marker):\n  try :\n   value=self[key]\n  except KeyError:\n   if default is self. __marker:\n    raise\n   return default\n  else :\n   del self[key]\n   return value\n   \n def popitem(self):\n  try :\n   key=next(iter(self))\n  except StopIteration:\n   raise KeyError\n  value=self[key]\n  del self[key]\n  return key,value\n  \n def clear(self):\n  try :\n   while True :\n    self. popitem()\n  except KeyError:\n   pass\n   \n def update(*args,**kwds):\n  if len(args)>2:\n   raise TypeError(\"update() takes at most 2 positional \"\n   \"arguments ({} given)\". format(len(args)))\n  elif not args:\n   raise TypeError(\"update() takes at least 1 argument (0 given)\")\n  self=args[0]\n  other=args[1]if len(args)>=2 else ()\n  \n  if isinstance(other,Mapping):\n   for key in other:\n    self[key]=other[key]\n  elif hasattr(other,\"keys\"):\n   for key in other. keys():\n    self[key]=other[key]\n  else :\n   for key,value in other:\n    self[key]=value\n  for key,value in kwds. items():\n   self[key]=value\n   \n def setdefault(self,key,default=None ):\n  try :\n   return self[key]\n  except KeyError:\n   self[key]=default\n  return default\n  \nMutableMapping. register(dict)\n\n\n\n\n\nclass Sequence(Sized,Iterable,Container):\n\n ''\n\n\n\n \n \n __slots__=()\n \n @abstractmethod\n def __getitem__(self,index):\n  raise IndexError\n  \n def __iter__(self):\n  i=0\n  try :\n   while True :\n    v=self[i]\n    yield v\n    i +=1\n  except IndexError:\n   return\n   \n def __contains__(self,value):\n  for v in self:\n   if v ==value:\n    return True\n  return False\n  \n def __reversed__(self):\n  for i in reversed(range(len(self))):\n   yield self[i]\n   \n def index(self,value):\n  for i,v in enumerate(self):\n   if v ==value:\n    return i\n  raise ValueError\n  \n def count(self,value):\n  return sum(1 for v in self if v ==value)\n  \nSequence. register(tuple)\nSequence. register(str)\nSequence. register(range)\n\n\nclass ByteString(Sequence):\n\n ''\n\n\n \n \n __slots__=()\n \nByteString. register(bytes)\nByteString. register(bytearray)\n\n\nclass MutableSequence(Sequence):\n\n __slots__=()\n \n @abstractmethod\n def __setitem__(self,index,value):\n  raise IndexError\n  \n @abstractmethod\n def __delitem__(self,index):\n  raise IndexError\n  \n @abstractmethod\n def insert(self,index,value):\n  raise IndexError\n  \n def append(self,value):\n  self. insert(len(self),value)\n  \n def clear(self):\n  try :\n   while True :\n    self. pop()\n  except IndexError:\n   pass\n   \n def reverse(self):\n  n=len(self)\n  for i in range(n //2):\n   self[i],self[n -i -1]=self[n -i -1],self[i]\n   \n def extend(self,values):\n  for v in values:\n   self. append(v)\n   \n def pop(self,index=-1):\n  v=self[index]\n  del self[index]\n  return v\n  \n def remove(self,value):\n  del self[self. index(value)]\n  \n def __iadd__(self,values):\n  self. extend(values)\n  return self\n  \nMutableSequence. register(list)\nMutableSequence. register(bytearray)\n"], "_weakref": [".py", "class ProxyType:\n\n def __init__(self,obj):\n  self. obj=obj\n  \nCallableProxyType=ProxyType\nProxyTypes=[ProxyType,CallableProxyType]\n\nclass ReferenceType:\n\n def __init__(self,obj,callback):\n  self. obj=obj\n  self. callback=callback\n  \nclass ref:\n\n def __init__(self,obj,callback=None ):\n  self. obj=ReferenceType(obj,callback)\n  self. callback=callback\n  \n def __call__(self):\n  return self. obj. obj\n  \ndef getweakrefcount(obj):\n return 1\n \ndef getweakrefs(obj):\n return obj\n \n \ndef proxy(obj,callback=None ):\n return ProxyType(obj)\n \n"], "sre_compile": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\"Internal support module for sre\"\"\"\n\n\nimport sys\nimport _sre\nimport sre_parse\nfrom sre_constants import *\nfrom _sre import MAXREPEAT\n\n\nassert _sre. MAGIC ==MAGIC,\"SRE module mismatch\"\n\nif _sre. CODESIZE ==2:\n MAXCODE=65535\nelse :\n MAXCODE=0xFFFFFFFF\n \ndef _identityfunction(x):\n return x\n \n \n_LITERAL_CODES=set([LITERAL,NOT_LITERAL])\n_REPEATING_CODES=set([REPEAT,MIN_REPEAT,MAX_REPEAT])\n_SUCCESS_CODES=set([SUCCESS,FAILURE])\n_ASSERT_CODES=set([ASSERT,ASSERT_NOT])\n\ndef _compile(code,pattern,flags):\n\n emit=code. append\n _len=len\n LITERAL_CODES=_LITERAL_CODES\n REPEATING_CODES=_REPEATING_CODES\n SUCCESS_CODES=_SUCCESS_CODES\n ASSERT_CODES=_ASSERT_CODES\n for op,av in pattern:\n \n \n  if op in LITERAL_CODES:\n   if flags&SRE_FLAG_IGNORECASE:\n    emit(OPCODES[OP_IGNORE[op]])\n    emit(_sre. getlower(av,flags))\n   else :\n    emit(OPCODES[op])\n    emit(av)\n  elif op is IN:\n   if flags&SRE_FLAG_IGNORECASE:\n    emit(OPCODES[OP_IGNORE[op]])\n    def fixup(literal,flags=flags):\n     return _sre. getlower(literal,flags)\n   else :\n    emit(OPCODES[op])\n    fixup=_identityfunction\n   skip=_len(code);emit(0)\n   _compile_charset(av,flags,code,fixup)\n   code[skip]=_len(code)-skip\n  elif op is ANY:\n   if flags&SRE_FLAG_DOTALL:\n    emit(OPCODES[ANY_ALL])\n   else :\n    emit(OPCODES[ANY])\n  elif op in REPEATING_CODES:\n   if flags&SRE_FLAG_TEMPLATE:\n    raise error(\"internal: unsupported template operator\")\n    emit(OPCODES[REPEAT])\n    skip=_len(code);emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code,av[2],flags)\n    emit(OPCODES[SUCCESS])\n    code[skip]=_len(code)-skip\n   elif _simple(av)and op is not REPEAT:\n    if op is MAX_REPEAT:\n     emit(OPCODES[REPEAT_ONE])\n    else :\n     emit(OPCODES[MIN_REPEAT_ONE])\n    skip=_len(code);emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code,av[2],flags)\n    emit(OPCODES[SUCCESS])\n    code[skip]=_len(code)-skip\n   else :\n    emit(OPCODES[REPEAT])\n    skip=_len(code);emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code,av[2],flags)\n    code[skip]=_len(code)-skip\n    if op is MAX_REPEAT:\n     emit(OPCODES[MAX_UNTIL])\n    else :\n     emit(OPCODES[MIN_UNTIL])\n  elif op is SUBPATTERN:\n   if av[0]:\n    emit(OPCODES[MARK])\n    emit((av[0]-1)*2)\n    \n   _compile(code,av[1],flags)\n   if av[0]:\n    emit(OPCODES[MARK])\n    emit((av[0]-1)*2+1)\n  elif op in SUCCESS_CODES:\n   emit(OPCODES[op])\n  elif op in ASSERT_CODES:\n   emit(OPCODES[op])\n   skip=_len(code);emit(0)\n   if av[0]>=0:\n    emit(0)\n   else :\n    lo,hi=av[1]. getwidth()\n    if lo !=hi:\n     raise error(\"look-behind requires fixed-width pattern\")\n    emit(lo)\n   _compile(code,av[1],flags)\n   emit(OPCODES[SUCCESS])\n   code[skip]=_len(code)-skip\n  elif op is CALL:\n   emit(OPCODES[op])\n   skip=_len(code);emit(0)\n   _compile(code,av,flags)\n   emit(OPCODES[SUCCESS])\n   code[skip]=_len(code)-skip\n  elif op is AT:\n   emit(OPCODES[op])\n   if flags&SRE_FLAG_MULTILINE:\n    av=AT_MULTILINE. get(av,av)\n   if flags&SRE_FLAG_LOCALE:\n    av=AT_LOCALE. get(av,av)\n   elif flags&SRE_FLAG_UNICODE:\n    av=AT_UNICODE. get(av,av)\n   emit(ATCODES[av])\n  elif op is BRANCH:\n   emit(OPCODES[op])\n   tail=[]\n   tailappend=tail. append\n   for av in av[1]:\n    skip=_len(code);emit(0)\n    \n    _compile(code,av,flags)\n    emit(OPCODES[JUMP])\n    tailappend(_len(code));emit(0)\n    code[skip]=_len(code)-skip\n   emit(0)\n   for tail in tail:\n    code[tail]=_len(code)-tail\n  elif op is CATEGORY:\n   emit(OPCODES[op])\n   if flags&SRE_FLAG_LOCALE:\n    av=CH_LOCALE[av]\n   elif flags&SRE_FLAG_UNICODE:\n    av=CH_UNICODE[av]\n   emit(CHCODES[av])\n  elif op is GROUPREF:\n   if flags&SRE_FLAG_IGNORECASE:\n    emit(OPCODES[OP_IGNORE[op]])\n   else :\n    emit(OPCODES[op])\n   emit(av -1)\n  elif op is GROUPREF_EXISTS:\n   emit(OPCODES[op])\n   emit(av[0]-1)\n   skipyes=_len(code);emit(0)\n   _compile(code,av[1],flags)\n   if av[2]:\n    emit(OPCODES[JUMP])\n    skipno=_len(code);emit(0)\n    code[skipyes]=_len(code)-skipyes+1\n    _compile(code,av[2],flags)\n    code[skipno]=_len(code)-skipno\n   else :\n    code[skipyes]=_len(code)-skipyes+1\n  else :\n   raise ValueError(\"unsupported operand type\",op)\n   \ndef _compile_charset(charset,flags,code,fixup=None ):\n\n emit=code. append\n if fixup is None :\n  fixup=_identityfunction\n for op,av in _optimize_charset(charset,fixup):\n  emit(OPCODES[op])\n  if op is NEGATE:\n   pass\n  elif op is LITERAL:\n   emit(fixup(av))\n  elif op is RANGE:\n   emit(fixup(av[0]))\n   emit(fixup(av[1]))\n  elif op is CHARSET:\n   code. extend(av)\n  elif op is BIGCHARSET:\n   code. extend(av)\n  elif op is CATEGORY:\n   if flags&SRE_FLAG_LOCALE:\n    emit(CHCODES[CH_LOCALE[av]])\n   elif flags&SRE_FLAG_UNICODE:\n    emit(CHCODES[CH_UNICODE[av]])\n   else :\n    emit(CHCODES[av])\n  else :\n   raise error(\"internal: unsupported set operator\")\n emit(OPCODES[FAILURE])\n \n \ndef _optimize_charset(charset,fixup):\n\n out=[]\n outappend=out. append\n charmap=[0]*256\n try :\n  for op,av in charset:\n   if op is NEGATE:\n    outappend((op,av))\n   elif op is LITERAL:\n    charmap[fixup(av)]=1\n   elif op is RANGE:\n    for i in range(fixup(av[0]),fixup(av[1])+1):\n     charmap[i]=1\n   elif op is CATEGORY:\n   \n    return charset\n except IndexError:\n \n  return _optimize_unicode(charset,fixup)\n  \n i=p=n=0\n runs=[]\n runsappend=runs. append\n for c in charmap:\n  if c:\n   if n ==0:\n    p=i\n   n=n+1\n  elif n:\n   runsappend((p,n))\n   n=0\n  i=i+1\n if n:\n  runsappend((p,n))\n if len(runs)<=2:\n \n  for p,n in runs:\n   if n ==1:\n    outappend((LITERAL,p))\n   else :\n    outappend((RANGE,(p,p+n -1)))\n  if len(out)<len(charset):\n   return out\n else :\n \n  data=_mk_bitmap(charmap)\n  outappend((CHARSET,data))\n  return out\n return charset\n \ndef _mk_bitmap(bits):\n data=[]\n dataappend=data. append\n if _sre. CODESIZE ==2:\n  start=(1,0)\n else :\n  start=(1,0)\n m,v=start\n for c in bits:\n  if c:\n   v=v+m\n  m=m+m\n  if m >MAXCODE:\n   dataappend(v)\n   m,v=start\n return data\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef _optimize_unicode(charset,fixup):\n try :\n  import array\n except ImportError:\n  return charset\n charmap=[0]*65536\n negate=0\n try :\n  for op,av in charset:\n   if op is NEGATE:\n    negate=1\n   elif op is LITERAL:\n    charmap[fixup(av)]=1\n   elif op is RANGE:\n    for i in range(fixup(av[0]),fixup(av[1])+1):\n     charmap[i]=1\n   elif op is CATEGORY:\n   \n    return charset\n except IndexError:\n \n  return charset\n if negate:\n  if sys. maxunicode !=65535:\n  \n  \n  \n   return charset\n  for i in range(65536):\n   charmap[i]=not charmap[i]\n comps={}\n mapping=[0]*256\n block=0\n data=[]\n for i in range(256):\n  chunk=tuple(charmap[i *256:(i+1)*256])\n  new=comps. setdefault(chunk,block)\n  mapping[i]=new\n  if new ==block:\n   block=block+1\n   data=data+_mk_bitmap(chunk)\n header=[block]\n if _sre. CODESIZE ==2:\n  code='H'\n else :\n  code='I'\n  \n mapping=array. array('b',mapping). tobytes()\n \n mapping=array. array(code,mapping)\n assert mapping. itemsize ==_sre. CODESIZE\n assert len(mapping)*mapping. itemsize ==256\n header=header+mapping. tolist()\n data[0:0]=header\n return [(BIGCHARSET,data)]\n \ndef _simple(av):\n\n lo,hi=av[2]. getwidth()\n if lo ==0 and hi ==MAXREPEAT:\n  raise error(\"nothing to repeat\")\n return lo ==hi ==1 and av[2][0][0]!=SUBPATTERN\n \ndef _compile_info(code,pattern,flags):\n\n\n\n lo,hi=pattern. getwidth()\n \n if lo ==0:\n  return\n  \n prefix=[]\n prefixappend=prefix. append\n prefix_skip=0\n charset=[]\n charsetappend=charset. append\n if not (flags&SRE_FLAG_IGNORECASE):\n \n  for op,av in pattern. data:\n  \n   if op is LITERAL:\n    if len(prefix)==prefix_skip:\n     prefix_skip=prefix_skip+1\n    prefixappend(av)\n   elif op is SUBPATTERN and len(av[1])==1:\n    op,av=av[1][0]\n    if op is LITERAL:\n     prefixappend(av)\n    else :\n     break\n   else :\n    break\n    \n  if not prefix and pattern. data:\n   op,av=pattern. data[0]\n   if op is SUBPATTERN and av[1]:\n    op,av=av[1][0]\n    if op is LITERAL:\n     charsetappend((op,av))\n    elif op is BRANCH:\n     c=[]\n     cappend=c. append\n     for p in av[1]:\n      if not p:\n       break\n      op,av=p[0]\n      if op is LITERAL:\n       cappend((op,av))\n      else :\n       break\n     else :\n      charset=c\n   elif op is BRANCH:\n    c=[]\n    cappend=c. append\n    for p in av[1]:\n     if not p:\n      break\n     op,av=p[0]\n     if op is LITERAL:\n      cappend((op,av))\n     else :\n      break\n    else :\n     charset=c\n   elif op is IN:\n    charset=av\n    \n    \n    \n    \n    \n    \n    \n emit=code. append\n emit(OPCODES[INFO])\n skip=len(code);emit(0)\n \n mask=0\n if prefix:\n  mask=SRE_INFO_PREFIX\n  if len(prefix)==prefix_skip ==len(pattern. data):\n   mask=mask+SRE_INFO_LITERAL\n elif charset:\n  mask=mask+SRE_INFO_CHARSET\n emit(mask)\n \n if lo <MAXCODE:\n  emit(lo)\n else :\n  emit(MAXCODE)\n  prefix=prefix[:MAXCODE]\n if hi <MAXCODE:\n  emit(hi)\n else :\n  emit(0)\n  \n  \n if prefix:\n  emit(len(prefix))\n  emit(prefix_skip)\n  code. extend(prefix)\n  \n  table=[-1]+([0]*len(prefix))\n  for i in range(len(prefix)):\n   table[i+1]=table[i]+1\n   while table[i+1]>0 and prefix[i]!=prefix[table[i+1]-1]:\n    table[i+1]=table[table[i+1]-1]+1\n  code. extend(table[1:])\n elif charset:\n  _compile_charset(charset,flags,code)\n code[skip]=len(code)-skip\n \ndef isstring(obj):\n return isinstance(obj,(str,bytes))\n \ndef _code(p,flags):\n\n flags=p. pattern. flags |flags\n code=[]\n \n \n _compile_info(code,p,flags)\n \n \n _compile(code,p. data,flags)\n \n code. append(OPCODES[SUCCESS])\n \n return code\n \ndef compile(p,flags=0):\n\n\n\n if isstring(p):\n  pattern=p\n  p=sre_parse. parse(p,flags)\n else :\n  pattern=None\n  \n  \n code=_code(p,flags)\n \n \n \n \n \n if p. pattern. groups >100:\n  raise AssertionError(\n  \"sorry, but this version only supports 100 named groups\"\n  )\n  \n  \n groupindex=p. pattern. groupdict\n indexgroup=[None ]*p. pattern. groups\n for k,i in groupindex. items():\n  indexgroup[i]=k\n  \n return _sre. compile(\n pattern,flags |p. pattern. flags,code,\n p. pattern. groups -1,\n groupindex,indexgroup\n )\n"], "_ajax": [".js", "// ajax\nvar $module = (function($B){\n\neval($B.InjectBuiltins())\nvar $N = $B.builtins.None\n\n\nfunction ajax1(){\n    if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var xmlhttp = new XMLHttpRequest();\n    }else{// code for IE6, IE5\n        var xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        var timer = this.$requestTimer\n        if(state===0 && this.onuninitialized){this.onuninitialized()}\n        else if(state===1 && this.onloading){this.onloading()}\n        else if(state===2 && this.onloaded){this.onloaded()}\n        else if(state===3 && this.oninteractive){this.oninteractive()}\n        else if(state===4 && this.oncomplete){\n            if(timer !== null){window.clearTimeout(timer)}\n            this.oncomplete()\n        }\n    }\n    return {\n        __class__: ajax.$dict, \n        js: xmlhttp,\n        headers: {}\n    }\n}\najax1.__class__ = $B.$factory\n\najax.__class__ = $B.$factory\n\nfunction ajax(){\n\n    if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var xmlhttp=new XMLHttpRequest();\n    }else{// code for IE6, IE5\n        var xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        res.js.text = this.responseText\n        var timer = this.$requestTimer\n        if(state===0 && this.onuninitialized){this.onuninitialized(res)}\n        else if(state===1 && this.onloading){this.onloading(res)}\n        else if(state===2 && this.onloaded){this.onloaded(res)}\n        else if(state===3 && this.oninteractive){this.oninteractive(res)}\n        else if(state===4 && this.oncomplete){\n            if(timer !== null){window.clearTimeout(timer)}\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax.$dict, \n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\n\nvar add_to_res = function(res,key,val) {\n    if (isinstance(val,list)) {\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res,key,val[j])\n        }\n    } else if (val instanceof File || val instanceof Blob) {\n        res.append(key,val)\n    } else res.append(key,str(val))\n}\n\najax.$dict = {\n\n    __class__:$B.$type,\n    __name__:'ajax',\n    $factory: ajax,\n    \n    __getattribute__ : function(self, attr){\n        // Special case for send : accept dict as parameters\n        if(attr=='send'){\n            return function(params){\n                return ajax.$dict.send(self, params)\n            }\n        }\n        // Otherwise default to JSObject method\n        return $B.JSObject.$dict.__getattribute__(self, attr)\n    },\n    \n    __repr__ : function(self){return '<object Ajax>'},\n    __str__ : function(self){return '<object Ajax>'},\n    \n    bind : function(self, evt, func){\n        // req.bind(evt,func) is the same as req.onevt = func\n        self.js['on'+evt] = function(){\n            try{\n                return func.apply(null, arguments)\n            }catch(err){\n                if(err.__class__!==undefined){\n                    var msg = _b_.getattr(err, 'info')+\n                        '\\n'+err.__class__.__name__\n                    if(err.args){msg += ': '+err.args[0]}\n                    try{getattr($B.stderr,\"write\")(msg)}\n                    catch(err){console.log(msg)}\n                }else{\n                    try{getattr($B.stderr,\"write\")(err)}\n                    catch(err1){console.log(err)}\n                }\n            }\n        }\n        return $N\n    },\n    \n    send : function(self,params){\n        // params can be Python dictionary or string\n        //self.js.onreadystatechange = function(ev){console.log(ev.target)}\n        var res = ''\n        if(!params){\n            self.js.send();\n            return $N;\n        }else if(isinstance(params,str)){\n            res = params\n        }else if(isinstance(params,dict)){\n            if(self.headers['content-type'] == 'multipart/form-data'){\n                // The FormData object serializes the data in the 'multipart/form-data'\n                // content-type so we may as well override that header if it was set\n                // by the user.\n                res = new FormData()\n                var items = _b_.list(_b_.dict.$dict.items(params))\n                for(var i=0, _len_i = items.length; i < _len_i;i++){\n                    add_to_res(res,str(items[i][0]),items[i][1])\n                }\n            }else{\n                var items = _b_.list(_b_.dict.$dict.items(params))\n                for(var i=0, _len_i = items.length; i < _len_i;i++){\n                    var key = encodeURIComponent(str(items[i][0]));\n                    if (isinstance(items[i][1],list)) {\n                        for (j = 0; j < items[i][1].length; j++) {\n                            res += key +'=' + encodeURIComponent(str(items[i][1][j])) + '&'\n                        }\n                    } else {\n                        res += key + '=' + encodeURIComponent(str(items[i][1])) + '&'\n                    }\n                }\n                res = res.substr(0,res.length-1)\n            }\n        }else{\n            throw _b_.TypeError(\"send() argument must be string or dictionary, not '\"+str(params.__class__)+\"'\")\n        }\n        self.js.send(res)\n        return $N\n    },\n    \n    set_header : function(self,key,value){\n        self.js.setRequestHeader(key,value)\n        self.headers[key.toLowerCase()] = value.toLowerCase()\n    },\n    \n    set_timeout : function(self,seconds,func){\n        self.js.$requestTimer = setTimeout(\n            function() {self.js.abort();func()},\n            seconds*1000);\n    }\n}\n\najax.$dict.__mro__ = [$B.JSObject.$dict, _b_.object.$dict]\n\n$B.set_func_names(ajax.$dict)\n\nreturn {ajax:ajax, ajax1:ajax1}\n\n})(__BRYTHON__)\n"], "itertools": [".py", "import operator\n\nclass accumulate:\n def __init__(self,iterable,func=operator. add):\n  self. it=iter(iterable)\n  self. _total=None\n  self. func=func\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self. _total:\n   self. _total=next(self. it)\n   return self. _total\n  else :\n   element=next(self. it)\n   try :\n    self. _total=self. func(self. _total,element)\n   except :\n    raise TypeError(\"unsupported operand type\")\n   return self. _total\n   \n   \n   \nclass chain:\n def __init__(self,*iterables):\n  self. _iterables_iter=iter(map(iter,iterables))\n  \n  self. _cur_iterable_iter=iter([])\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True :\n   try :\n    return next(self. _cur_iterable_iter)\n   except StopIteration:\n    self. _cur_iterable_iter=next(self. _iterables_iter)\n    \n @classmethod\n def from_iterable(cls,iterable):\n  for it in iterable:\n   for element in it:\n    yield element\n    \nclass combinations:\n def __init__(self,iterable,r):\n  self. pool=tuple(iterable)\n  self. n=len(self. pool)\n  self. r=r\n  self. indices=list(range(self. r))\n  self. zero=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self. r >self. n:\n   raise StopIteration\n  if not self. zero:\n   self. zero=True\n   return tuple(self. pool[i]for i in self. indices)\n  else :\n   try :\n    for i in reversed(range(self. r)):\n     if self. indices[i]!=i+self. n -self. r:\n      break\n    self. indices[i]+=1\n    for j in range(i+1,self. r):\n     self. indices[j]=self. indices[j -1]+1\n    return tuple(self. pool[i]for i in self. indices)\n   except :\n    raise StopIteration\n    \nclass combinations_with_replacement:\n def __init__(self,iterable,r):\n  self. pool=tuple(iterable)\n  self. n=len(self. pool)\n  self. r=r\n  self. indices=[0]*self. r\n  self. zero=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self. n and self. r:\n   raise StopIteration\n  if not self. zero:\n   self. zero=True\n   return tuple(self. pool[i]for i in self. indices)\n  else :\n   try :\n    for i in reversed(range(self. r)):\n     if self. indices[i]!=self. n -1:\n      break\n    self. indices[i:]=[self. indices[i]+1]*(self. r -i)\n    return tuple(self. pool[i]for i in self. indices)\n   except :\n    raise StopIteration\n    \n    \n    \nclass compress:\n def __init__(self,data,selectors):\n  self. data=iter(data)\n  self. selectors=iter(selectors)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True :\n   next_item=next(self. data)\n   next_selector=next(self. selectors)\n   if bool(next_selector):\n    return next_item\n    \n    \n    \n    \nclass count:\n ''\n\n\n\n \n def __init__(self,start=0,step=1):\n  if not isinstance(start,(int,float)):\n   raise TypeError('a number is required')\n  self. times=start -step\n  self. step=step\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  self. times +=self. step\n  return self. times\n  \n def __repr__(self):\n  return'count(%d)'%(self. times+self. step)\n  \n  \n  \nclass cycle:\n def __init__(self,iterable):\n  self. _cur_iter=iter(iterable)\n  self. _saved=[]\n  self. _must_save=True\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  try :\n   next_elt=next(self. _cur_iter)\n   if self. _must_save:\n    self. _saved. append(next_elt)\n  except StopIteration:\n   self. _cur_iter=iter(self. _saved)\n   next_elt=next(self. _cur_iter)\n   self. _must_save=False\n  return next_elt\n  \n  \n  \nclass dropwhile:\n def __init__(self,predicate,iterable):\n  self. _predicate=predicate\n  self. _iter=iter(iterable)\n  self. _dropped=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value=next(self. _iter)\n  if self. _dropped:\n   return value\n  while self. _predicate(value):\n   value=next(self. _iter)\n  self. _dropped=True\n  return value\n  \n  \n  \nclass filterfalse:\n def __init__(self,predicate,iterable):\n \n  self. _iter=iter(iterable)\n  if predicate is None :\n   self. _predicate=bool\n  else :\n   self. _predicate=predicate\n   \n def __iter__(self):\n  return self\n def __next__(self):\n  next_elt=next(self. _iter)\n  while True :\n   if not self. _predicate(next_elt):\n    return next_elt\n   next_elt=next(self. _iter)\n   \nclass groupby:\n\n\n def __init__(self,iterable,key=None ):\n  if key is None :\n   key=lambda x:x\n  self. keyfunc=key\n  self. it=iter(iterable)\n  self. tgtkey=self. currkey=self. currvalue=object()\n def __iter__(self):\n  return self\n def __next__(self):\n  while self. currkey ==self. tgtkey:\n   self. currvalue=next(self. it)\n   self. currkey=self. keyfunc(self. currvalue)\n  self. tgtkey=self. currkey\n  return (self. currkey,self. _grouper(self. tgtkey))\n def _grouper(self,tgtkey):\n  while self. currkey ==tgtkey:\n   yield self. currvalue\n   self. currvalue=next(self. it)\n   self. currkey=self. keyfunc(self. currvalue)\n   \n   \n   \nclass islice:\n def __init__(self,iterable,*args):\n  s=slice(*args)\n  self. start,self. stop,self. step=s. start or 0,s. stop,s. step\n  if not isinstance(self. start,int):\n   raise ValueError(\"Start argument must be an integer\")\n  if self. stop !=None and not isinstance(self. stop,int):\n   raise ValueError(\"Stop argument must be an integer or None\")\n  if self. step is None :\n   self. step=1\n  if self. start <0 or (self. stop !=None and self. stop <0\n  )or self. step <=0:\n   raise ValueError(\"indices for islice() must be positive\")\n  self. it=iter(iterable)\n  self. donext=None\n  self. cnt=0\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  nextindex=self. start\n  if self. stop !=None and nextindex >=self. stop:\n   raise StopIteration\n  while self. cnt <=nextindex:\n   nextitem=next(self. it)\n   self. cnt +=1\n  self. start +=self. step\n  return nextitem\n  \nclass permutations:\n def __init__(self,iterable,r=None ):\n  self. pool=tuple(iterable)\n  self. n=len(self. pool)\n  self. r=self. n if r is None else r\n  self. indices=list(range(self. n))\n  self. cycles=list(range(self. n,self. n -self. r,-1))\n  self. zero=False\n  self. stop=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  indices=self. indices\n  if self. r >self. n:\n   raise StopIteration\n  if not self. zero:\n   self. zero=True\n   return tuple(self. pool[i]for i in indices[:self. r])\n   \n  i=self. r -1\n  while i >=0:\n   j=self. cycles[i]-1\n   if j >0:\n    self. cycles[i]=j\n    indices[i],indices[-j]=indices[-j],indices[i]\n    return tuple(self. pool[i]for i in indices[:self. r])\n   self. cycles[i]=len(indices)-i\n   n1=len(indices)-1\n   assert n1 >=0\n   num=indices[i]\n   for k in range(i,n1):\n    indices[k]=indices[k+1]\n   indices[n1]=num\n   i -=1\n  raise StopIteration\n  \n  \ndef product(*args,repeat=1):\n\n\n pools=[tuple(pool)for pool in args]*repeat\n result=[[]]\n for pool in pools:\n  result=[x+[y]for x in result for y in pool]\n for prod in result:\n  yield tuple(prod)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _product:\n def __init__(self,*args,**kw):\n  if len(kw)>1:\n   raise TypeError(\"product() takes at most 1 argument (%d given)\"%\n   len(kw))\n  self. repeat=kw. get('repeat',1)\n  if not isinstance(self. repeat,int):\n   raise TypeError(\"integer argument expected, got %s\"%\n   type(self. repeat))\n  self. gears=[x for x in args]*self. repeat\n  self. num_gears=len(self. gears)\n  \n  self. indicies=[(0,len(self. gears[x]))\n  for x in range(0,self. num_gears)]\n  self. cont=True\n  self. zero=False\n  \n def roll_gears(self):\n \n \n \n  should_carry=True\n  for n in range(0,self. num_gears):\n   nth_gear=self. num_gears -n -1\n   if should_carry:\n    count,lim=self. indicies[nth_gear]\n    count +=1\n    if count ==lim and nth_gear ==0:\n     self. cont=False\n    if count ==lim:\n     should_carry=True\n     count=0\n    else :\n     should_carry=False\n    self. indicies[nth_gear]=(count,lim)\n   else :\n    break\n    \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self. zero:\n   raise StopIteration\n  if self. repeat >0:\n   if not self. cont:\n    raise StopIteration\n   l=[]\n   for x in range(0,self. num_gears):\n    index,limit=self. indicies[x]\n    print('itertools 353',self. gears,x,index)\n    l. append(self. gears[x][index])\n   self. roll_gears()\n   return tuple(l)\n  elif self. repeat ==0:\n   self. zero=True\n   return ()\n  else :\n   raise ValueError(\"repeat argument cannot be negative\")\n   \n   \n   \nclass repeat:\n def __init__(self,obj,times=None ):\n  self. _obj=obj\n  if times is not None :\n   range(times)\n   if times <0:\n    times=0\n  self. _times=times\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n \n  if self. _times is not None :\n   if self. _times <=0:\n    raise StopIteration()\n   self. _times -=1\n  return self. _obj\n  \n def __repr__(self):\n  if self. _times is not None :\n   return'repeat(%r, %r)'%(self. _obj,self. _times)\n  else :\n   return'repeat(%r)'%(self. _obj,)\n   \n def __len__(self):\n  if self. _times ==-1 or self. _times is None :\n   raise TypeError(\"len() of uniszed object\")\n  return self. _times\n  \n  \n  \nclass starmap(object):\n def __init__(self,function,iterable):\n  self. _func=function\n  self. _iter=iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  t=next(self. _iter)\n  return self. _func(*t)\n  \n  \n  \nclass takewhile(object):\n def __init__(self,predicate,iterable):\n  self. _predicate=predicate\n  self. _iter=iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value=next(self. _iter)\n  if not self. _predicate(value):\n   raise StopIteration()\n  return value\n  \n  \n  \nclass TeeData(object):\n def __init__(self,iterator):\n  self. data=[]\n  self. _iter=iterator\n  \n def __getitem__(self,i):\n \n  while i >=len(self. data):\n   self. data. append(next(self. _iter))\n  return self. data[i]\n  \n  \nclass TeeObject(object):\n def __init__(self,iterable=None ,tee_data=None ):\n  if tee_data:\n   self. tee_data=tee_data\n   self. pos=0\n   \n  elif isinstance(iterable,TeeObject):\n   self. tee_data=iterable. tee_data\n   self. pos=iterable. pos\n  else :\n   self. tee_data=TeeData(iter(iterable))\n   self. pos=0\n   \n def __next__(self):\n  data=self. tee_data[self. pos]\n  self. pos +=1\n  return data\n  \n def __iter__(self):\n  return self\n  \n  \ndef tee(iterable,n=2):\n if isinstance(iterable,TeeObject):\n  return tuple([iterable]+\n  [TeeObject(tee_data=iterable. tee_data)for i in range(n -1)])\n tee_data=TeeData(iter(iterable))\n return tuple([TeeObject(tee_data=tee_data)for i in range(n)])\n \nclass zip_longest:\n def __init__(self,*args,fillvalue=None ):\n  self. args=[iter(arg)for arg in args]\n  self. fillvalue=fillvalue\n  self. units=len(args)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  temp=[]\n  nb=0\n  for i in range(self. units):\n   try :\n    temp. append(next(self. args[i]))\n    nb +=1\n   except StopIteration:\n    temp. append(self. fillvalue)\n  if nb ==0:\n   raise StopIteration\n  return tuple(temp)\n"], "_collections": [".py", "\n\n\n\n\n\n\n\n\n\nimport operator\n\n\n\ndef _thread_ident():\n return -1\n \n \nn=30\nLFTLNK=n\nRGTLNK=n+1\nBLOCKSIZ=n+2\n\n\n\n\n\n\n\n\nclass deque:\n\n def __new__(cls,iterable=(),*args,**kw):\n \n \n  self=object. __new__(cls,*args,**kw)\n  self. clear()\n  return self\n  \n def __init__(self,iterable=(),maxlen=None ):\n  object. __init__(self)\n  self. clear()\n  if maxlen is not None :\n   if maxlen <0:\n    raise ValueError(\"maxlen must be non-negative\")\n  self. _maxlen=maxlen\n  add=self. append\n  for elem in iterable:\n   add(elem)\n   \n @property\n def maxlen(self):\n  return self. _maxlen\n  \n def clear(self):\n  self. right=self. left=[None ]*BLOCKSIZ\n  self. rightndx=n //2\n  self. leftndx=n //2+1\n  self. length=0\n  self. state=0\n  \n def append(self,x):\n  self. state +=1\n  self. rightndx +=1\n  if self. rightndx ==n:\n   newblock=[None ]*BLOCKSIZ\n   self. right[RGTLNK]=newblock\n   newblock[LFTLNK]=self. right\n   self. right=newblock\n   self. rightndx=0\n  self. length +=1\n  self. right[self. rightndx]=x\n  if self. maxlen is not None and self. length >self. maxlen:\n   self. popleft()\n   \n def appendleft(self,x):\n  self. state +=1\n  self. leftndx -=1\n  if self. leftndx ==-1:\n   newblock=[None ]*BLOCKSIZ\n   self. left[LFTLNK]=newblock\n   newblock[RGTLNK]=self. left\n   self. left=newblock\n   self. leftndx=n -1\n  self. length +=1\n  self. left[self. leftndx]=x\n  if self. maxlen is not None and self. length >self. maxlen:\n   self. pop()\n   \n def extend(self,iterable):\n  if iterable is self:\n   iterable=list(iterable)\n  for elem in iterable:\n   self. append(elem)\n   \n def extendleft(self,iterable):\n  if iterable is self:\n   iterable=list(iterable)\n  for elem in iterable:\n   self. appendleft(elem)\n   \n def pop(self):\n  if self. left is self. right and self. leftndx >self. rightndx:\n  \n   raise IndexError(\"pop from an empty deque\")\n  x=self. right[self. rightndx]\n  self. right[self. rightndx]=None\n  self. length -=1\n  self. rightndx -=1\n  self. state +=1\n  if self. rightndx ==-1:\n   prevblock=self. right[LFTLNK]\n   if prevblock is None :\n   \n    self. rightndx=n //2\n    self. leftndx=n //2+1\n   else :\n    prevblock[RGTLNK]=None\n    self. right[LFTLNK]=None\n    self. right=prevblock\n    self. rightndx=n -1\n  return x\n  \n def popleft(self):\n  if self. left is self. right and self. leftndx >self. rightndx:\n  \n   raise IndexError(\"pop from an empty deque\")\n  x=self. left[self. leftndx]\n  self. left[self. leftndx]=None\n  self. length -=1\n  self. leftndx +=1\n  self. state +=1\n  if self. leftndx ==n:\n   prevblock=self. left[RGTLNK]\n   if prevblock is None :\n   \n    self. rightndx=n //2\n    self. leftndx=n //2+1\n   else :\n    prevblock[LFTLNK]=None\n    self. left[RGTLNK]=None\n    self. left=prevblock\n    self. leftndx=0\n  return x\n  \n def count(self,value):\n  c=0\n  for item in self:\n   if item ==value:\n    c +=1\n  return c\n  \n def remove(self,value):\n \n  for i in range(len(self)):\n   if self[i]==value:\n    del self[i]\n    return\n  raise ValueError(\"deque.remove(x): x not in deque\")\n  \n def rotate(self,n=1):\n  length=len(self)\n  if length ==0:\n   return\n  halflen=(length+1)>>1\n  if n >halflen or n <-halflen:\n   n %=length\n   if n >halflen:\n    n -=length\n   elif n <-halflen:\n    n +=length\n  while n >0:\n   self. appendleft(self. pop())\n   n -=1\n  while n <0:\n   self. append(self. popleft())\n   n +=1\n   \n def reverse(self):\n  ''\n  leftblock=self. left\n  rightblock=self. right\n  leftindex=self. leftndx\n  rightindex=self. rightndx\n  for i in range(self. length //2):\n  \n   assert leftblock !=rightblock or leftindex <rightindex\n   \n   \n   (rightblock[rightindex],leftblock[leftindex])=(\n   leftblock[leftindex],rightblock[rightindex])\n   \n   \n   leftindex +=1\n   if leftindex ==n:\n    leftblock=leftblock[RGTLNK]\n    assert leftblock is not None\n    leftindex=0\n    \n    \n   rightindex -=1\n   if rightindex ==-1:\n    rightblock=rightblock[LFTLNK]\n    assert rightblock is not None\n    rightindex=n -1\n    \n def __repr__(self):\n  threadlocalattr='__repr'+str(_thread_ident())\n  if threadlocalattr in self. __dict__:\n   return'deque([...])'\n  else :\n   self. __dict__[threadlocalattr]=True\n   try :\n    if self. maxlen is not None :\n     return'deque(%r, maxlen=%s)'%(list(self),self. maxlen)\n    else :\n     return'deque(%r)'%(list(self),)\n   finally :\n    del self. __dict__[threadlocalattr]\n    \n def __iter__(self):\n  return deque_iterator(self,self. _iter_impl)\n  \n def _iter_impl(self,original_state,giveup):\n  if self. state !=original_state:\n   giveup()\n  block=self. left\n  while block:\n   l,r=0,n\n   if block is self. left:\n    l=self. leftndx\n   if block is self. right:\n    r=self. rightndx+1\n   for elem in block[l:r]:\n    yield elem\n    if self. state !=original_state:\n     giveup()\n   block=block[RGTLNK]\n   \n def __reversed__(self):\n  return deque_iterator(self,self. _reversed_impl)\n  \n def _reversed_impl(self,original_state,giveup):\n  if self. state !=original_state:\n   giveup()\n  block=self. right\n  while block:\n   l,r=0,n\n   if block is self. left:\n    l=self. leftndx\n   if block is self. right:\n    r=self. rightndx+1\n   for elem in reversed(block[l:r]):\n    yield elem\n    if self. state !=original_state:\n     giveup()\n   block=block[LFTLNK]\n   \n def __len__(self):\n \n \n \n \n \n \n  return self. length\n  \n def __getref(self,index):\n  if index >=0:\n   block=self. left\n   while block:\n    l,r=0,n\n    if block is self. left:\n     l=self. leftndx\n    if block is self. right:\n     r=self. rightndx+1\n    span=r -l\n    if index <span:\n     return block,l+index\n    index -=span\n    block=block[RGTLNK]\n  else :\n   block=self. right\n   while block:\n    l,r=0,n\n    if block is self. left:\n     l=self. leftndx\n    if block is self. right:\n     r=self. rightndx+1\n    negative_span=l -r\n    if index >=negative_span:\n     return block,r+index\n    index -=negative_span\n    block=block[LFTLNK]\n  raise IndexError(\"deque index out of range\")\n  \n def __getitem__(self,index):\n  block,index=self. __getref(index)\n  return block[index]\n  \n def __setitem__(self,index,value):\n  block,index=self. __getref(index)\n  block[index]=value\n  \n def __delitem__(self,index):\n  length=len(self)\n  if index >=0:\n   if index >=length:\n    raise IndexError(\"deque index out of range\")\n   self. rotate(-index)\n   self. popleft()\n   self. rotate(index)\n  else :\n  \n   index=index ^(2 **31)\n   if index >=length:\n    raise IndexError(\"deque index out of range\")\n   self. rotate(index)\n   self. pop()\n   self. rotate(-index)\n   \n def __reduce_ex__(self,proto):\n  return type(self),(list(self),self. maxlen)\n  \n def __hash__(self):\n \n  raise TypeError(\"deque objects are unhashable\")\n  \n def __copy__(self):\n  return self. __class__(self,self. maxlen)\n  \n  \n def __eq__(self,other):\n  if isinstance(other,deque):\n   return list(self)==list(other)\n  else :\n   return NotImplemented\n   \n def __ne__(self,other):\n  if isinstance(other,deque):\n   return list(self)!=list(other)\n  else :\n   return NotImplemented\n   \n def __lt__(self,other):\n  if isinstance(other,deque):\n   return list(self)<list(other)\n  else :\n   return NotImplemented\n   \n def __le__(self,other):\n  if isinstance(other,deque):\n   return list(self)<=list(other)\n  else :\n   return NotImplemented\n   \n def __gt__(self,other):\n  if isinstance(other,deque):\n   return list(self)>list(other)\n  else :\n   return NotImplemented\n   \n def __ge__(self,other):\n  if isinstance(other,deque):\n   return list(self)>=list(other)\n  else :\n   return NotImplemented\n   \n def __iadd__(self,other):\n  self. extend(other)\n  return self\n  \n  \nclass deque_iterator(object):\n\n def __init__(self,deq,itergen):\n  self. counter=len(deq)\n  def giveup():\n   self. counter=0\n   \n   raise RuntimeError(\"deque mutated during iteration\")\n  self. _gen=itergen(deq. state,giveup)\n  \n def next(self):\n  res=self. _gen. next()\n  self. counter -=1\n  return res\n  \n def __iter__(self):\n  return self\n  \nclass defaultdict(dict):\n\n def __init__(self,*args,**kwds):\n  if len(args)>0:\n   default_factory=args[0]\n   args=args[1:]\n   if not callable(default_factory)and default_factory is not None :\n    raise TypeError(\"first argument must be callable\")\n  else :\n   default_factory=None\n  dict. __init__(self,args,kwds)\n  self. default_factory=default_factory\n  self. update(args,kwds)\n  super(defaultdict,self). __init__(*args,**kwds)\n  \n  \n  \n  \n  \n  \n  \n  \n def __missing__(self,key):\n \n  if self. default_factory is None :\n   raise KeyError(key)\n  self[key]=value=self. default_factory()\n  return value\n  \n def __repr__(self,recurse=set()):\n  if id(self)in recurse:\n   return\"defaultdict(...)\"\n  try :\n   recurse. add(id(self))\n   return\"defaultdict(%s, %s)\"%(repr(self. default_factory),super(defaultdict,self). __repr__())\n  finally :\n   recurse. remove(id(self))\n   \n def copy(self):\n  return type(self)(self. default_factory,self)\n  \n def __copy__(self):\n  return self. copy()\n  \n def __reduce__(self):\n \n \n \n \n \n \n \n \n \n \n \n  return (type(self),(self. default_factory,),None ,None ,self. items())\n  \nfrom operator import itemgetter as _itemgetter\nfrom keyword import iskeyword as _iskeyword\nimport sys as _sys\n\ndef namedtuple(typename,field_names,verbose=False ,rename=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n if isinstance(field_names,str):\n  field_names=field_names. replace(',',' '). split()\n field_names=tuple(map(str,field_names))\n if rename:\n  names=list(field_names)\n  seen=set()\n  for i,name in enumerate(names):\n   if (not min(c. isalnum()or c =='_'for c in name)or _iskeyword(name)\n   or not name or name[0]. isdigit()or name. startswith('_')\n   or name in seen):\n    names[i]='_%d'%i\n   seen. add(name)\n  field_names=tuple(names)\n for name in (typename,)+field_names:\n  if not min(c. isalnum()or c =='_'for c in name):\n   raise ValueError('Type names and field names can only contain alphanumeric characters and underscores: %r'%name)\n  if _iskeyword(name):\n   raise ValueError('Type names and field names cannot be a keyword: %r'%name)\n  if name[0]. isdigit():\n   raise ValueError('Type names and field names cannot start with a number: %r'%name)\n seen_names=set()\n for name in field_names:\n  if name. startswith('_')and not rename:\n   raise ValueError('Field names cannot start with an underscore: %r'%name)\n  if name in seen_names:\n   raise ValueError('Encountered duplicate field name: %r'%name)\n  seen_names. add(name)\n  \n  \n numfields=len(field_names)\n argtxt=repr(field_names). replace(\"'\",\"\")[1:-1]\n reprtxt=', '. join('%s=%%r'%name for name in field_names)\n \n template='''class %(typename)s(tuple):\n        '%(typename)s(%(argtxt)s)' \\n\n        __slots__ = () \\n\n        _fields = %(field_names)r \\n\n        def __new__(_cls, %(argtxt)s):\n            return tuple.__new__(_cls, (%(argtxt)s)) \\n\n        @classmethod\n        def _make(cls, iterable, new=tuple.__new__, len=len):\n            'Make a new %(typename)s object from a sequence or iterable'\n            result = new(cls, iterable)\n            if len(result) != %(numfields)d:\n                raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result))\n            return result \\n\n        def __repr__(self):\n            return '%(typename)s(%(reprtxt)s)' %% self \\n\n        def _asdict(self):\n            'Return a new dict which maps field names to their values'\n            return dict(zip(self._fields, self)) \\n\n        def _replace(_self, **kwds):\n            'Return a new %(typename)s object replacing specified fields with new values'\n            result = _self._make(map(kwds.pop, %(field_names)r, _self))\n            if kwds:\n                raise ValueError('Got unexpected field names: %%r' %% kwds.keys())\n            return result \\n\n        def __getnewargs__(self):\n            return tuple(self) \\n\\n'''%locals()\n for i,name in enumerate(field_names):\n  template +='        %s = _property(_itemgetter(%d))\\n'%(name,i)\n  \n if verbose:\n  print(template)\n  \n  \n namespace=dict(_itemgetter=_itemgetter,__name__='namedtuple_%s'%typename,\n _property=property,_tuple=tuple)\n try :\n  exec(template,namespace)\n except SyntaxError as e:\n  raise SyntaxError(e. message+':\\n'+template)\n result=namespace[typename]\n \n \n \n \n \n try :\n  result. __module__=_sys. _getframe(1). f_globals. get('__name__','__main__')\n except (AttributeError,ValueError):\n  pass\n  \n return result\n \nif __name__ =='__main__':\n Point=namedtuple('Point',['x','y'])\n p=Point(11,y=22)\n print(p[0]+p[1])\n x,y=p\n print(x,y)\n print(p. x+p. y)\n print(p)\n"], "__future__": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nall_feature_names=[\n\"nested_scopes\",\n\"generators\",\n\"division\",\n\"absolute_import\",\n\"with_statement\",\n\"print_function\",\n\"unicode_literals\",\n\"barry_as_FLUFL\",\n]\n\n__all__=[\"all_feature_names\"]+all_feature_names\n\n\n\n\n\nCO_NESTED=0x0010\nCO_GENERATOR_ALLOWED=0\nCO_FUTURE_DIVISION=0x2000\nCO_FUTURE_ABSOLUTE_IMPORT=0x4000\nCO_FUTURE_WITH_STATEMENT=0x8000\nCO_FUTURE_PRINT_FUNCTION=0x10000\nCO_FUTURE_UNICODE_LITERALS=0x20000\nCO_FUTURE_BARRY_AS_BDFL=0x40000\n\nclass _Feature:\n def __init__(self,optionalRelease,mandatoryRelease,compiler_flag):\n  self. optional=optionalRelease\n  self. mandatory=mandatoryRelease\n  self. compiler_flag=compiler_flag\n  \n def getOptionalRelease(self):\n  ''\n\n\n  \n  \n  return self. optional\n  \n def getMandatoryRelease(self):\n  ''\n\n\n\n  \n  \n  return self. mandatory\n  \n def __repr__(self):\n  return\"_Feature\"+repr((self. optional,\n  self. mandatory,\n  self. compiler_flag))\n  \nnested_scopes=_Feature((2,1,0,\"beta\",1),\n(2,2,0,\"alpha\",0),\nCO_NESTED)\n\ngenerators=_Feature((2,2,0,\"alpha\",1),\n(2,3,0,\"final\",0),\nCO_GENERATOR_ALLOWED)\n\ndivision=_Feature((2,2,0,\"alpha\",2),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_DIVISION)\n\nabsolute_import=_Feature((2,5,0,\"alpha\",1),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_ABSOLUTE_IMPORT)\n\nwith_statement=_Feature((2,5,0,\"alpha\",1),\n(2,6,0,\"alpha\",0),\nCO_FUTURE_WITH_STATEMENT)\n\nprint_function=_Feature((2,6,0,\"alpha\",2),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_PRINT_FUNCTION)\n\nunicode_literals=_Feature((2,6,0,\"alpha\",2),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_UNICODE_LITERALS)\n\nbarry_as_FLUFL=_Feature((3,1,0,\"alpha\",2),\n(3,9,0,\"alpha\",0),\nCO_FUTURE_BARRY_AS_BDFL)\n"], "_abcoll": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) for collections, according to PEP 3119.\n\nDON'T USE THIS MODULE DIRECTLY!  The classes here should be imported\nvia collections; they are defined here only to alleviate certain\nbootstrapping issues.  Unit tests are in test_collections.\n\"\"\"\n\n\n\n\nimport sys\n\n__all__=[\"Hashable\",\"Iterable\",\"Iterator\",\n\"Sized\",\"Container\",\"Callable\",\n\"Set\",\"MutableSet\",\n\"Mapping\",\"MutableMapping\",\n\"MappingView\",\"KeysView\",\"ItemsView\",\"ValuesView\",\n\"Sequence\",\"MutableSequence\",\n\"ByteString\",\n]\n\n\"\"\"\n### collection related types which are not exposed through builtin ###\n## iterators ##\n#fixme brython\n#bytes_iterator = type(iter(b''))\nbytes_iterator = type(iter(''))\n#fixme brython\n#bytearray_iterator = type(iter(bytearray()))\n#callable_iterator = ???\ndict_keyiterator = type(iter({}.keys()))\ndict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\ndict_proxy = type(type.__dict__)\n\"\"\"\n\ndef abstractmethod(self):\n return self\n \n \n \n \n \nclass Iterable:\n\n @abstractmethod\n def __iter__(self):\n  while False :\n   yield None\n   \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Iterable:\n   if any(\"__iter__\"in B. __dict__ for B in C. __mro__):\n    return True\n  return NotImplemented\n  \n  \n  \nclass Sized:\n\n @abstractmethod\n def __len__(self):\n  return 0\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Sized:\n   if any(\"__len__\"in B. __dict__ for B in C. __mro__):\n    return True\n  return NotImplemented\n  \n  \n  \nclass Container:\n\n @abstractmethod\n def __contains__(self,x):\n  return False\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Container:\n   if any(\"__contains__\"in B. __dict__ for B in C. __mro__):\n    return True\n  return NotImplemented\n  \n  \n  \n  \nclass Mapping(Sized,Iterable,Container):\n\n @abstractmethod\n def __getitem__(self,key):\n  raise KeyError\n  \n def get(self,key,default=None ):\n  try :\n   return self[key]\n  except KeyError:\n   return default\n   \n def __contains__(self,key):\n  try :\n   self[key]\n  except KeyError:\n   return False\n  else :\n   return True\n   \n def keys(self):\n  return KeysView(self)\n  \n def items(self):\n  return ItemsView(self)\n  \n def values(self):\n  return ValuesView(self)\n  \n def __eq__(self,other):\n  if not isinstance(other,Mapping):\n   return NotImplemented\n  return dict(self. items())==dict(other. items())\n  \n def __ne__(self,other):\n  return not (self ==other)\n  \n  \nclass MutableMapping(Mapping):\n\n @abstractmethod\n def __setitem__(self,key,value):\n  raise KeyError\n  \n @abstractmethod\n def __delitem__(self,key):\n  raise KeyError\n  \n __marker=object()\n \n def pop(self,key,default=__marker):\n  try :\n   value=self[key]\n  except KeyError:\n   if default is self. __marker:\n    raise\n   return default\n  else :\n   del self[key]\n   return value\n   \n def popitem(self):\n  try :\n   key=next(iter(self))\n  except StopIteration:\n   raise KeyError\n  value=self[key]\n  del self[key]\n  return key,value\n  \n def clear(self):\n  try :\n   while True :\n    self. popitem()\n  except KeyError:\n   pass\n   \n def update(*args,**kwds):\n  if len(args)>2:\n   raise TypeError(\"update() takes at most 2 positional \"\n   \"arguments ({} given)\". format(len(args)))\n  elif not args:\n   raise TypeError(\"update() takes at least 1 argument (0 given)\")\n  self=args[0]\n  other=args[1]if len(args)>=2 else ()\n  \n  if isinstance(other,Mapping):\n   for key in other:\n    self[key]=other[key]\n  elif hasattr(other,\"keys\"):\n   for key in other. keys():\n    self[key]=other[key]\n  else :\n   for key,value in other:\n    self[key]=value\n  for key,value in kwds. items():\n   self[key]=value\n   \n def setdefault(self,key,default=None ):\n  try :\n   return self[key]\n  except KeyError:\n   self[key]=default\n  return default\n  \n  \n"], "traceback": [".py", "import sys\nfrom browser import console\n\ndef _restore_current(exc):\n ''\n\n \n __BRYTHON__. current_exception=exc\n \ndef print_exc(file=sys. stderr):\n exc=__BRYTHON__. current_exception\n if isinstance(exc,SyntaxError):\n  file. write('\\n module %s line %s'%(exc. args[1],exc. args[2]))\n  offset=exc. args[3]\n  file. write('\\n  '+exc. args[4])\n  file. write('\\n  '+offset *' '+'^')\n else :\n  file. write(exc. info)\n msg=exc. __name__\n if exc. args:\n  msg +=': %s'%exc. args[0]\n file. write(msg+'\\n')\n _restore_current(exc)\n \ndef format_exc(limit=None ,chain=True ):\n exc=__BRYTHON__. current_exception\n res=exc. info+'\\n'+exc. __name__\n if exc. args:\n  res +=': '+exc. args[0]\n _restore_current(exc)\n return res+'\\n'\n \ndef format_exception(_type,value,tb,limit=None ,chain=True ):\n return ['%s\\n'%_type,'%s\\n'%value]\n \ndef extract_tb(tb,limit=None ):\n return tb"], "_codecs": [".py", "\ndef ascii_decode(*args,**kw):\n pass\n \ndef ascii_encode(*args,**kw):\n pass\n \ndef charbuffer_encode(*args,**kw):\n pass\n \ndef charmap_build(*args,**kw):\n pass\n \ndef charmap_decode(*args,**kw):\n pass\n \ndef charmap_encode(*args,**kw):\n pass\n \ndef decode(*args,**kw):\n ''\n\n\n\n\n\n \n pass\n \ndef encode(*args,**kw):\n ''\n\n\n\n\n\n \n obj=args[0]\n if len(args)==2:\n  encoding=args[1]\n else :\n  encoding='utf-8'\n if isinstance(obj,str):\n  return obj. encode(encoding)\n  \ndef escape_decode(*args,**kw):\n pass\n \ndef escape_encode(*args,**kw):\n pass\n \ndef latin_1_decode(*args,**kw):\n pass\n \ndef latin_1_encode(*args,**kw):\n pass\n \ndef lookup(encoding):\n ''\n\n \n \n if encoding in ('utf-8','utf_8'):\n  from javascript import console\n  console. log('encoding',encoding)\n  import encodings. utf_8\n  return encodings. utf_8. getregentry()\n  \n LookupError(encoding)\n \ndef lookup_error(*args,**kw):\n ''\n\n \n pass\n \ndef mbcs_decode(*args,**kw):\n pass\n \ndef mbcs_encode(*args,**kw):\n pass\n \ndef raw_unicode_escape_decode(*args,**kw):\n pass\n \ndef raw_unicode_escape_encode(*args,**kw):\n pass\n \ndef readbuffer_encode(*args,**kw):\n pass\n \ndef register(*args,**kw):\n ''\n\n\n\n \n pass\n \ndef register_error(*args,**kw):\n ''\n\n\n\n\n \n pass\n \ndef unicode_escape_decode(*args,**kw):\n pass\n \ndef unicode_escape_encode(*args,**kw):\n pass\n \ndef unicode_internal_decode(*args,**kw):\n pass\n \ndef unicode_internal_encode(*args,**kw):\n pass\n \ndef utf_16_be_decode(*args,**kw):\n pass\n \ndef utf_16_be_encode(*args,**kw):\n pass\n \ndef utf_16_decode(*args,**kw):\n pass\n \ndef utf_16_encode(*args,**kw):\n pass\n \ndef utf_16_ex_decode(*args,**kw):\n pass\n \ndef utf_16_le_decode(*args,**kw):\n pass\n \ndef utf_16_le_encode(*args,**kw):\n pass\n \ndef utf_32_be_decode(*args,**kw):\n pass\n \ndef utf_32_be_encode(*args,**kw):\n pass\n \ndef utf_32_decode(*args,**kw):\n pass\n \ndef utf_32_encode(*args,**kw):\n pass\n \ndef utf_32_ex_decode(*args,**kw):\n pass\n \ndef utf_32_le_decode(*args,**kw):\n pass\n \ndef utf_32_le_encode(*args,**kw):\n pass\n \ndef utf_7_decode(*args,**kw):\n pass\n \ndef utf_7_encode(*args,**kw):\n pass\n \ndef utf_8_decode(*args,**kw):\n pass\n \ndef utf_8_encode(*args,**kw):\n input=args[0]\n if len(args)==2:\n  errors=args[1]\n else :\n  errors=kw. get('errors','strict')\n  \n  \n  \n return (bytes([_f for _f in input],'utf-8'),len(input))\n"], "builtins": [".js", "var $module = (function(){\n    var obj = {__class__:__BRYTHON__.$ModuleDict,__name__:'builtins'}\n    var builtin_names = ['ArithmeticError', 'AssertionError', 'AttributeError', \n    'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', \n    'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', \n    'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', \n    'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', \n    'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', \n    'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', \n    'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError',\n    'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', \n    'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', \n    'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', \n    'ProcessLookupError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', \n    'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning', \n    'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', \n    'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', \n    'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', \n    'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', \n    '__build_class__', '__debug__', '__doc__', '__import__', '__name__', \n    '__package__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', \n    'bytes','callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', \n    'credits','delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', \n    'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', \n    'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', \n    'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', \n    'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', \n    'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', \n    'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', \n    'vars', 'zip']\n    for(var i=0, _len_i = builtin_names.length; i < _len_i;i++){\n        try{eval(\"obj['\"+builtin_names[i]+\"']=__BRYTHON__.builtins.\"+builtin_names[i])}\n        catch(err){if (__BRYTHON__.$debug) {console.log(err)}}\n    }\n    return obj\n})()\n"], "uuid": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__author__='Ka-Ping Yee <ping@zesty.ca>'\n\nRESERVED_NCS,RFC_4122,RESERVED_MICROSOFT,RESERVED_FUTURE=[\n'reserved for NCS compatibility','specified in RFC 4122',\n'reserved for Microsoft compatibility','reserved for future definition']\n\nint_=int\nbytes_=bytes\n\nclass UUID(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,hex=None ,bytes=None ,bytes_le=None ,fields=None ,\n int=None ,version=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if [hex,bytes,bytes_le,fields,int]. count(None )!=4:\n   raise TypeError('need one of hex, bytes, bytes_le, fields, or int')\n  if hex is not None :\n   hex=hex. replace('urn:',''). replace('uuid:','')\n   hex=hex. strip('{}'). replace('-','')\n   if len(hex)!=32:\n    raise ValueError('badly formed hexadecimal UUID string')\n   int=int_(hex,16)\n  if bytes_le is not None :\n   if len(bytes_le)!=16:\n    raise ValueError('bytes_le is not a 16-char string')\n   bytes=(bytes_(reversed(bytes_le[0:4]))+\n   bytes_(reversed(bytes_le[4:6]))+\n   bytes_(reversed(bytes_le[6:8]))+\n   bytes_le[8:])\n  if bytes is not None :\n   if len(bytes)!=16:\n    raise ValueError('bytes is not a 16-char string')\n   assert isinstance(bytes,bytes_),repr(bytes)\n   int=int_. from_bytes(bytes,byteorder='big')\n  if fields is not None :\n   if len(fields)!=6:\n    raise ValueError('fields is not a 6-tuple')\n   (time_low,time_mid,time_hi_version,\n   clock_seq_hi_variant,clock_seq_low,node)=fields\n   if not 0 <=time_low <1 <<32:\n    raise ValueError('field 1 out of range (need a 32-bit value)')\n   if not 0 <=time_mid <1 <<16:\n    raise ValueError('field 2 out of range (need a 16-bit value)')\n   if not 0 <=time_hi_version <1 <<16:\n    raise ValueError('field 3 out of range (need a 16-bit value)')\n   if not 0 <=clock_seq_hi_variant <1 <<8:\n    raise ValueError('field 4 out of range (need an 8-bit value)')\n   if not 0 <=clock_seq_low <1 <<8:\n    raise ValueError('field 5 out of range (need an 8-bit value)')\n   if not 0 <=node <1 <<48:\n    raise ValueError('field 6 out of range (need a 48-bit value)')\n   clock_seq=(clock_seq_hi_variant <<8)|clock_seq_low\n   int=((time_low <<96)|(time_mid <<80)|\n   (time_hi_version <<64)|(clock_seq <<48)|node)\n  if int is not None :\n   if not 0 <=int <1 <<128:\n    raise ValueError('int is out of range (need a 128-bit value)')\n  if version is not None :\n   if not 1 <=version <=5:\n    raise ValueError('illegal version number')\n    \n   int &=~(0xc000 <<48)\n   int |=0x8000 <<48\n   \n   int &=~(0xf000 <<64)\n   int |=version <<76\n  self. __dict__['int']=int\n  \n def __eq__(self,other):\n  if isinstance(other,UUID):\n   return self. int ==other. int\n  return NotImplemented\n  \n def __ne__(self,other):\n  if isinstance(other,UUID):\n   return self. int !=other. int\n  return NotImplemented\n  \n  \n  \n  \n def __lt__(self,other):\n  if isinstance(other,UUID):\n   return self. int <other. int\n  return NotImplemented\n  \n def __gt__(self,other):\n  if isinstance(other,UUID):\n   return self. int >other. int\n  return NotImplemented\n  \n def __le__(self,other):\n  if isinstance(other,UUID):\n   return self. int <=other. int\n  return NotImplemented\n  \n def __ge__(self,other):\n  if isinstance(other,UUID):\n   return self. int >=other. int\n  return NotImplemented\n  \n def __hash__(self):\n  return hash(self. int)\n  \n def __int__(self):\n  return self. int\n  \n def __repr__(self):\n  return'UUID(%r)'%str(self)\n  \n def __setattr__(self,name,value):\n  raise TypeError('UUID objects are immutable')\n  \n def __str__(self):\n  hex='%032x'%self. int\n  return'%s-%s-%s-%s-%s'%(\n  hex[:8],hex[8:12],hex[12:16],hex[16:20],hex[20:])\n  \n @property\n def bytes(self):\n  bytes=bytearray()\n  for shift in range(0,128,8):\n   bytes. insert(0,(self. int >>shift)&0xff)\n  return bytes_(bytes)\n  \n @property\n def bytes_le(self):\n  bytes=self. bytes\n  return (bytes_(reversed(bytes[0:4]))+\n  bytes_(reversed(bytes[4:6]))+\n  bytes_(reversed(bytes[6:8]))+\n  bytes[8:])\n  \n @property\n def fields(self):\n  return (self. time_low,self. time_mid,self. time_hi_version,\n  self. clock_seq_hi_variant,self. clock_seq_low,self. node)\n  \n @property\n def time_low(self):\n  return self. int >>96\n  \n @property\n def time_mid(self):\n  return (self. int >>80)&0xffff\n  \n @property\n def time_hi_version(self):\n  return (self. int >>64)&0xffff\n  \n @property\n def clock_seq_hi_variant(self):\n  return (self. int >>56)&0xff\n  \n @property\n def clock_seq_low(self):\n  return (self. int >>48)&0xff\n  \n @property\n def time(self):\n  return (((self. time_hi_version&0x0fff)<<48)|\n  (self. time_mid <<32)|self. time_low)\n  \n @property\n def clock_seq(self):\n  return (((self. clock_seq_hi_variant&0x3f)<<8)|\n  self. clock_seq_low)\n  \n @property\n def node(self):\n  return self. int&0xffffffffffff\n  \n @property\n def hex(self):\n  return'%032x'%self. int\n  \n @property\n def urn(self):\n  return'urn:uuid:'+str(self)\n  \n @property\n def variant(self):\n  if not self. int&(0x8000 <<48):\n   return RESERVED_NCS\n  elif not self. int&(0x4000 <<48):\n   return RFC_4122\n  elif not self. int&(0x2000 <<48):\n   return RESERVED_MICROSOFT\n  else :\n   return RESERVED_FUTURE\n   \n @property\n def version(self):\n \n  if self. variant ==RFC_4122:\n   return int((self. int >>76)&0xf)\n   \ndef _find_mac(command,args,hw_identifiers,get_index):\n import os,shutil\n executable=shutil. which(command)\n if executable is None :\n  path=os. pathsep. join(('/sbin','/usr/sbin'))\n  executable=shutil. which(command,path=path)\n  if executable is None :\n   return None\n   \n try :\n \n \n \n  cmd='LC_ALL=C %s %s 2>/dev/null'%(executable,args)\n  with os. popen(cmd)as pipe:\n   for line in pipe:\n    words=line. lower(). split()\n    for i in range(len(words)):\n     if words[i]in hw_identifiers:\n      try :\n       return int(\n       words[get_index(i)]. replace(':',''),16)\n      except (ValueError,IndexError):\n      \n      \n      \n      \n      \n       pass\n except OSError:\n  pass\n  \ndef _ifconfig_getnode():\n ''\n \n \n for args in ('','-a','-av'):\n  mac=_find_mac('ifconfig',args,['hwaddr','ether'],lambda i:i+1)\n  if mac:\n   return mac\n   \n import socket\n ip_addr=socket. gethostbyname(socket. gethostname())\n \n \n mac=_find_mac('arp','-an',[ip_addr],lambda i:-1)\n if mac:\n  return mac\n  \n  \n mac=_find_mac('lanscan','-ai',['lan0'],lambda i:0)\n if mac:\n  return mac\n  \n return None\n \ndef _ipconfig_getnode():\n ''\n import os,re\n dirs=['',r'c:\\windows\\system32',r'c:\\winnt\\system32']\n try :\n  import ctypes\n  buffer=ctypes. create_string_buffer(300)\n  ctypes. windll. kernel32. GetSystemDirectoryA(buffer,300)\n  dirs. insert(0,buffer. value. decode('mbcs'))\n except :\n  pass\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef _netbios_getnode():\n ''\n \n import win32wnet,netbios\n ncb=netbios. NCB()\n ncb. Command=netbios. NCBENUM\n ncb. Buffer=adapters=netbios. LANA_ENUM()\n adapters. _pack()\n if win32wnet. Netbios(ncb)!=0:\n  return\n adapters. _unpack()\n for i in range(adapters. length):\n  ncb. Reset()\n  ncb. Command=netbios. NCBRESET\n  ncb. Lana_num=ord(adapters. lana[i])\n  if win32wnet. Netbios(ncb)!=0:\n   continue\n  ncb. Reset()\n  ncb. Command=netbios. NCBASTAT\n  ncb. Lana_num=ord(adapters. lana[i])\n  ncb. Callname='*'. ljust(16)\n  ncb. Buffer=status=netbios. ADAPTER_STATUS()\n  if win32wnet. Netbios(ncb)!=0:\n   continue\n  status. _unpack()\n  bytes=status. adapter_address\n  return ((bytes[0]<<40)+(bytes[1]<<32)+(bytes[2]<<24)+\n  (bytes[3]<<16)+(bytes[4]<<8)+bytes[5])\n  \n  \n  \n  \n  \n_uuid_generate_random=_uuid_generate_time=_UuidCreate=None\ntry :\n import ctypes,ctypes. util\n \n \n \n for libname in ['uuid','c']:\n  try :\n   lib=ctypes. CDLL(ctypes. util. find_library(libname))\n  except :\n   continue\n  if hasattr(lib,'uuid_generate_random'):\n   _uuid_generate_random=lib. uuid_generate_random\n  if hasattr(lib,'uuid_generate_time'):\n   _uuid_generate_time=lib. uuid_generate_time\n   if _uuid_generate_random is not None :\n    break\n    \n    \n    \n    \n    \n    \n    \n    \n import sys\n if sys. platform =='darwin':\n  import os\n  if int(os. uname(). release. split('.')[0])>=9:\n   _uuid_generate_random=_uuid_generate_time=None\n   \n   \n   \n   \n   \n   \n   \n   \n   \n try :\n  lib=ctypes. windll. rpcrt4\n except :\n  lib=None\n _UuidCreate=getattr(lib,'UuidCreateSequential',\n getattr(lib,'UuidCreate',None ))\nexcept :\n pass\n \ndef _unixdll_getnode():\n ''\n _buffer=ctypes. create_string_buffer(16)\n _uuid_generate_time(_buffer)\n return UUID(bytes=bytes_(_buffer. raw)). node\n \ndef _windll_getnode():\n ''\n _buffer=ctypes. create_string_buffer(16)\n if _UuidCreate(_buffer)==0:\n  return UUID(bytes=bytes_(_buffer. raw)). node\n  \ndef _random_getnode():\n ''\n import random\n return random. randrange(0,1 <<48)|0x010000000000\n \n_node=None\n\ndef getnode():\n ''\n\n\n\n\n\n \n \n global _node\n if _node is not None :\n  return _node\n  \n import sys\n if sys. platform =='win32':\n  getters=[_windll_getnode,_netbios_getnode,_ipconfig_getnode]\n else :\n  getters=[_unixdll_getnode,_ifconfig_getnode]\n  \n for getter in getters+[_random_getnode]:\n  try :\n   _node=getter()\n  except :\n   continue\n  if _node is not None :\n   return _node\n   \n_last_timestamp=None\n\ndef uuid1(node=None ,clock_seq=None ):\n ''\n\n\n \n \n \n \n if _uuid_generate_time and node is clock_seq is None :\n  _buffer=ctypes. create_string_buffer(16)\n  _uuid_generate_time(_buffer)\n  return UUID(bytes=bytes_(_buffer. raw))\n  \n global _last_timestamp\n import time\n nanoseconds=int(time. time()*1e9)\n \n \n timestamp=int(nanoseconds /100)+0x01b21dd213814000\n if _last_timestamp is not None and timestamp <=_last_timestamp:\n  timestamp=_last_timestamp+1\n _last_timestamp=timestamp\n if clock_seq is None :\n  import random\n  clock_seq=random. randrange(1 <<14)\n time_low=timestamp&0xffffffff\n time_mid=(timestamp >>32)&0xffff\n time_hi_version=(timestamp >>48)&0x0fff\n clock_seq_low=clock_seq&0xff\n clock_seq_hi_variant=(clock_seq >>8)&0x3f\n if node is None :\n  node=getnode()\n return UUID(fields=(time_low,time_mid,time_hi_version,\n clock_seq_hi_variant,clock_seq_low,node),version=1)\n \ndef uuid3(namespace,name):\n ''\n from hashlib import md5\n hash=md5(namespace. bytes+bytes(name,\"utf-8\")). digest()\n return UUID(bytes=hash[:16],version=3)\n \ndef uuid4():\n ''\n \n \n if _uuid_generate_random:\n  _buffer=ctypes. create_string_buffer(16)\n  _uuid_generate_random(_buffer)\n  return UUID(bytes=bytes_(_buffer. raw))\n  \n  \n try :\n  import os\n  return UUID(bytes=os. urandom(16),version=4)\n except :\n  import random\n  bytes=bytes_(random. randrange(256)for i in range(16))\n  return UUID(bytes=bytes,version=4)\n  \ndef uuid5(namespace,name):\n ''\n from hashlib import sha1\n hash=sha1(namespace. bytes+bytes(name,\"utf-8\")). digest()\n return UUID(bytes=hash[:16],version=5)\n \n \n \nNAMESPACE_DNS=UUID('6ba7b810-9dad-11d1-80b4-00c04fd430c8')\nNAMESPACE_URL=UUID('6ba7b811-9dad-11d1-80b4-00c04fd430c8')\nNAMESPACE_OID=UUID('6ba7b812-9dad-11d1-80b4-00c04fd430c8')\nNAMESPACE_X500=UUID('6ba7b814-9dad-11d1-80b4-00c04fd430c8')\n"], "genericpath": [".py", "''\n\n\n\n\nimport os\nimport stat\n\n__all__=['commonprefix','exists','getatime','getctime','getmtime',\n'getsize','isdir','isfile']\n\n\n\n\ndef exists(path):\n ''\n try :\n  os. stat(path)\n except os. error:\n  return False\n return True\n \n \n \n \ndef isfile(path):\n ''\n try :\n  st=os. stat(path)\n except os. error:\n  return False\n return stat. S_ISREG(st. st_mode)\n \n \n \n \n \ndef isdir(s):\n ''\n try :\n  st=os. stat(s)\n except os. error:\n  return False\n return stat. S_ISDIR(st. st_mode)\n \n \ndef getsize(filename):\n ''\n return os. stat(filename). st_size\n \n \ndef getmtime(filename):\n ''\n return os. stat(filename). st_mtime\n \n \ndef getatime(filename):\n ''\n return os. stat(filename). st_atime\n \n \ndef getctime(filename):\n ''\n return os. stat(filename). st_ctime\n \n \n \ndef commonprefix(m):\n ''\n if not m:return''\n s1=min(m)\n s2=max(m)\n for i,c in enumerate(s1):\n  if c !=s2[i]:\n   return s1[:i]\n return s1\n \n \n \n \n \n \n \n \ndef _splitext(p,sep,altsep,extsep):\n ''\n\n\n \n \n \n sepIndex=p. rfind(sep)\n if altsep:\n  altsepIndex=p. rfind(altsep)\n  sepIndex=max(sepIndex,altsepIndex)\n  \n dotIndex=p. rfind(extsep)\n if dotIndex >sepIndex:\n \n  filenameIndex=sepIndex+1\n  while filenameIndex <dotIndex:\n   if p[filenameIndex:filenameIndex+1]!=extsep:\n    return p[:dotIndex],p[dotIndex:]\n   filenameIndex +=1\n   \n return p,p[:0]\n"], "io": [".py", "import builtins\n\nopen=builtins. open\n\n\nSEEK_SET=0\nSEEK_CUR=1\nSEEK_END=2\n\nr\"\"\"File-like objects that read from or write to a string buffer.\n\nThis implements (nearly) all stdio methods.\n\nf = StringIO()      # ready for writing\nf = StringIO(buf)   # ready for reading\nf.close()           # explicitly release resources held\nflag = f.isatty()   # always false\npos = f.tell()      # get current position\nf.seek(pos)         # set current position\nf.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF\nbuf = f.read()      # read until EOF\nbuf = f.read(n)     # read up to n bytes\nbuf = f.readline()  # read until end of line ('\\n') or EOF\nlist = f.readlines()# list of f.readline() results until EOF\nf.truncate([size])  # truncate file at to at most size (default: current pos)\nf.write(buf)        # write at current position\nf.writelines(list)  # for line in list: f.write(line)\nf.getvalue()        # return whole file's contents as a string\n\nNotes:\n- Using a real file is often faster (but less convenient).\n- There's also a much faster implementation in C, called cStringIO, but\n  it's not subclassable.\n- fileno() is left unimplemented so that code which uses it triggers\n  an exception early.\n- Seeking far beyond EOF and then writing will insert real null\n  bytes that occupy space in the buffer.\n- There's a simple test set (see end of this file).\n\"\"\"\ntry :\n from errno import EINVAL\nexcept ImportError:\n EINVAL=22\n \n__all__=[\"StringIO\"]\n\ndef _complain_ifclosed(closed):\n if closed:\n  raise ValueError(\"I/O operation on closed file\")\n  \nclass StringIO:\n ''\n\n\n\n\n\n\n\n\n\n \n def __init__(self,buf=''):\n  self. buf=buf\n  self. len=len(buf)\n  self. buflist=[]\n  self. pos=0\n  self. closed=False\n  self. softspace=0\n  \n def __iter__(self):\n  return self\n  \n def next(self):\n  ''\n\n\n\n\n  \n  _complain_ifclosed(self. closed)\n  r=self. readline()\n  if not r:\n   raise StopIteration\n  return r\n  \n def close(self):\n  ''\n  \n  if not self. closed:\n   self. closed=True\n   del self. buf,self. pos\n   \n def isatty(self):\n  ''\n\n  \n  _complain_ifclosed(self. closed)\n  return False\n  \n def seek(self,pos,mode=0):\n  ''\n\n\n\n\n\n\n  \n  _complain_ifclosed(self. closed)\n  if self. buflist:\n   self. buf +=''. join(self. buflist)\n   self. buflist=[]\n  if mode ==1:\n   pos +=self. pos\n  elif mode ==2:\n   pos +=self. len\n  self. pos=max(0,pos)\n  \n def tell(self):\n  ''\n  _complain_ifclosed(self. closed)\n  return self. pos\n  \n def read(self,n=-1):\n  ''\n\n\n\n\n\n  \n  _complain_ifclosed(self. closed)\n  if self. buflist:\n   self. buf +=''. join(self. buflist)\n   self. buflist=[]\n  if n is None or n <0:\n   newpos=self. len\n  else :\n   newpos=min(self. pos+n,self. len)\n  r=self. buf[self. pos:newpos]\n  self. pos=newpos\n  return r\n  \n def readline(self,length=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  _complain_ifclosed(self. closed)\n  if self. buflist:\n   self. buf +=''. join(self. buflist)\n   self. buflist=[]\n  i=self. buf. find('\\n',self. pos)\n  if i <0:\n   newpos=self. len\n  else :\n   newpos=i+1\n  if length is not None and length >=0:\n   if self. pos+length <newpos:\n    newpos=self. pos+length\n  r=self. buf[self. pos:newpos]\n  self. pos=newpos\n  return r\n  \n def readlines(self,sizehint=0):\n  ''\n\n\n\n\n\n  \n  total=0\n  lines=[]\n  line=self. readline()\n  while line:\n   lines. append(line)\n   total +=len(line)\n   if 0 <sizehint <=total:\n    break\n   line=self. readline()\n  return lines\n  \n def truncate(self,size=None ):\n  ''\n\n\n\n\n\n\n\n\n  \n  _complain_ifclosed(self. closed)\n  if size is None :\n   size=self. pos\n  elif size <0:\n   raise IOError(EINVAL,\"Negative size not allowed\")\n  elif size <self. pos:\n   self. pos=size\n  self. buf=self. getvalue()[:size]\n  self. len=size\n  \n def write(self,s):\n  ''\n\n\n  \n  _complain_ifclosed(self. closed)\n  if not s:return\n  spos=self. pos\n  slen=self. len\n  if spos ==slen:\n   self. buflist. append(s)\n   self. len=self. pos=spos+len(s)\n   return\n  if spos >slen:\n   self. buflist. append('\\0'*(spos -slen))\n   slen=spos\n  newpos=spos+len(s)\n  if spos <slen:\n   if self. buflist:\n    self. buf +=''. join(self. buflist)\n   self. buflist=[self. buf[:spos],s,self. buf[newpos:]]\n   self. buf=''\n   if newpos >slen:\n    slen=newpos\n  else :\n   self. buflist. append(s)\n   slen=newpos\n  self. len=slen\n  self. pos=newpos\n  \n def writelines(self,iterable):\n  ''\n\n\n\n\n\n  \n  write=self. write\n  for line in iterable:\n   write(line)\n   \n def flush(self):\n  ''\n  \n  _complain_ifclosed(self. closed)\n  \n def getvalue(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  _complain_ifclosed(self. closed)\n  if self. buflist:\n   self. buf +=''. join(self. buflist)\n   self. buflist=[]\n  return self. buf\n  \n  \nTextIOWrapper=StringIO\n\n\nclass RawIOBase:\n\n def read(self,n=-1):\n  pass\n def readall(self):\n  pass\n def readinto(self,b):\n  pass\n def write(self,b):\n  pass\n  \n  \nBufferedIOBase=RawIOBase\nBufferedReader=RawIOBase\nBytesIO=StringIO\n\n\n"], "os": [".py", "''\n\n\n\nimport sys\n\nerror=OSError\nname='posix'\nlinesep='\\n'\n\nfrom posix import *\nimport posixpath as path\n\nsys. modules['os.path']=path\nfrom os. path import (curdir,pardir,sep,pathsep,defpath,extsep,altsep,\ndevnull)\n\n\nenviron={'HOME':__BRYTHON__. curdir}\n\ndef getenv(key,default=None ):\n ''\n\n \n return environ. get(key,default)\n \nsupports_bytes_environ=True\n\ndef chdir(path):\n __BRYTHON__. curdir=path\n \ndef getcwd():\n return __BRYTHON__. curdir\n"], "pprint": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\"Support to pretty-print lists, tuples, & dictionaries recursively.\n\nVery simple, but useful, especially in debugging data structures.\n\nClasses\n-------\n\nPrettyPrinter()\n    Handle pretty-printing operations onto a stream using a configured\n    set of formatting parameters.\n\nFunctions\n---------\n\npformat()\n    Format a Python object into a pretty-printed representation.\n\npprint()\n    Pretty-print a Python object to a stream [default is sys.stdout].\n\nsaferepr()\n    Generate a 'standard' repr()-like value, but protect against recursive\n    data structures.\n\n\"\"\"\n\nimport sys as _sys\nfrom collections import OrderedDict as _OrderedDict\nfrom io import StringIO as _StringIO\n\n__all__=[\"pprint\",\"pformat\",\"isreadable\",\"isrecursive\",\"saferepr\",\n\"PrettyPrinter\"]\n\n\n_commajoin=\", \". join\n_id=id\n_len=len\n_type=type\n\n\ndef pprint(object,stream=None ,indent=1,width=80,depth=None ):\n ''\n printer=PrettyPrinter(\n stream=stream,indent=indent,width=width,depth=depth)\n printer. pprint(object)\n \ndef pformat(object,indent=1,width=80,depth=None ):\n ''\n return PrettyPrinter(indent=indent,width=width,depth=depth). pformat(object)\n \ndef saferepr(object):\n ''\n return _safe_repr(object,{},None ,0)[0]\n \ndef isreadable(object):\n ''\n return _safe_repr(object,{},None ,0)[1]\n \ndef isrecursive(object):\n ''\n return _safe_repr(object,{},None ,0)[2]\n \nclass _safe_key:\n ''\n\n\n\n\n\n\n \n \n __slots__=['obj']\n \n def __init__(self,obj):\n  self. obj=obj\n  \n def __lt__(self,other):\n  try :\n   rv=self. obj. __lt__(other. obj)\n  except TypeError:\n   rv=NotImplemented\n   \n  if rv is NotImplemented:\n   rv=(str(type(self. obj)),id(self. obj))<   (str(type(other. obj)),id(other. obj))\n  return rv\n  \ndef _safe_tuple(t):\n ''\n return _safe_key(t[0]),_safe_key(t[1])\n \nclass PrettyPrinter:\n def __init__(self,indent=1,width=80,depth=None ,stream=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  indent=int(indent)\n  width=int(width)\n  assert indent >=0,\"indent must be >= 0\"\n  assert depth is None or depth >0,\"depth must be > 0\"\n  assert width,\"width must be != 0\"\n  self. _depth=depth\n  self. _indent_per_level=indent\n  self. _width=width\n  if stream is not None :\n   self. _stream=stream\n  else :\n   self. _stream=_sys. stdout\n   \n def pprint(self,object):\n  self. _format(object,self. _stream,0,0,{},0)\n  self. _stream. write(\"\\n\")\n  \n def pformat(self,object):\n  sio=_StringIO()\n  self. _format(object,sio,0,0,{},0)\n  return sio. getvalue()\n  \n def isrecursive(self,object):\n  return self. format(object,{},0,0)[2]\n  \n def isreadable(self,object):\n  s,readable,recursive=self. format(object,{},0,0)\n  return readable and not recursive\n  \n def _format(self,object,stream,indent,allowance,context,level):\n  level=level+1\n  import sys\n  sys. stderr. write(str(object))\n  objid=_id(object)\n  if objid in context:\n   stream. write(_recursion(object))\n   self. _recursive=True\n   self. _readable=False\n   return\n  rep=self. _repr(object,context,level -1)\n  typ=_type(object)\n  sepLines=_len(rep)>(self. _width -1 -indent -allowance)\n  write=stream. write\n  \n  if self. _depth and level >self. _depth:\n   write(rep)\n   return\n   \n  if sepLines:\n   r=getattr(typ,\"__repr__\",None )\n   if issubclass(typ,dict):\n    write('{')\n    if self. _indent_per_level >1:\n     write((self. _indent_per_level -1)*' ')\n    length=_len(object)\n    if length:\n     context[objid]=1\n     indent=indent+self. _indent_per_level\n     if issubclass(typ,_OrderedDict):\n      items=list(object. items())\n     else :\n      items=sorted(object. items(),key=_safe_tuple)\n     key,ent=items[0]\n     rep=self. _repr(key,context,level)\n     write(rep)\n     write(': ')\n     self. _format(ent,stream,indent+_len(rep)+2,\n     allowance+1,context,level)\n     if length >1:\n      for key,ent in items[1:]:\n       rep=self. _repr(key,context,level)\n       write(',\\n%s%s: '%(' '*indent,rep))\n       self. _format(ent,stream,indent+_len(rep)+2,\n       allowance+1,context,level)\n     indent=indent -self. _indent_per_level\n     del context[objid]\n    write('}')\n    return\n    \n   if ((issubclass(typ,list)and r is list. __repr__)or\n   (issubclass(typ,tuple)and r is tuple. __repr__)or\n   (issubclass(typ,set)and r is set. __repr__)or\n   (issubclass(typ,frozenset)and r is frozenset. __repr__)\n   ):\n    length=_len(object)\n    if issubclass(typ,list):\n     write('[')\n     endchar=']'\n    elif issubclass(typ,tuple):\n     write('(')\n     endchar=')'\n    else :\n     if not length:\n      write(rep)\n      return\n     if typ is set:\n      write('{')\n      endchar='}'\n     else :\n      write(typ. __name__)\n      write('({')\n      endchar='})'\n      indent +=len(typ. __name__)+1\n     object=sorted(object,key=_safe_key)\n    if self. _indent_per_level >1:\n     write((self. _indent_per_level -1)*' ')\n    if length:\n     context[objid]=1\n     indent=indent+self. _indent_per_level\n     self. _format(object[0],stream,indent,allowance+1,\n     context,level)\n     if length >1:\n      for ent in object[1:]:\n       write(',\\n'+' '*indent)\n       self. _format(ent,stream,indent,\n       allowance+1,context,level)\n     indent=indent -self. _indent_per_level\n     del context[objid]\n    if issubclass(typ,tuple)and length ==1:\n     write(',')\n    write(endchar)\n    return\n    \n  write(rep)\n  \n def _repr(self,object,context,level):\n  repr,readable,recursive=self. format(object,context. copy(),\n  self. _depth,level)\n  if not readable:\n   self. _readable=False\n  if recursive:\n   self. _recursive=True\n  return repr\n  \n def format(self,object,context,maxlevels,level):\n  ''\n\n\n  \n  return _safe_repr(object,context,maxlevels,level)\n  \n  \n  \n  \ndef _safe_repr(object,context,maxlevels,level):\n typ=_type(object)\n if typ is str:\n  if'locale'not in _sys. modules:\n   return repr(object),True ,False\n  if\"'\"in object and'\"'not in object:\n   closure='\"'\n   quotes={'\"':'\\\\\"'}\n  else :\n   closure=\"'\"\n   quotes={\"'\":\"\\\\'\"}\n  qget=quotes. get\n  sio=_StringIO()\n  write=sio. write\n  for char in object:\n   if char. isalpha():\n    write(char)\n   else :\n    write(qget(char,repr(char)[1:-1]))\n  return (\"%s%s%s\"%(closure,sio. getvalue(),closure)),True ,False\n  \n r=getattr(typ,\"__repr__\",None )\n if issubclass(typ,dict)and r is dict. __repr__:\n  if not object:\n   return\"{}\",True ,False\n  objid=_id(object)\n  if maxlevels and level >=maxlevels:\n   return\"{...}\",False ,objid in context\n  if objid in context:\n   return _recursion(object),False ,True\n  context[objid]=1\n  readable=True\n  recursive=False\n  components=[]\n  append=components. append\n  level +=1\n  saferepr=_safe_repr\n  items=sorted(object. items(),key=_safe_tuple)\n  for k,v in items:\n   krepr,kreadable,krecur=saferepr(k,context,maxlevels,level)\n   vrepr,vreadable,vrecur=saferepr(v,context,maxlevels,level)\n   append(\"%s: %s\"%(krepr,vrepr))\n   readable=readable and kreadable and vreadable\n   if krecur or vrecur:\n    recursive=True\n  del context[objid]\n  return\"{%s}\"%_commajoin(components),readable,recursive\n  \n if (issubclass(typ,list)and r is list. __repr__)or (issubclass(typ,tuple)and r is tuple. __repr__):\n  if issubclass(typ,list):\n   if not object:\n    return\"[]\",True ,False\n   format=\"[%s]\"\n  elif _len(object)==1:\n   format=\"(%s,)\"\n  else :\n   if not object:\n    return\"()\",True ,False\n   format=\"(%s)\"\n  objid=_id(object)\n  if maxlevels and level >=maxlevels:\n   return format %\"...\",False ,objid in context\n  if objid in context:\n   return _recursion(object),False ,True\n  context[objid]=1\n  readable=True\n  recursive=False\n  components=[]\n  append=components. append\n  level +=1\n  for o in object:\n   orepr,oreadable,orecur=_safe_repr(o,context,maxlevels,level)\n   append(orepr)\n   if not oreadable:\n    readable=False\n   if orecur:\n    recursive=True\n  del context[objid]\n  return format %_commajoin(components),readable,recursive\n  \n rep=repr(object)\n return rep,(rep and not rep. startswith('<')),False\n \n \ndef _recursion(object):\n return (\"<Recursion on %s with id=%s>\"\n %(_type(object). __name__,_id(object)))\n \n \ndef _perfcheck(object=None ):\n import time\n if object is None :\n  object=[(\"string\",(1,2),[3,4],{5:6,7:8})]*100000\n p=PrettyPrinter()\n t1=time. time()\n _safe_repr(object,{},None ,0)\n t2=time. time()\n p. pformat(object)\n t3=time. time()\n print(\"_safe_repr:\",t2 -t1)\n print(\"pformat:\",t3 -t2)\n \nif __name__ ==\"__main__\":\n _perfcheck()\n"], "sys": [".py", "\nfrom _sys import *\n\n_getframe=Getframe\nfrom javascript import JSObject\nfrom browser import window\n\nbrython_debug_mode=__BRYTHON__. debug\n\nbase_exec_prefix=__BRYTHON__. brython_path\n\nbase_prefix=__BRYTHON__. brython_path\n\nbuiltin_module_names=__BRYTHON__. builtin_module_names\n\nbyteorder='little'\n\ndef exc_info():\n exc=__BRYTHON__. current_exception\n if exc is None :\n  return (None ,None ,None )\n return (exc. __class__,exc,exc. traceback)\n \nexec_prefix=__BRYTHON__. brython_path\n\nexecutable=__BRYTHON__. brython_path+'/brython.js'\n\ndef exit(i=None ):\n raise SystemExit('')\n \nclass flag_class:\n def __init__(self):\n  self. debug=0\n  self. inspect=0\n  self. interactive=0\n  self. optimize=0\n  self. dont_write_bytecode=0\n  self. no_user_site=0\n  self. no_site=0\n  self. ignore_environment=0\n  self. verbose=0\n  self. bytes_warning=0\n  self. quiet=0\n  self. hash_randomization=1\n  \nflags=flag_class()\n\ndef getfilesystemencoding(*args,**kw):\n ''\n\n \n return'utf-8'\n \ndef getrecursionlimit():\n return 200\n \nmaxsize=2 **63 -1\n\nmaxunicode=1114111\n\n\n\n\n\n\nplatform=\"brython\"\n\nprefix=__BRYTHON__. brython_path\n\nversion='.'. join(str(x)for x in __BRYTHON__. version_info[:3])\nversion +=\" (default, %s) \\n[Javascript 1.5] on Brython\"%__BRYTHON__. compiled_date\nhexversion=0x03000000\n\nclass __version_info(object):\n def __init__(self,version_info):\n  self. version_info=version_info\n  self. major=version_info[0]\n  self. minor=version_info[1]\n  self. micro=version_info[2]\n  self. releaselevel=version_info[3]\n  self. serial=version_info[4]\n  \n def __getitem__(self,index):\n  if isinstance(self. version_info[index],list):\n   return tuple(self. version_info[index])\n  return self. version_info[index]\n  \n def hexversion(self):\n  try :\n   return'0%d0%d0%d'%(self. major,self. minor,self. micro)\n  finally :\n   return'0%d0000'%(self. major)\n   \n def __str__(self):\n  _s=\"sys.version(major=%d, minor=%d, micro=%d, releaselevel='%s', serial=%d)\"\n  return _s %(self. major,self. minor,self. micro,\n  self. releaselevel,self. serial)\n  \n  \n def __eq__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)==other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ge__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)>=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __gt__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)>other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __le__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)<=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __lt__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)<other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ne__(self,other):\n  if isinstance(other,tuple):\n   return (self. major,self. minor,self. micro)!=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n  \n  \nversion_info=__version_info(__BRYTHON__. version_info)\n\nclass _implementation:\n def __init__(self):\n  self. name='brython'\n  self. version=__version_info(__BRYTHON__. implementation)\n  self. hexversion=self. version. hexversion()\n  self. cache_tag=None\n  \n def __repr__(self):\n  return\"namespace(name='%s' version=%s hexversion='%s')\"%(self. name,self. version,self. hexversion)\n  \n def __str__(self):\n  return\"namespace(name='%s' version=%s hexversion='%s')\"%(self. name,self. version,self. hexversion)\n  \nimplementation=_implementation()\n\nclass _hash_info:\n def __init__(self):\n  self. width=32,\n  self. modulus=2147483647\n  self. inf=314159\n  self. nan=0\n  self. imag=1000003\n  self. algorithm='siphash24'\n  self. hash_bits=64\n  self. seed_bits=128\n  cutoff=0\n  \n def __repr(self):\n \n  return\"sys.hash_info(width=32, modulus=2147483647, inf=314159, nan=0, imag=1000003, algorithm='siphash24', hash_bits=64, seed_bits=128, cutoff=0)\"\n  \nhash_info=_hash_info()\n\nwarnoptions=[]\n\ndef getfilesystemencoding():\n return'utf-8'\n \n \n__stdout__=__BRYTHON__. stdout\n__stderr__=__BRYTHON__. stderr\n__stdin__=__BRYTHON__. stdin\n\n\ndel JSObject\ndel _implementation\n"], "math": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\nvar $s=[]\nfor(var $b in _b_) $s.push('var ' + $b +'=_b_[\"'+$b+'\"]')\neval($s.join(';'))\n\n//for(var $py_builtin in _b_){eval(\"var \"+$py_builtin+\"=_b_[$py_builtin]\")}\n\nvar float_check=function(x) {\n    if (x.__class__===$B.LongInt.$dict){return parseInt(x.value)}\n    return _b_.float(x)\n}\n\nvar isWholeNumber=function(x){return (x*10) % 10 == 0}\n\nvar isOdd=function(x) {return isWholeNumber(x) && 2*Math.floor(x/2) != x}\n\nvar isLargeNumber=function(x) {return x > Math.pow(2,32)}\n\n// Big number Library from jsfromhell.com\n// This library helps with producing \"correct\" results from \n// mathematic operations\n\n//+ Jonas Raoni Soares Silva\n//@ http://jsfromhell.com/classes/bignumber [rev. #4]\n\n\nvar BigNumber = function(n, p, r){\n    var o = this, i;\n    if(n instanceof BigNumber){\n        for(i in {precision: 0, roundType: 0, _s: 0, _f: 0}) o[i] = n[i];\n        o._d = n._d.slice();\n        return;\n    }\n    o.precision = isNaN(p = Math.abs(p)) ? BigNumber.defaultPrecision : p;\n    o.roundType = isNaN(r = Math.abs(r)) ? BigNumber.defaultRoundType : r;\n    o._s = (n += \"\").charAt(0) == \"-\";\n    o._f = ((n = n.replace(/[^\\d.]/g, \"\").split(\".\", 2))[0] = n[0].replace(/^0+/, \"\") || \"0\").length;\n    for(i = (n = o._d = (n.join(\"\") || \"0\").split(\"\")).length; i; n[--i] = +n[i]);\n    o.round();\n};\nwith({$: BigNumber, o: BigNumber.prototype}){\n    $.ROUND_HALF_EVEN = ($.ROUND_HALF_DOWN = ($.ROUND_HALF_UP = ($.ROUND_FLOOR = ($.ROUND_CEIL = ($.ROUND_DOWN = ($.ROUND_UP = 0) + 1) + 1) + 1) + 1) + 1) + 1;\n    $.defaultPrecision = 40;\n    $.defaultRoundType = $.ROUND_HALF_UP;\n    o.add = function(n){\n        if(this._s != (n = new BigNumber(n))._s)\n            return n._s ^= 1, this.subtract(n);\n        var o = new BigNumber(this), a = o._d, b = n._d, la = o._f,\n        lb = n._f, n = Math.max(la, lb), i, r;\n        la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1));\n        i = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length;\n        for(r = 0; i; r = (a[--i] = a[i] + b[i] + r) / 10 >>> 0, a[i] %= 10);\n        return r && ++n && a.unshift(r), o._f = n, o.round();\n    };\n    o.subtract = function(n){\n        if(this._s != (n = new BigNumber(n))._s)\n            return n._s ^= 1, this.add(n);\n        var o = new BigNumber(this), c = o.abs().compare(n.abs()) + 1, a = c ? o : n, b = c ? n : o, la = a._f, lb = b._f, d = la, i, j;\n        a = a._d, b = b._d, la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1));\n        for(i = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length; i;){\n            if(a[--i] < b[i]){\n                for(j = i; j && !a[--j]; a[j] = 9);\n                --a[j], a[i] += 10;\n            }\n            b[i] = a[i] - b[i];\n        }\n        return c || (o._s ^= 1), o._f = d, o._d = b, o.round();\n    };\n    o.multiply = function(n){\n        var o = new BigNumber(this), r = o._d.length >= (n = new BigNumber(n))._d.length, a = (r ? o : n)._d,\n        b = (r ? n : o)._d, la = a.length, lb = b.length, x = new BigNumber, i, j, s;\n        for(i = lb; i; r && s.unshift(r), x.set(x.add(new BigNumber(s.join(\"\")))))\n            for(s = (new Array(lb - --i)).join(\"0\").split(\"\"), r = 0, j = la; j; r += a[--j] * b[i], s.unshift(r % 10), r = (r / 10) >>> 0);\n        return o._s = o._s != n._s, o._f = ((r = la + lb - o._f - n._f) >= (j = (o._d = x._d).length) ? this._zeroes(o._d, r - j + 1, 1).length : j) - r, o.round();\n    };\n    o.divide = function(n){\n        if((n = new BigNumber(n)) == \"0\")\n            throw new Error(\"Division by 0\");\n        else if(this == \"0\")\n            return new BigNumber;\n        var o = new BigNumber(this), a = o._d, b = n._d, la = a.length - o._f,\n        lb = b.length - n._f, r = new BigNumber, i = 0, j, s, l, f = 1, c = 0, e = 0;\n        r._s = o._s != n._s, r.precision = Math.max(o.precision, n.precision),\n        r._f = +r._d.pop(), la != lb && o._zeroes(la > lb ? b : a, Math.abs(la - lb));\n        n._f = b.length, b = n, b._s = false, b = b.round();\n        for(n = new BigNumber; a[0] == \"0\"; a.shift());\n        out:\n        do{\n            for(l = c = 0, n == \"0\" && (n._d = [], n._f = 0); i < a.length && n.compare(b) == -1; ++i){\n                (l = i + 1 == a.length, (!f && ++c > 1 || (e = l && n == \"0\" && a[i] == \"0\")))\n                && (r._f == r._d.length && ++r._f, r._d.push(0));\n                (a[i] == \"0\" && n == \"0\") || (n._d.push(a[i]), ++n._f);\n                if(e)\n                    break out;\n                if((l && n.compare(b) == -1 && (r._f == r._d.length && ++r._f, 1)) || (l = 0))\n                    while(r._d.push(0), n._d.push(0), ++n._f, n.compare(b) == -1);\n            }\n            if(f = 0, n.compare(b) == -1 && !(l = 0))\n                while(l ? r._d.push(0) : l = 1, n._d.push(0), ++n._f, n.compare(b) == -1);\n            for(s = new BigNumber, j = 0; n.compare(y = s.add(b)) + 1 && ++j; s.set(y));\n            n.set(n.subtract(s)), !l && r._f == r._d.length && ++r._f, r._d.push(j);\n        }\n        while((i < a.length || n != \"0\") && (r._d.length - r._f) <= r.precision);\n        return r.round();\n    };\n    o.mod = function(n){\n        return this.subtract(this.divide(n).intPart().multiply(n));\n    };\n    o.pow = function(n){\n        var o = new BigNumber(this), i;\n        if((n = (new BigNumber(n)).intPart()) == 0) return o.set(1);\n        for(i = Math.abs(n); --i; o.set(o.multiply(this)));\n        return n < 0 ? o.set((new BigNumber(1)).divide(o)) : o;\n    };\n    o.set = function(n){\n        return this.constructor(n), this;\n    };\n    o.compare = function(n){\n        var a = this, la = this._f, b = new BigNumber(n), lb = b._f, r = [-1, 1], i, l;\n        if(a._s != b._s)\n            return a._s ? -1 : 1;\n        if(la != lb)\n            return r[(la > lb) ^ a._s];\n        for(la = (a = a._d).length, lb = (b = b._d).length, i = -1, l = Math.min(la, lb); ++i < l;)\n            if(a[i] != b[i])\n                return r[(a[i] > b[i]) ^ a._s];\n        return la != lb ? r[(la > lb) ^ a._s] : 0;\n    };\n    o.negate = function(){\n        var n = new BigNumber(this); return n._s ^= 1, n;\n    };\n    o.abs = function(){\n        var n = new BigNumber(this); return n._s = 0, n;\n    };\n    o.intPart = function(){\n        return new BigNumber((this._s ? \"-\" : \"\") + (this._d.slice(0, this._f).join(\"\") || \"0\"));\n    };\n    o.valueOf = o.toString = function(){\n        var o = this;\n        return (o._s ? \"-\" : \"\") + (o._d.slice(0, o._f).join(\"\") || \"0\") + (o._f != o._d.length ? \".\" + o._d.slice(o._f).join(\"\") : \"\");\n    };\n    o._zeroes = function(n, l, t){\n        var s = [\"push\", \"unshift\"][t || 0];\n        for(++l; --l;  n[s](0));\n        return n;\n    };\n    o.round = function(){\n        if(\"_rounding\" in this) return this;\n        var $ = BigNumber, r = this.roundType, b = this._d, d, p, n, x;\n        for(this._rounding = true; this._f > 1 && !b[0]; --this._f, b.shift());\n        for(d = this._f, p = this.precision + d, n = b[p]; b.length > d && !b[b.length -1]; b.pop());\n        x = (this._s ? \"-\" : \"\") + (p - d ? \"0.\" + this._zeroes([], p - d - 1).join(\"\") : \"\") + 1;\n        if(b.length > p){\n            n && (r == $.DOWN ? false : r == $.UP ? true : r == $.CEIL ? !this._s\n            : r == $.FLOOR ? this._s : r == $.HALF_UP ? n >= 5 : r == $.HALF_DOWN ? n > 5\n            : r == $.HALF_EVEN ? n >= 5 && b[p - 1] & 1 : false) && this.add(x);\n            b.splice(p, b.length - p);\n        }\n        return delete this._rounding, this;\n    };\n}\n\nvar isNegZero=function(x) {return x===0 && Math.atan2(x,x) < 0}\n\nvar _mod = {\n    __getattr__ : function(attr){\n        var res = this[attr]\n        if(res===undefined){$raise('AttributeError','module math has no attribute '+attr)}\n        return res\n    },\n    acos: function(x) {return float(Math.acos(float_check(x)))},\n    acosh: function(x) { \n        if (_b_.$isinf(x)) return float('inf');\n        var y = float_check(x);\n        return float(Math.log(y + Math.sqrt(y*y-1)));\n    },\n    asin: function(x) {return float(Math.asin(float_check(x)))},\n    asinh: function(x) {\n        if (_b_.$isninf(x)) return float('-inf');\n        if (_b_.$isinf(x)) return float('inf');\n        var y = float_check(x);\n        return float(Math.log(y + Math.sqrt(y*y+1)))\n    },\n    atan: function(x) {\n        if (_b_.$isninf(x)) return float(-Math.PI/2);\n        if (_b_.$isinf(x)) return float(Math.PI/2);\n        return float(Math.atan(float_check(x)))},\n    atan2: function(y,x) {\n        return float(Math.atan2(float_check(y),float_check(x)))\n    },\n    atanh: function(x) { \n       var y=float_check(x);\n       if (y==0) return 0;\n       return float(0.5 * Math.log((1/y+1)/(1/y-1)));\n    },\n    ceil: function(x) {\n       try{return getattr(x,'__ceil__')()}catch(err){}\n\n       if (_b_.$isninf(x)) return float('-inf')\n       if (_b_.$isinf(x)) return float('inf')\n       if (isNaN(x)) return float('nan')\n\n       var y=float_check(x);\n       if (!isNaN(parseFloat(y)) && isFinite(y)) return int(Math.ceil(y));\n       \n       $raise('ValueError', 'object is not a number and does not contain __ceil__')\n    },\n    copysign: function(x,y) {\n        var x1=Math.abs(float_check(x))\n        var y1=float_check(y)\n        var sign=y1?y1<0?-1:1:1\n        if (isNegZero(y1)) sign=-1   // probably need to work on adding a check for -0\n        return float(x1 * sign)\n    },\n    cos : function(x){return float(Math.cos(float_check(x)))},\n    cosh: function(x){\n        if (_b_.$isinf(x)) return float('inf')\n        var y = float_check(x)\n        if (Math.cosh !== undefined) return float(Math.cosh(y))\n        return float((Math.pow(Math.E,y) + Math.pow(Math.E,-y))/2)\n    },\n    degrees: function(x){return float(float_check(x) * 180/Math.PI)},\n    e: float(Math.E),\n    erf: function(x) {\n        // inspired from \n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y =float_check(x);\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y*y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 + \n                     t * ( 0.09678418 + \n                     t * (-0.18628806 + \n                     t * ( 0.27886807 + \n                     t * (-1.13520398 + \n                     t * ( 1.48851587 + \n                     t * (-0.82215223 + \n                     t * 0.17087277)))))))))\n        if (y >= 0.0) return ans\n\n        return -ans\n    },\n\n    erfc: function(x) {\n        // inspired from \n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x);\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y*y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 + \n                     t * ( 0.09678418 + \n                     t * (-0.18628806 + \n                     t * ( 0.27886807 + \n                     t * (-1.13520398 + \n                     t * ( 1.48851587 + \n                     t * (-0.82215223 + \n                     t * 0.17087277)))))))))\n        if (y >= 0.0) return 1-ans\n        return 1+ans\n    },\n    exp: function(x){\n         if (_b_.$isninf(x)) {return float(0)}\n         if (_b_.$isinf(x)) {return float('inf')}\n         var _r=Math.exp(float_check(x))\n         if (_b_.$isinf(_r)) {throw OverflowError(\"math range error\")}\n         return float(_r)\n    },\n    expm1: function(x){return float(Math.exp(float_check(x))-1)},\n    //fabs: function(x){ return x>0?float(x):float(-x)},\n    fabs: function(x){return _b_.$fabs(x)}, //located in py_float.js\n    factorial: function(x) {\n         //using code from http://stackoverflow.com/questions/3959211/fast-factorial-function-in-javascript\n         var y=float_check(x);\n         var r=1\n         for (var i=2; i<=y; i++){r*=i}\n         return r\n    },\n    floor:function(x){return Math.floor(float_check(x))},\n    fmod:function(x,y){return float(float_check(x)%float_check(y))},\n    frexp: function(x){var _l=_b_.$frexp(x);return _b_.tuple([float(_l[0]), _l[1]])}, // located in py_float.js\n    fsum:function(x){\n        /* Translation into Javascript of the function msum in an Active\n           State Cookbook recipe : https://code.activestate.com/recipes/393090/\n           by Raymond Hettinger\n        */\n        var partials = [],\n            res = new Number(), \n            _it = _b_.iter(x)\n        while(true){\n            try{\n                var x = _b_.next(_it),\n                    i = 0\n                for(var j=0, len=partials.length;j<len;j++){\n                    var y = partials[j]\n                    if(Math.abs(x) < Math.abs(y)){\n                        var z = x\n                        x = y\n                        y = z\n                    }\n                    var hi = x + y,\n                        lo = y - (hi - x)\n                    if(lo){\n                        partials[i] = lo\n                        i++\n                    }\n                    x = hi\n                }\n                partials = partials.slice(0, i).concat([x])\n            }catch(err){\n                if(_b_.isinstance(err, _b_.StopIteration)){break}\n                throw err\n            }\n        }\n        var res = new Number(0)\n        for(var i=0; i<partials.length;i++){res += new Number(partials[i])}\n        return new Number(res)\n    },\n    gamma: function(x){\n         //using code from http://stackoverflow.com/questions/3959211/fast-factorial-function-in-javascript\n         // Lanczos Approximation of the Gamma Function\n         // As described in Numerical Recipes in C (2nd ed. Cambridge University Press, 1992)\n         var y=float_check(x);\n         var z = y + 1;\n         var d1 = Math.sqrt(2 * Math.PI) / z;\n\n         var d2 = 1.000000000190015;\n         d2 +=  76.18009172947146 / (z+1);\n         d2 += -86.50532032941677 / (z+2);\n         d2 +=  24.01409824083091 / (z+3); \n         d2 += -1.231739572450155 / (z+4); \n         d2 +=  1.208650973866179E-3 / (z+5);\n         d2 += -5.395239384953E-6 / (z+6);\n\n         return d1 * d2 * Math.pow(z+5.5,z+0.5) * Math.exp(-(z+5.5));\n    },\n    hypot: function(x,y){\n       if (_b_.$isinf(x) || _b_.$isinf(y)) return float('inf')\n       var x1=float_check(x);\n       var y1=float_check(y);\n       return float(Math.sqrt(x1*x1 + y1*y1))},\n    inf: float('inf'),\n    isclose:function(){\n        var $ns = $B.args(\"isclose\",\n                          4,\n                          {a:null,b:null,rel_tol:null,abs_tol:null},\n                          ['a', 'b', 'rel_tol', 'abs_tol'],\n                          arguments,\n                          {rel_tol:1e-09, abs_tol:0.0}, \n                          null, \n                          null)\n        var a = $ns['a'];\n        var b = $ns['b'];\n        var rel_tol = $ns['rel_tol'];\n        var abs_tol = $ns['abs_tol'];\n        if (rel_tol < 0.0 || abs_tol < 0.0) throw ValueError('tolerances must be non-negative')\n        if (a == b){return True}\n        if (_b_.$isinf(a) || _b_.$isinf(b)){return false}\n        var diff = _b_.$fabs(b - a);\n        var result = ((diff <= _b_.$fabs(rel_tol * b)) || (diff <= _b_.$fabs(rel_tol * a))) || (diff <= _b_.$fabs(abs_tol));\n        return result},\n    isfinite:function(x) {return isFinite(float_check(x))},\n    isinf:function(x) {return _b_.$isinf(float_check(x))},\n    isnan:function(x) {return isNaN(float_check(x))},\n    ldexp:function(x,i) {return _b_.$ldexp(x,i)},   //located in py_float.js\n    lgamma:function(x) {\n         // see gamma function for sources\n         var y=float_check(x);\n         var z = y + 1;\n         var d1 = Math.sqrt(2 * Math.PI) / z;\n\n         var d2 = 1.000000000190015;\n         d2 +=  76.18009172947146 / (z+1);\n         d2 += -86.50532032941677 / (z+2);\n         d2 +=  24.01409824083091 / (z+3); \n         d2 += -1.231739572450155 / (z+4); \n         d2 +=  1.208650973866179E-3 / (z+5);\n         d2 += -5.395239384953E-6 / (z+6);\n\n         return float(Math.log(Math.abs(d1 * d2 * Math.pow(z+5.5,z+0.5) * Math.exp(-(z+5.5)))));\n    },\n    log: function(x, base) {\n         var x1=float_check(x);\n         if (base === undefined) return float(Math.log(x1));\n         return float(Math.log(x1)/Math.log(float_check(base)));\n    },\n    log1p: function(x) {return float(Math.log(1.0 + float_check(x)))},\n    log2: function(x) {\n        if (isNaN(x)) return float('nan')\n        if (_b_.$isninf(x)) throw ValueError('')\n        var x1=float_check(x)\n        if (x1 < 0.0) throw ValueError('')\n        //if (isLargeNumber(x1)) x1=new BigNumber(x1)         \n        return float(Math.log(x1)/Math.LN2)\n    },\n    log10: function(x) {return float(Math.log(float_check(x))/Math.LN10)},\n    modf:function(x) {\n       if (_b_.$isninf(x)) return _b_.tuple([0.0, float('-inf')])\n       if (_b_.$isinf(x)) return _b_.tuple([0.0, float('inf')])\n       if (isNaN(x)) return _b_.tuple([float('nan'), float('nan')])\n\n       var x1=float_check(x);\n       if (x1 > 0) {\n          var i=float(x1-Math.floor(x1))\n          return _b_.tuple([i, float(x1-i)])\n       }\n\n       var x2=Math.ceil(x1)\n       var i=float(x1-x2)\n       return _b_.tuple([i, float(x2)])\n    },\n    nan: float('nan'),\n    pi : float(Math.PI),\n    pow: function(x,y) {\n        var x1=float_check(x)\n        var y1=float_check(y)\n        if (y1 == 0) return float(1)        \n        if (x1 == 0 && y1 < 0) throw _b_.ValueError('')\n\n        if(isNaN(y1)) {if(x1==1) return float(1) \n                       return float('nan')\n        }\n        if (x1 == 0) return float(0)\n\n        if(_b_.$isninf(y)) {if(x1==1||x1==-1) {return float(1)}\n                       if(x1 < 1 && x1 > -1) return float('inf') \n                       return float(0)\n        }\n        if(_b_.$isinf(y)) {if(x1==1||x1==-1) {return float(1)} \n                      if(x1 < 1 && x1 > -1) return float(0) \n                      return float('inf')}\n\n        if(isNaN(x1)) return float('nan')\n        if(_b_.$isninf(x)) {\n            if (y1 > 0 && isOdd(y1)) return float('-inf')\n            if (y1 > 0) return float('inf')  // this is even or a float\n            if (y1 < 0) return float(0)\n            return float(1)\n        }\n\n        if(_b_.$isinf(x)) { \n            if (y1 > 0) return float('inf')\n            if (y1 < 0) return float(0)\n            return float(1)\n        }\n\n        var r\n        if (isLargeNumber(x1) || isLargeNumber(y1)) {\n           var x=new BigNumber(x1)\n           var y=new BigNumber(y1)\n           r=x.pow(y)\n        } else {\n           r=Math.pow(x1,y1)\n        }\n\n        if (isNaN(r)) return float('nan')\n        if (_b_.$isninf(r)) return float('-inf')\n        if (_b_.$isinf(r)) return float('inf')\n\n        return r\n    },\n    radians: function(x){return float(float_check(x) * Math.PI/180)},\n    sin : function(x){return float(Math.sin(float_check(x)))},\n    sinh: function(x) { \n        //if (_b_.$isinf(x)) return float('inf');\n        var y = float_check(x)\n        if (Math.sinh !== undefined) { return float(Math.sinh(y))}\n        return float((Math.pow(Math.E,y) - Math.pow(Math.E,-y))/2)\n    },\n    sqrt : function(x){\n      var y = float_check(x)\n      if (y < 0) { throw ValueError(\"math range error\")}\n      if (_b_.$isinf(y)) return float('inf')\n      var _r=Math.sqrt(y)\n      if (_b_.$isinf(_r)) {throw OverflowError(\"math range error\")}\n      return float(_r)\n    },\n    tan: function(x) {\n        var y = float_check(x)\n        return float(Math.tan(y))\n    },\n    tanh: function(x) {\n        var y = float_check(x)\n        if (Math.tanh !== undefined) return float(Math.tanh(y))\n        return float((Math.pow(Math.E,y) - Math.pow(Math.E,-y))/\n                     (Math.pow(Math.E,y) + Math.pow(Math.E,-y)))       \n    },\n    trunc: function(x) {\n       try{return getattr(x,'__trunc__')()}catch(err){}\n       var x1=float_check(x);\n       if (!isNaN(parseFloat(x1)) && isFinite(x1)) {\n          if (Math.trunc !== undefined) { return int(Math.trunc(x1))}\n          if (x1 > 0) {return int(Math.floor(x1))}\n          return int(Math.ceil(x1))  // x1 < 0\n       }\n       $raise('ValueError', 'object is not a number and does not contain __trunc__')\n    }\n}\n\nfor(var $attr in _mod){\n    if(typeof _mod[$attr]==='function'){\n        _mod[$attr].__repr__=(function(func){\n            return function(){return '<built-in function '+func+'>'}})($attr)\n        _mod[$attr].__str__=(function(func){\n            return function(){return '<built-in function '+func+'>'}})($attr)\n    }\n}\n\nreturn _mod\n\n})(__BRYTHON__)\n"], "random": [".js", "// Javascript implementation of the random module\n// Based on Ian Bicking's implementation of the Mersenne twister\n\nvar $module = (function($B){\n\n_b_ = $B.builtins\n\nvar VERSION = 3\n\n// Code copied from https://github.com/ianb/whrandom/blob/master/mersenne.js\n// by Ian Bicking\n\n// this program is a JavaScript version of Mersenne Twister,\n// a straight conversion from the original program, mt19937ar.c,\n// translated by y. okada on july 17, 2006.\n// and modified a little at july 20, 2006, but there are not any substantial differences.\n// modularized by Ian Bicking, March 25, 2013 (found original version at http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/JAVASCRIPT/java-script.html)\n// in this program, procedure descriptions and comments of original source code were not removed.\n// lines commented with //c// were originally descriptions of c procedure. and a few following lines are appropriate JavaScript descriptions.\n// lines commented with /* and */ are original comments.\n// lines commented with // are additional comments in this JavaScript version.\n/*\n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n\n   Before using, initialize the state by using init_genrand(seed)\n   or init_by_array(init_key, key_length).\n\n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n     3. The names of its contributors may not be used to endorse or promote\n        products derived from this software without specific prior written\n        permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nfunction RandomStream(seed) {\n\n  /*jshint bitwise:false */\n  /* Period parameters */\n  //c//#define N 624\n  //c//#define M 397\n  //c//#define MATRIX_A 0x9908b0dfUL   /* constant vector a */\n  //c//#define UPPER_MASK 0x80000000UL /* most significant w-r bits */\n  //c//#define LOWER_MASK 0x7fffffffUL /* least significant r bits */\n  var N = 624;\n  var M = 397;\n  var MATRIX_A = 0x9908b0df;   /* constant vector a */\n  var UPPER_MASK = 0x80000000; /* most significant w-r bits */\n  var LOWER_MASK = 0x7fffffff; /* least significant r bits */\n  //c//static unsigned long mt[N]; /* the array for the state vector  */\n  //c//static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */\n  var mt = new Array(N);   /* the array for the state vector  */\n  var mti = N+1;           /* mti==N+1 means mt[N] is not initialized */\n\n  function unsigned32 (n1) // returns a 32-bits unsiged integer from an operand to which applied a bit operator.\n  {\n    return n1 < 0 ? (n1 ^ UPPER_MASK) + UPPER_MASK : n1;\n  }\n\n  function subtraction32 (n1, n2) // emulates lowerflow of a c 32-bits unsiged integer variable, instead of the operator -. these both arguments must be non-negative integers expressible using unsigned 32 bits.\n  {\n    return n1 < n2 ? unsigned32((0x100000000 - (n2 - n1)) & 0xffffffff) : n1 - n2;\n  }\n\n  function addition32 (n1, n2) // emulates overflow of a c 32-bits unsiged integer variable, instead of the operator +. these both arguments must be non-negative integers expressible using unsigned 32 bits.\n  {\n    return unsigned32((n1 + n2) & 0xffffffff);\n  }\n\n  function multiplication32 (n1, n2) // emulates overflow of a c 32-bits unsiged integer variable, instead of the operator *. these both arguments must be non-negative integers expressible using unsigned 32 bits.\n  {\n    var sum = 0;\n    for (var i = 0; i < 32; ++i){\n      if ((n1 >>> i) & 0x1){\n        sum = addition32(sum, unsigned32(n2 << i));\n      }\n    }\n    return sum;\n  }\n\n  /* initializes mt[N] with a seed */\n  //c//void init_genrand(unsigned long s)\n  function init_genrand(s) {\n    //c//mt[0]= s & 0xffffffff;\n    mt[0]= unsigned32(s & 0xffffffff);\n    for (mti=1; mti<N; mti++) {\n      mt[mti] =\n      //c//(1812433253 * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);\n      addition32(multiplication32(1812433253, unsigned32(mt[mti-1] ^ (mt[mti-1] >>> 30))), mti);\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      //c//mt[mti] &= 0xffffffff;\n      mt[mti] = unsigned32(mt[mti] & 0xffffffff);\n      /* for >32 bit machines */\n    }\n  }\n\n  /* initialize by an array with array-length */\n  /* init_key is the array for initializing keys */\n  /* key_length is its length */\n  /* slight change for C++, 2004/2/26 */\n  //c//void init_by_array(unsigned long init_key[], int key_length)\n  function init_by_array(init_key, key_length) {\n    //c//int i, j, k;\n    var i, j, k;\n    init_genrand(19650218);\n    i=1; j=0;\n    k = (N>key_length ? N : key_length);\n    for (; k; k--) {\n      //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525))\n      //c// + init_key[j] + j; /* non linear */\n      mt[i] = addition32(addition32(unsigned32(mt[i] ^ multiplication32(unsigned32(mt[i-1] ^ (mt[i-1] >>> 30)), 1664525)), init_key[j]), j);\n      mt[i] =\n      //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n      unsigned32(mt[i] & 0xffffffff);\n      i++; j++;\n      if (i>=N) { mt[0] = mt[N-1]; i=1; }\n      if (j>=key_length) {\n        j=0;\n      }\n    }\n    for (k=N-1; k; k--) {\n      //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941))\n      //c//- i; /* non linear */\n      mt[i] = subtraction32(unsigned32((mt[i]) ^ multiplication32(unsigned32(mt[i-1] ^ (mt[i-1] >>> 30)), 1566083941)), i);\n      //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n      mt[i] = unsigned32(mt[i] & 0xffffffff);\n      i++;\n      if (i>=N) { mt[0] = mt[N-1]; i=1; }\n    }\n    mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n  }\n\n  /* generates a random number on [0,0xffffffff]-interval */\n  //c//unsigned long genrand_int32(void)\n  function genrand_int32() {\n    //c//unsigned long y;\n    //c//static unsigned long mag01[2]={0x0UL, MATRIX_A};\n    var y;\n    var mag01 = [0x0, MATRIX_A];\n    /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n    if (mti >= N) { /* generate N words at one time */\n      //c//int kk;\n      var kk;\n\n      if (mti == N+1) {   /* if init_genrand() has not been called, */\n        init_genrand(Date.now()); /* a default initial seed is used */\n      }\n\n      for (kk=0;kk<N-M;kk++) {\n        //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n        //c//mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n        y = unsigned32((mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK));\n        mt[kk] = unsigned32(mt[kk+M] ^ (y >>> 1) ^ mag01[y & 0x1]);\n      }\n      for (;kk<N-1;kk++) {\n        //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n        //c//mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n        y = unsigned32((mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK));\n        mt[kk] = unsigned32(mt[kk+(M-N)] ^ (y >>> 1) ^ mag01[y & 0x1]);\n      }\n      //c//y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n      //c//mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n      y = unsigned32((mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK));\n      mt[N-1] = unsigned32(mt[M-1] ^ (y >>> 1) ^ mag01[y & 0x1]);\n      mti = 0;\n    }\n\n    y = mt[mti++];\n\n    /* Tempering */\n    //c//y ^= (y >> 11);\n    //c//y ^= (y << 7) & 0x9d2c5680;\n    //c//y ^= (y << 15) & 0xefc60000;\n    //c//y ^= (y >> 18);\n    y = unsigned32(y ^ (y >>> 11));\n    y = unsigned32(y ^ ((y << 7) & 0x9d2c5680));\n    y = unsigned32(y ^ ((y << 15) & 0xefc60000));\n    y = unsigned32(y ^ (y >>> 18));\n\n    return y;\n  }\n\n  /* generates a random number on [0,0x7fffffff]-interval */\n  //c//long genrand_int31(void)\n  function genrand_int31() {\n    //c//return (genrand_int32()>>1);\n    return (genrand_int32()>>>1);\n  }\n\n  /* generates a random number on [0,1]-real-interval */\n  //c//double genrand_real1(void)\n  function genrand_real1() {\n    return genrand_int32()*(1.0/4294967295.0);\n    /* divided by 2^32-1 */\n  }\n\n  /* generates a random number on [0,1)-real-interval */\n  //c//double genrand_real2(void)\n  function genrand_real2() {\n    return genrand_int32()*(1.0/4294967296.0);\n    /* divided by 2^32 */\n  }\n\n  /* generates a random number on (0,1)-real-interval */\n  //c//double genrand_real3(void)\n  function genrand_real3() {\n    return ((genrand_int32()) + 0.5)*(1.0/4294967296.0);\n    /* divided by 2^32 */\n  }\n\n  /* generates a random number on [0,1) with 53-bit resolution*/\n  //c//double genrand_res53(void)\n  function genrand_res53() {\n    //c//unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6;\n    var a=genrand_int32()>>>5, b=genrand_int32()>>>6;\n    return (a*67108864.0+b)*(1.0/9007199254740992.0);\n  }\n  /* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n  var random = genrand_res53;\n\n  random.seed = function (seed) {\n    if (! seed) {\n      seed = Date.now();\n    }\n    if (typeof seed != \"number\") {\n      seed = parseInt(seed, 10);\n    }\n    if ((seed !== 0 && ! seed) || isNaN(seed)) {\n      throw \"Bad seed\";\n    }\n    init_genrand(seed);\n  };\n\n  random.seed(seed);\n\n  random.int31 = genrand_int31;\n  random.real1 = genrand_real1;\n  random.real2 = genrand_real2;\n  random.real3 = genrand_real3;\n  random.res53 = genrand_res53;\n  \n  // Added for compatibility with Python\n  random.getstate = function(){return [VERSION, mt, mti]}\n  \n  random.setstate = function(state){\n    mt = state[1]\n    mti = state[2]\n  }\n\n  return random;\n\n}\n\nfunction _Random(){\n    var _random = RandomStream()\n    \n    _b_ = $B.builtins\n    \n    var NV_MAGICCONST = 4 * Math.exp(-0.5)/Math.sqrt(2),\n        gauss_next = null\n    \n    function _randbelow(x){\n        return Math.floor(x*_random())\n    }\n    \n    function _urandom(n){\n        /*\n        urandom(n) -> str\n        Return n random bytes suitable for cryptographic use.\n        */\n        \n        var randbytes= []\n        for(i=0;i<n;i++){randbytes.push(parseInt(_random()*256))}\n        return _b_.bytes(randbytes)\n    }\n    \n    var res = {\n        // magic constants\n        NV_MAGICCONST: 1.71552776992141,\n        TWOPI: 6.28318530718,\n        LOG4: 1.38629436111989,\n        SG_MAGICCONST: 2.50407739677627,\n\n        choice: function(seq){\n            var $ = $B.args('choice', 1,\n                {seq:null},['seq'],arguments, {}, null, null),\n                seq = $.seq\n            var len, rank\n            if(Array.isArray(seq)){len = seq.length}\n            else{len = _b_.getattr(seq,'__len__')()}\n            if(len==0){throw _b_.IndexError(\"Cannot choose from an empty sequence\")}\n            rank = parseInt(_random()*len)\n            if(Array.isArray(seq)){return seq[rank]}\n            else{return _b_.getattr(seq,'__getitem__')(rank)}\n        },\n    \n        expovariate: function(lambd){\n            /*\n            Exponential distribution.\n    \n            lambd is 1.0 divided by the desired mean.  It should be\n            nonzero.  (The parameter would be called \"lambda\", but that is\n            a reserved word in Python.)  Returned values range from 0 to\n            positive infinity if lambd is positive, and from negative\n            infinity to 0 if lambd is negative.\n    \n            */\n            // lambd: rate lambd = 1/mean\n            // ('lambda' is a Python reserved word)\n    \n            // we use 1-random() instead of random() to preclude the\n            // possibility of taking the log of zero.\n            return -Math.log(1.0 - _random())/lambd\n        },\n    \n        gammavariate: function(alpha, beta){\n            /* Gamma distribution.  Not the gamma function!\n    \n            Conditions on the parameters are alpha > 0 and beta > 0.\n    \n            The probability distribution function is:\n    \n                        x ** (alpha - 1) * math.exp(-x / beta)\n              pdf(x) =  --------------------------------------\n                          math.gamma(alpha) * beta ** alpha\n    \n            */\n    \n            // alpha > 0, beta > 0, mean is alpha*beta, variance is alpha*beta**2\n    \n            // Warning: a few older sources define the gamma distribution in terms\n            // of alpha > -1.0\n            \n            var $ = $B.args('gammavariate', 2,\n                    {alpha:null, beta:null}, ['alpha', 'beta'],\n                    arguments, {}, null, null),\n                alpha = $.alpha,\n                beta = $.beta,\n                LOG4 = Math.log(4),\n                SG_MAGICCONST = 1.0 + Math.log(4.5)\n                \n            if(alpha <= 0.0 || beta <= 0.0){\n                throw _b_.ValueError('gammavariate: alpha and beta must be > 0.0')\n            }\n    \n            if(alpha > 1.0){\n    \n                // Uses R.C.H. Cheng, \"The generation of Gamma\n                // variables with non-integral shape parameters\",\n                // Applied Statistics, (1977), 26, No. 1, p71-74\n    \n                var ainv = Math.sqrt(2.0 * alpha - 1.0),\n                    bbb = alpha - LOG4,\n                    ccc = alpha + ainv\n    \n                while(true){\n                    var u1 = _random()\n                    if(!((1e-7 < u1) && (u1 < .9999999))){\n                        continue\n                    }\n                    var u2 = 1.0 - _random(),\n                        v = Math.log(u1/(1.0-u1))/ainv,\n                        x = alpha*Math.exp(v),\n                        z = u1*u1*u2,\n                        r = bbb+ccc*v-x\n                    if((r + SG_MAGICCONST - 4.5*z >= 0.0) || r >= Math.log(z)){\n                        return x * beta\n                    }\n                }\n            }else if(alpha == 1.0){\n                // expovariate(1)\n                var u = _random()\n                while(u <= 1e-7){u = _random()}\n                return -Math.log(u) * beta\n            }else{\n                // alpha is between 0 and 1 (exclusive)\n    \n                // Uses ALGORITHM GS of Statistical Computing - Kennedy & Gentle\n    \n                while(true){\n                    var u = _random(),\n                        b = (Math.E + alpha)/Math.E,\n                        p = b*u,\n                        x\n                    if(p <= 1.0){x = Math.pow(p, (1.0/alpha))}\n                    else{x = -Math.log((b-p)/alpha)}\n                    var u1 = _random()\n                    if(p > 1.0){\n                        if(u1 <= Math.pow(x, alpha - 1.0)){\n                            break\n                        }\n                    }else if(u1 <= Math.exp(-x)){\n                        break\n                    }\n                }\n                return x * beta\n            }\n        },\n        \n        gauss:function(){\n    \n            /* Gaussian distribution.\n    \n            mu is the mean, and sigma is the standard deviation.  This is\n            slightly faster than the normalvariate() function.\n    \n            Not thread-safe without a lock around calls.\n    \n            # When x and y are two variables from [0, 1), uniformly\n            # distributed, then\n            #\n            #    cos(2*pi*x)*sqrt(-2*log(1-y))\n            #    sin(2*pi*x)*sqrt(-2*log(1-y))\n            #\n            # are two *independent* variables with normal distribution\n            # (mu = 0, sigma = 1).\n            # (Lambert Meertens)\n            # (corrected version; bug discovered by Mike Miller, fixed by LM)\n    \n            # Multithreading note: When two threads call this function\n            # simultaneously, it is possible that they will receive the\n            # same return value.  The window is very small though.  To\n            # avoid this, you have to use a lock around all calls.  (I\n            # didn't want to slow this down in the serial case by using a\n            # lock here.)\n            */\n    \n            var $ = $B.args('gauss', 2, {mu:null, sigma:null},\n                    ['mu', 'sigma'], arguments, {}, null, null),\n                mu = $.mu,\n                sigma = $.sigma\n    \n            var z = gauss_next\n            gauss_next = null\n            if(z===null){\n                var x2pi = _random() * Math.PI * 2,\n                    g2rad = Math.sqrt(-2.0 * Math.log(1.0 - _random())),\n                    z = Math.cos(x2pi) * g2rad\n                gauss_next = Math.sin(x2pi) * g2rad\n            }\n            return mu + z*sigma\n        },\n             \n        getrandbits: function(k){\n            var $ = $B.args('getrandbits', 1,\n                {k:null},['k'],arguments, {}, null, null),\n                k = $B.$GetInt($.k)\n            // getrandbits(k) -> x.  Generates a long int with k random bits.\n            if(k <= 0){\n                throw _b_.ValueError('number of bits must be greater than zero')\n            }\n            if(k != _b_.int(k)){\n                throw _b_.TypeError('number of bits should be an integer')\n            }\n            var numbytes = (k + 7), // bits / 8 and rounded up\n                x = _b_.int.$dict.from_bytes(_urandom(numbytes), 'big')\n            return _b_.getattr(x, '__rshift__')(\n                _b_.getattr(numbytes*8,'__sub__')(k))\n        },\n        \n        getstate: function(){\n            // Return internal state; can be passed to setstate() later.\n            var $ = $B.args('getstate', 0, {}, [], arguments, {}, null, null)\n            return _random.getstate()\n        },\n        \n        normalvariate: function(mu, sigma){\n            /*\n            Normal distribution.\n    \n            mu is the mean, and sigma is the standard deviation.\n    \n            */\n    \n            // mu = mean, sigma = standard deviation\n    \n            // Uses Kinderman and Monahan method. Reference: Kinderman,\n            // A.J. and Monahan, J.F., \"Computer generation of random\n            // variables using the ratio of uniform deviates\", ACM Trans\n            // Math Software, 3, (1977), pp257-260.\n            \n            var $=$B.args('normalvariate', 2,\n                {mu:null, sigma:null}, ['mu', 'sigma'],\n                arguments, {}, null, null),\n                mu = $.mu,\n                sigma = $.sigma\n    \n            while(true){\n                var u1 = _random(),\n                    u2 = 1.0 - _random(),\n                    z = NV_MAGICCONST*(u1-0.5)/u2,\n                    zz = z*z/4.0\n                if(zz <= -Math.log(u2)){break}\n            }\n            return mu + z*sigma\n        },\n        \n        paretovariate: function(){\n            /* Pareto distribution.  alpha is the shape parameter.*/\n            // Jain, pg. 495\n            \n            var $ = $B.args('paretovariate', 1, {alpha:null}, ['alpha'],\n                        arguments, {}, null, null)\n    \n            var u = 1 - _random()\n            return 1 / Math.pow(u,1/$.alpha)\n        },\n            \n        randint: function(a, b){\n            var $ = $B.args('randint', 2,\n                {a:null, b:null},\n                ['a', 'b'],\n                arguments, {}, null, null)\n            return parseInt(_random()*($.b-$.a+1)+$.a)\n        },\n        \n        random: _random,\n        \n        randrange: function(){\n            var $ = $B.args('randrange', 3,\n                {x:null, stop:null, step:null},\n                ['x', 'stop', 'step'],\n                arguments, {stop:null, step:null}, null, null)\n            if($.stop===null){\n                var start = 0, stop = $.x, step = 1\n            }else{\n                var start = $.x, stop = $.stop, \n                    step = $.step===null ? 1 : $.step\n                if(step==0){throw _b_.ValueError('step cannot be 0')}\n            }\n            if(typeof start=='number' && typeof stop == 'number' &&\n                typeof step=='number'){\n                return start+step*Math.floor(_random()*Math.floor((stop-start)/step))\n            }else{\n                var d = _b_.getattr(stop,'__sub__')(start)\n                d = _b_.getattr(d, '__floordiv__')(step)\n                // Force d to be a LongInt\n                d = $B.LongInt(d)\n                // d is a long integer with n digits ; to choose a random number\n                // between 0 and d the most simple is to take a random digit\n                // at each position, except the first one\n                var s = d.value, _len = s.length,\n                    res = Math.floor(_random()*(parseInt(s.charAt(0))+(_len==1 ? 0 : 1)))+''\n                var same_start = res.charAt(0)==s.charAt(0)\n                for(var i=1;i<_len;i++){\n                    if(same_start){\n                        // If it's the last digit, don't allow stop as valid\n                        if(i==_len-1){\n                            res += Math.floor(_random()*parseInt(s.charAt(i)))+''\n                        }else{\n                            res += Math.floor(_random()*(parseInt(s.charAt(i))+1))+''\n                            same_start = res.charAt(i)==s.charAt(i)\n                        }\n                    }else{\n                        res += Math.floor(_random()*10)+''\n                    }\n                }\n                var offset = {__class__:$B.LongInt.$dict, value: res, \n                    pos: true}\n                d = _b_.getattr(step, '__mul__')(offset)\n                d = _b_.getattr(start, '__add__')(d)\n                return _b_.int(d)\n            }\n        },\n    \n        sample: function(){\n            /*\n            Chooses k unique random elements from a population sequence or set.\n    \n            Returns a new list containing elements from the population while\n            leaving the original population unchanged.  The resulting list is\n            in selection order so that all sub-slices will also be valid random\n            samples.  This allows raffle winners (the sample) to be partitioned\n            into grand prize and second place winners (the subslices).\n    \n            Members of the population need not be hashable or unique.  If the\n            population contains repeats, then each occurrence is a possible\n            selection in the sample.\n    \n            To choose a sample in a range of integers, use range as an argument.\n            This is especially fast and space efficient for sampling from a\n            large population:   sample(range(10000000), 60)\n            \n            # Sampling without replacement entails tracking either potential\n            # selections (the pool) in a list or previous selections in a set.\n    \n            # When the number of selections is small compared to the\n            # population, then tracking selections is efficient, requiring\n            # only a small set and an occasional reselection.  For\n            # a larger number of selections, the pool tracking method is\n            # preferred since the list takes less space than the\n            # set and it doesn't suffer from frequent reselections.'\n            \n            */\n            var $ = $B.args('sample',2,{population:null,k:null},\n                ['population','k'], arguments,{},null,null),\n                population = $.population,\n                k = $.k\n    \n            if(!_b_.hasattr(population, '__len__')){\n                throw _b_.TypeError(\"Population must be a sequence or set.  For dicts, use list(d).\")\n            }\n            var n = _b_.getattr(population, '__len__')()\n    \n            if(k<0 || k>n){\n                throw _b_.ValueError(\"Sample larger than population\")\n            }\n            var result = [],\n                setsize = 21        // size of a small set minus size of an empty list\n            if(k > 5){\n                setsize += Math.pow(4, Math.ceil(Math.log(k * 3, 4))) // table size for big sets\n            }\n            if(n <= setsize){\n                // An n-length list is smaller than a k-length set\n                if(Array.isArray(population)){\n                    var pool = population.slice()\n                }else{var pool = _b_.list(population)}\n                for(var i=0;i<k;i++){ //invariant:  non-selected at [0,n-i)\n                    var j = _randbelow(n-i)\n                    result[i] = pool[j]\n                    pool[j] = pool[n-i-1]   // move non-selected item into vacancy\n                }\n            }else{\n                selected = {}\n                for(var i=0;i<k;i++){\n                    var j = _randbelow(n)\n                    while(selected[j]!==undefined){\n                        j = _randbelow(n)\n                    }\n                    selected[j] = true\n                    result[i] = Array.isArray(population) ? population[j] :\n                                    _b_.getattr(population, '__getitem__')(j)\n                }\n            }\n            return result\n        },\n            \n        seed: function(){\n            /*\n            Initialize internal state from hashable object.\n        \n            None or no argument seeds from current time or from an operating\n            system specific randomness source if available.\n        \n            If *a* is an int, all bits are used.\n            */\n            var $=$B.args('seed',2,{a:null, version:null},['a', 'version'],\n                    arguments,{a:new Date(), version:2},null,null),\n                a = $.a,\n                version = $.version\n    \n            if(version==1){a = _b_.hash(a)}\n            else if(version==2){\n                if(_b_.isinstance(a, _b_.str)){\n                    a = _b_.int.$dict.from_bytes(_b_.bytes(a, 'utf-8'), 'big')\n                }else if(_b_.isinstance(a, [_b_.bytes, _b_.bytearray])){\n                    a = _b_.int.$dict.from_bytes(a, 'big')\n                }else if(!_b_.isinstance(a, _b_.int)){\n                    throw _b_.TypeError('wrong argument')\n                }\n                if(a.__class__===$B.LongInt.$dict){\n                    // In this implementation, seed() only accepts safe integers\n                    // Generate a random one from the underlying string value,\n                    // using an arbitrary seed (99) to always return the same\n                    // integer\n                    var numbers = a.value, res = '', pos\n                    _random.seed(99)\n                    for(var i=0;i<17;i++){\n                        pos = parseInt(_random()*numbers.length)\n                        res += numbers.charAt(pos)\n                    }\n                    a = parseInt(res)\n                }\n            }else{\n                throw ValueError('version can only be 1 or 2')\n            }\n    \n            _random.seed(a)\n            gauss_next = null\n        },\n        \n        setstate: function(state){\n            // Restore internal state from object returned by getstate().\n            var $ = $B.args('setstate', 1, {state:null}, ['state'], \n                arguments, {}, null, null)\n            var state = _random.getstate()\n            if(!Array.isArray($.state)){\n                throw _b_.TypeError('state must be a list, not '+\n                    $B.get_class($.state).__name__)\n            }\n            if($.state.length<state.length){\n                throw _b_.ValueError(\"need more than \"+$.state.length+\n                    \" values to unpack\")\n            }else if($.state.length>state.length){\n                throw _b_.ValueError(\"too many values to unpack (expected \"+\n                    state.length+\")\")\n            }\n            if($.state[0]!=3){\n                throw _b_.ValueError(\"ValueError: state with version \"+\n                    $.state[0]+\" passed to Random.setstate() of version 3\")\n            }\n            var second = _b_.list($.state[1])\n            if(second.length!==state[1].length){\n                throw _b_.ValueError('state vector is the wrong size')\n            }\n            for(var i=0;i<second.length;i++){\n                if(typeof second[i] != 'number'){\n                    throw _b_.ValueError('state vector items must be integers')\n                }\n            }\n            _random.setstate($.state)\n        },\n    \n        shuffle: function(x, random){\n            /*\n            x, random=random.random -> shuffle list x in place; return None.\n    \n            Optional arg random is a 0-argument function returning a random\n            float in [0.0, 1.0); by default, the standard random.random.\n            */\n    \n            var $ = $B.args('shuffle',2,{x:null,random:null},\n                ['x','random'],\n                arguments,{random:null},null,null),\n                x = $.x,\n                random = $.random\n    \n            if(random===null){random=_random}\n    \n            if(Array.isArray(x)){\n                for(var i=x.length-1;i>=0;i--){\n                    var j = Math.floor(random() * (i+1)),\n                        temp = x[j]\n                    x[j] = x[i]\n                    x[i] = temp\n                }\n            }else{\n                var len = _b_.getattr(x, '__len__')(), temp,\n                    x_get = _b_.getattr(x, '__getitem__'),\n                    x_set = _b_.getattr(x, '__setitem__')\n                \n                for(i=len-1;i>=0;i--){\n                    var j = Math.floor(random() * (i+1)),\n                        temp = x_get(j)\n                    x_set(j, x_get(i))\n                    x_set(i, temp)\n                }\n            }\n        },\n    \n        triangular: function(){\n            /*\n            Triangular distribution.\n    \n            Continuous distribution bounded by given lower and upper limits,\n            and having a given mode value in-between.\n    \n            http://en.wikipedia.org/wiki/Triangular_distribution\n            */\n            var $=$B.args('triangular',3,\n                {low:null, high:null, mode:null},\n                ['low', 'high', 'mode'],\n                arguments,{low:0, high:1, mode:null}, null, null),\n                low = $.low,\n                high = $.high,\n                mode = $.mode\n                \n            var u = _random(),\n                c = mode===null ? 0.5 : (mode - low) / (high - low)\n            if(u > c){\n                u = 1 - u\n                c = 1 - c\n                var temp = low\n                low = high\n                high = temp\n            }\n            return low + (high - low) * Math.pow(u * c, 0.5)\n        },\n            \n        uniform: function(){\n            var $ = $B.args('uniform',2,{a:null,b:null},['a','b'],\n                arguments,{},null,null),\n                a = $B.$GetInt($.a),\n                b = $B.$GetInt($.b)\n            \n            return a + (b-a)*_random()\n        },\n    \n        vonmisesvariate: function(mu, kappa){\n            /* Circular data distribution.\n    \n            mu is the mean angle, expressed in radians between 0 and 2*pi, and\n            kappa is the concentration parameter, which must be greater than or\n            equal to zero.  If kappa is equal to zero, this distribution reduces\n            to a uniform random angle over the range 0 to 2*pi.\n    \n            */\n            // mu:    mean angle (in radians between 0 and 2*pi)\n            // kappa: concentration parameter kappa (>= 0)\n            // if kappa = 0 generate uniform random angle\n    \n            // Based upon an algorithm published in: Fisher, N.I.,\n            // \"Statistical Analysis of Circular Data\", Cambridge\n            // University Press, 1993.\n    \n            // Thanks to Magnus Kessler for a correction to the\n            // implementation of step 4.\n            \n            var $=$B.args('vonmisesvariate', 2,\n                    {mu: null, kappa:null}, ['mu', 'kappa'],\n                    arguments, {}, null, null),\n                mu = $.mu,\n                kappa = $.kappa,\n                TWOPI = 2*Math.PI\n    \n            if(kappa <= 1e-6){return TWOPI * _random()}\n    \n            var s = 0.5 / kappa,\n                r = s + Math.sqrt(1.0 + s * s)\n    \n            while(true){\n                var u1 = _random(),\n                    z = Math.cos(Math.PI * u1),\n                    d = z / (r + z),\n                    u2 = _random()\n                if((u2 < 1.0 - d * d) || \n                    (u2 <= (1.0 - d) * Math.exp(d))){\n                        break\n                }\n            }\n            var q = 1.0 / r,\n                f = (q + z) / (1.0 + q * z),\n                u3 = _random()\n            if(u3 > 0.5){var theta = (mu + Math.acos(f)) % TWOPI}\n            else{var theta = (mu - Math.acos(f)) % TWOPI}\n            return theta\n        },\n    \n        weibullvariate: function(){\n            /*Weibull distribution.\n    \n            alpha is the scale parameter and beta is the shape parameter.\n    \n            */\n            // Jain, pg. 499; bug fix courtesy Bill Arms\n    \n            var $ = $B.args('weibullvariate', 2, {alpha:null, beta:null},\n                    ['alpha', 'beta'], arguments, {}, null, null),\n                alpha = $.alpha,\n                beta = $.beta\n    \n            var u = 1 - _random()\n            return alpha * Math.pow(-Math.log(u), 1/beta)\n        },\n        \n        VERSION: VERSION\n    }\n\n    res.lognormvariate = function(){\n        /*\n        Log normal distribution.\n    \n        If you take the natural logarithm of this distribution, you'll get a\n        normal distribution with mean mu and standard deviation sigma.\n        mu can have any value, and sigma must be greater than zero.\n    \n        */\n    \n        return Math.exp(res.normalvariate.apply(null, arguments))\n    }\n    \n    res.betavariate = function(){\n        /* Beta distribution.\n    \n        Conditions on the parameters are alpha > 0 and beta > 0.\n        Returned values range between 0 and 1.\n    \n    \n        # This version due to Janne Sinkkonen, and matches all the std\n        # texts (e.g., Knuth Vol 2 Ed 3 pg 134 \"the beta distribution\").\n        */\n        \n        var $ = $B.args('betavariate', 2, {alpha:null, beta:null},\n                ['alpha', 'beta'], arguments, {}, null, null),\n            alpha = $.alpha,\n            beta = $.beta\n    \n        var y = res.gammavariate(alpha, 1)\n        if(y == 0){return _b_.float(0)}\n        else{return y / (y + res.gammavariate(beta, 1))}\n    }\n    \n    return res\n\n}\n\nfunction Random(){\n    var obj = {__class__: Random.$dict}\n    Random.$dict.__init__(obj)\n    return obj\n}\nRandom.__class__ = $B.$factory\nRandom.$dict = {\n    __class__: $B.$type,\n    __name__: 'Random',\n    $factory: Random,\n    __init__: function(self){self.$r = _Random()},\n    __getattribute__: function(self, attr){return self.$r[attr]}\n}\nRandom.$dict.__mro__ = [$B.builtins.object.$dict]\n\nvar $module = _Random()\n\n$module.Random = Random\n\n$module.SystemRandom = function(){\n    var f = function(){return {__class__:f.$dict}}\n    f.__class__ = $B.$factory\n    f.$dict = {\n        __class__: $B.$type,\n        __name__: 'SystemRandom',\n        $factory: f,\n        __getattribute__: function(){\n            throw $B.builtins.NotImplementedError()\n        }\n    }\n    f.$dict.__mro__ = [$B.builtins.object.$dict]\n    return f()\n}\n\nreturn $module\n\n})(__BRYTHON__)\n\n"], "sre_constants": [".py", "\n\n\n\n\n\n\n\n\n\n\n\"\"\"Internal support module for sre\"\"\"\n\n\n\nMAGIC=20031017\n\n\n\n\n\n\n\nclass error(Exception):\n pass\n \n \n \nFAILURE=\"failure\"\nSUCCESS=\"success\"\n\nANY=\"any\"\nANY_ALL=\"any_all\"\nASSERT=\"assert\"\nASSERT_NOT=\"assert_not\"\nAT=\"at\"\nBIGCHARSET=\"bigcharset\"\nBRANCH=\"branch\"\nCALL=\"call\"\nCATEGORY=\"category\"\nCHARSET=\"charset\"\nGROUPREF=\"groupref\"\nGROUPREF_IGNORE=\"groupref_ignore\"\nGROUPREF_EXISTS=\"groupref_exists\"\nIN=\"in\"\nIN_IGNORE=\"in_ignore\"\nINFO=\"info\"\nJUMP=\"jump\"\nLITERAL=\"literal\"\nLITERAL_IGNORE=\"literal_ignore\"\nMARK=\"mark\"\nMAX_REPEAT=\"max_repeat\"\nMAX_UNTIL=\"max_until\"\nMIN_REPEAT=\"min_repeat\"\nMIN_UNTIL=\"min_until\"\nNEGATE=\"negate\"\nNOT_LITERAL=\"not_literal\"\nNOT_LITERAL_IGNORE=\"not_literal_ignore\"\nRANGE=\"range\"\nREPEAT=\"repeat\"\nREPEAT_ONE=\"repeat_one\"\nSUBPATTERN=\"subpattern\"\nMIN_REPEAT_ONE=\"min_repeat_one\"\n\n\nAT_BEGINNING=\"at_beginning\"\nAT_BEGINNING_LINE=\"at_beginning_line\"\nAT_BEGINNING_STRING=\"at_beginning_string\"\nAT_BOUNDARY=\"at_boundary\"\nAT_NON_BOUNDARY=\"at_non_boundary\"\nAT_END=\"at_end\"\nAT_END_LINE=\"at_end_line\"\nAT_END_STRING=\"at_end_string\"\nAT_LOC_BOUNDARY=\"at_loc_boundary\"\nAT_LOC_NON_BOUNDARY=\"at_loc_non_boundary\"\nAT_UNI_BOUNDARY=\"at_uni_boundary\"\nAT_UNI_NON_BOUNDARY=\"at_uni_non_boundary\"\n\n\nCATEGORY_DIGIT=\"category_digit\"\nCATEGORY_NOT_DIGIT=\"category_not_digit\"\nCATEGORY_SPACE=\"category_space\"\nCATEGORY_NOT_SPACE=\"category_not_space\"\nCATEGORY_WORD=\"category_word\"\nCATEGORY_NOT_WORD=\"category_not_word\"\nCATEGORY_LINEBREAK=\"category_linebreak\"\nCATEGORY_NOT_LINEBREAK=\"category_not_linebreak\"\nCATEGORY_LOC_WORD=\"category_loc_word\"\nCATEGORY_LOC_NOT_WORD=\"category_loc_not_word\"\nCATEGORY_UNI_DIGIT=\"category_uni_digit\"\nCATEGORY_UNI_NOT_DIGIT=\"category_uni_not_digit\"\nCATEGORY_UNI_SPACE=\"category_uni_space\"\nCATEGORY_UNI_NOT_SPACE=\"category_uni_not_space\"\nCATEGORY_UNI_WORD=\"category_uni_word\"\nCATEGORY_UNI_NOT_WORD=\"category_uni_not_word\"\nCATEGORY_UNI_LINEBREAK=\"category_uni_linebreak\"\nCATEGORY_UNI_NOT_LINEBREAK=\"category_uni_not_linebreak\"\n\nOPCODES=[\n\n\nFAILURE,SUCCESS,\n\nANY,ANY_ALL,\nASSERT,ASSERT_NOT,\nAT,\nBRANCH,\nCALL,\nCATEGORY,\nCHARSET,BIGCHARSET,\nGROUPREF,GROUPREF_EXISTS,GROUPREF_IGNORE,\nIN,IN_IGNORE,\nINFO,\nJUMP,\nLITERAL,LITERAL_IGNORE,\nMARK,\nMAX_UNTIL,\nMIN_UNTIL,\nNOT_LITERAL,NOT_LITERAL_IGNORE,\nNEGATE,\nRANGE,\nREPEAT,\nREPEAT_ONE,\nSUBPATTERN,\nMIN_REPEAT_ONE\n\n]\n\nATCODES=[\nAT_BEGINNING,AT_BEGINNING_LINE,AT_BEGINNING_STRING,AT_BOUNDARY,\nAT_NON_BOUNDARY,AT_END,AT_END_LINE,AT_END_STRING,\nAT_LOC_BOUNDARY,AT_LOC_NON_BOUNDARY,AT_UNI_BOUNDARY,\nAT_UNI_NON_BOUNDARY\n]\n\nCHCODES=[\nCATEGORY_DIGIT,CATEGORY_NOT_DIGIT,CATEGORY_SPACE,\nCATEGORY_NOT_SPACE,CATEGORY_WORD,CATEGORY_NOT_WORD,\nCATEGORY_LINEBREAK,CATEGORY_NOT_LINEBREAK,CATEGORY_LOC_WORD,\nCATEGORY_LOC_NOT_WORD,CATEGORY_UNI_DIGIT,CATEGORY_UNI_NOT_DIGIT,\nCATEGORY_UNI_SPACE,CATEGORY_UNI_NOT_SPACE,CATEGORY_UNI_WORD,\nCATEGORY_UNI_NOT_WORD,CATEGORY_UNI_LINEBREAK,\nCATEGORY_UNI_NOT_LINEBREAK\n]\n\ndef makedict(list):\n d={}\n i=0\n for item in list:\n  d[item]=i\n  i=i+1\n return d\n \nOPCODES=makedict(OPCODES)\nATCODES=makedict(ATCODES)\nCHCODES=makedict(CHCODES)\n\n\nOP_IGNORE={\nGROUPREF:GROUPREF_IGNORE,\nIN:IN_IGNORE,\nLITERAL:LITERAL_IGNORE,\nNOT_LITERAL:NOT_LITERAL_IGNORE\n}\n\nAT_MULTILINE={\nAT_BEGINNING:AT_BEGINNING_LINE,\nAT_END:AT_END_LINE\n}\n\nAT_LOCALE={\nAT_BOUNDARY:AT_LOC_BOUNDARY,\nAT_NON_BOUNDARY:AT_LOC_NON_BOUNDARY\n}\n\nAT_UNICODE={\nAT_BOUNDARY:AT_UNI_BOUNDARY,\nAT_NON_BOUNDARY:AT_UNI_NON_BOUNDARY\n}\n\nCH_LOCALE={\nCATEGORY_DIGIT:CATEGORY_DIGIT,\nCATEGORY_NOT_DIGIT:CATEGORY_NOT_DIGIT,\nCATEGORY_SPACE:CATEGORY_SPACE,\nCATEGORY_NOT_SPACE:CATEGORY_NOT_SPACE,\nCATEGORY_WORD:CATEGORY_LOC_WORD,\nCATEGORY_NOT_WORD:CATEGORY_LOC_NOT_WORD,\nCATEGORY_LINEBREAK:CATEGORY_LINEBREAK,\nCATEGORY_NOT_LINEBREAK:CATEGORY_NOT_LINEBREAK\n}\n\nCH_UNICODE={\nCATEGORY_DIGIT:CATEGORY_UNI_DIGIT,\nCATEGORY_NOT_DIGIT:CATEGORY_UNI_NOT_DIGIT,\nCATEGORY_SPACE:CATEGORY_UNI_SPACE,\nCATEGORY_NOT_SPACE:CATEGORY_UNI_NOT_SPACE,\nCATEGORY_WORD:CATEGORY_UNI_WORD,\nCATEGORY_NOT_WORD:CATEGORY_UNI_NOT_WORD,\nCATEGORY_LINEBREAK:CATEGORY_UNI_LINEBREAK,\nCATEGORY_NOT_LINEBREAK:CATEGORY_UNI_NOT_LINEBREAK\n}\n\n\nSRE_FLAG_TEMPLATE=1\nSRE_FLAG_IGNORECASE=2\nSRE_FLAG_LOCALE=4\nSRE_FLAG_MULTILINE=8\nSRE_FLAG_DOTALL=16\nSRE_FLAG_UNICODE=32\nSRE_FLAG_VERBOSE=64\nSRE_FLAG_DEBUG=128\nSRE_FLAG_ASCII=256\n\n\nSRE_INFO_PREFIX=1\nSRE_INFO_LITERAL=2\nSRE_INFO_CHARSET=4\n\nif __name__ ==\"__main__\":\n def dump(f,d,prefix):\n  items=sorted(d. items(),key=lambda a:a[1])\n  for k,v in items:\n   f. write(\"#define %s_%s %s\\n\"%(prefix,k. upper(),v))\n f=open(\"sre_constants.h\",\"w\")\n f. write(\"\"\"\\\n/*\n * Secret Labs' Regular Expression Engine\n *\n * regular expression matching engine\n *\n * NOTE: This file is generated by sre_constants.py.  If you need\n * to change anything in here, edit sre_constants.py and run it.\n *\n * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.\n *\n * See the _sre.c file for information on usage and redistribution.\n */\n\n\"\"\")\n \n f. write(\"#define SRE_MAGIC %d\\n\"%MAGIC)\n \n dump(f,OPCODES,\"SRE_OP\")\n dump(f,ATCODES,\"SRE\")\n dump(f,CHCODES,\"SRE\")\n \n f. write(\"#define SRE_FLAG_TEMPLATE %d\\n\"%SRE_FLAG_TEMPLATE)\n f. write(\"#define SRE_FLAG_IGNORECASE %d\\n\"%SRE_FLAG_IGNORECASE)\n f. write(\"#define SRE_FLAG_LOCALE %d\\n\"%SRE_FLAG_LOCALE)\n f. write(\"#define SRE_FLAG_MULTILINE %d\\n\"%SRE_FLAG_MULTILINE)\n f. write(\"#define SRE_FLAG_DOTALL %d\\n\"%SRE_FLAG_DOTALL)\n f. write(\"#define SRE_FLAG_UNICODE %d\\n\"%SRE_FLAG_UNICODE)\n f. write(\"#define SRE_FLAG_VERBOSE %d\\n\"%SRE_FLAG_VERBOSE)\n \n f. write(\"#define SRE_INFO_PREFIX %d\\n\"%SRE_INFO_PREFIX)\n f. write(\"#define SRE_INFO_LITERAL %d\\n\"%SRE_INFO_LITERAL)\n f. write(\"#define SRE_INFO_CHARSET %d\\n\"%SRE_INFO_CHARSET)\n \n f. close()\n print(\"done\")\n"], "posix": [".py", "''\n\n\n\n\nimport datetime\n\nfrom browser import window\n\ndef _randint(a,b):\n return int(window. Math. random()*(b -a+1)+a)\n \nF_OK=0\n\nO_APPEND=8\n\nO_BINARY=32768\n\nO_CREAT=256\n\nO_EXCL=1024\n\nO_NOINHERIT=128\n\nO_RANDOM=16\n\nO_RDONLY=0\n\nO_RDWR=2\n\nO_SEQUENTIAL=32\n\nO_SHORT_LIVED=4096\n\nO_TEMPORARY=64\n\nO_TEXT=16384\n\nO_TRUNC=512\n\nO_WRONLY=1\n\nP_DETACH=4\n\nP_NOWAIT=1\n\nP_NOWAITO=3\n\nP_OVERLAY=2\n\nP_WAIT=0\n\nR_OK=4\n\nTMP_MAX=32767\n\nW_OK=2\n\nX_OK=1\n\nclass __loader__:\n pass\n \ndef _exit(*args,**kw):\n ''\n \n pass\n \ndef _getdiskusage(*args,**kw):\n ''\n \n pass\n \ndef _getfileinformation(*args,**kw):\n pass\n \ndef _getfinalpathname(*args,**kw):\n pass\n \ndef _getfullpathname(*args,**kw):\n pass\n \n_have_functions=['MS_WINDOWS']\n\ndef _isdir(*args,**kw):\n ''\n pass\n \ndef abort(*args,**kw):\n ''\n\n \n pass\n \ndef access(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef chdir(*args,**kw):\n ''\n\n\n\n\n \n pass\n \ndef chmod(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef close(*args,**kw):\n ''\n \n pass\n \ndef closerange(*args,**kw):\n ''\n \n pass\n \ndef device_encoding(*args,**kw):\n ''\n\n \n pass\n \ndef dup(*args,**kw):\n ''\n \n pass\n \ndef dup2(*args,**kw):\n ''\n \n pass\n \nenviron={'PYTHONUSERBASE':' '}\n\nerror=OSError\n\ndef execv(*args,**kw):\n ''\n\n\n\n \n pass\n \ndef execve(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n \n pass\n \ndef fstat(*args,**kw):\n ''\n\n \n pass\n \ndef fsync(*args,**kw):\n ''\n \n pass\n \ndef get_terminal_size(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef getcwd(*args,**kw):\n ''\n \n return __BRYTHON__. brython_path\n \ndef getcwdb(*args,**kw):\n ''\n \n pass\n \ndef getlogin(*args,**kw):\n ''\n \n pass\n \ndef getpid(*args,**kw):\n ''\n \n return 0\n \ndef getppid(*args,**kw):\n ''\n\n\n \n pass\n \ndef isatty(*args,**kw):\n ''\n\n \n pass\n \ndef kill(*args,**kw):\n ''\n \n pass\n \ndef link(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef listdir(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef lseek(*args,**kw):\n ''\n\n \n pass\n \ndef lstat(*args,**kw):\n ''\n\n \n return stat_result()\n \ndef mkdir(*args,**kw):\n ''\n\n\n\n\n\n\n\n \n pass\n \ndef open(path,flags,mode=0o777,*args,dir_fd=None ):\n ''\n\n\n\n\n\n \n \n \n from browser. local_storage import storage\n \n class mystorage:\n  def __init__(self,path,flags):\n   self. _path=path\n   self. _pos=0\n   self. _flags=flags\n   \n   if self. _flags&O_RDONLY ==O_RDONLY:\n    self. _data=storage. get(self. _path,None )\n    if self. _data is None :\n     raise FileNotFoundError(\"%s not found\"%self. _path)\n   elif self. _flags&O_WRONLY ==O_WRONLY:\n    storage[self. _path]=''\n    \n  def seek(self,pos):\n   self. _pos=pos\n   \n  def read(self,size=None ):\n   if size is None :\n    _result=self. _data[self. _pos:]\n    self. _pos=len(self. _data)\n    return _result\n    \n   assert size <=len(self. _data)-self. _pos\n   _result=self. _data[self. _pos:self. _pos+size]\n   self. _pos +=size\n   return _result\n   \n  def write(self,data):\n   storage[self. _path]+=str(data)\n   \n  def close(self):\n   pass\n   \n return mystorage(path,flags)\n \ndef pipe(*args,**kw):\n ''\n \n pass\n \ndef putenv(*args,**kw):\n ''\n \n pass\n \ndef read(*args,**kw):\n ''\n \n pass\n \ndef readlink(*args,**kw):\n ''\n\n\n\n\n\n \n pass\n \ndef remove(*args,**kw):\n ''\n\n\n\n\n\n \n pass\n \ndef rename(*args,**kw):\n ''\n\n\n\n\n\n\n \n pass\n \ndef replace(*args,**kw):\n ''\n\n\n\n\n\n\n \n pass\n \ndef rmdir(*args,**kw):\n ''\n\n\n\n\n\n \n pass\n \ndef spawnv(*args,**kw):\n ''\n\n\n\n\n \n pass\n \ndef spawnve(*args,**kw):\n ''\n\n\n\n\n\n \n pass\n \ndef startfile(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef stat(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n return stat_result()\n \ndef stat_float_times(*args,**kw):\n ''\n\n\n\n\n \n pass\n \nclass stat_result:\n\n def __init__(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  self. st_atime=datetime. datetime. now()\n  self. st_mtime=self. st_ctime=self. st_atime_ns=  self. st_mtime_ns=self. st_ctime_ns=self. st_atime\n  self. st_uid=self. st_gid=self. st_ino=-1\n  self. st_mode=0\n  self. st_size=1\n  \nclass statvfs_result:\n pass\n \ndef strerror(*args,**kw):\n ''\n \n pass\n \ndef symlink(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef system(*args,**kw):\n ''\n \n pass\n \nclass terminal_size:\n pass\n \ndef times(*args,**kw):\n ''\n\n\n \n pass\n \nclass times_result:\n pass\n \ndef umask(*args,**kw):\n ''\n \n pass\n \nclass uname_result:\n pass\n \ndef unlink(path,*args,dir_fd=None ):\n ''\n\n\n\n\n\n \n pass\n \ndef urandom(n):\n ''\n \n randbytes=[_randint(0,255)for i in range(n)]\n return bytes(randbytes)\n \ndef utime(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef waitpid(*args,**kw):\n ''\n \n pass\n \ndef write(*args,**kw):\n ''\n \n pass\n \n \n \ndef WIFSIGNALED(a):\n return False\n \ndef WTERMSIG(status):\n return 0\n \ndef WIFSIGNALED(status):\n ''\n return False\n \ndef WIFEXITED(status):\n return False\n \ndef WEXITSTATUS(status):\n pass\n \ndef WNOHANG():\n return (0,0)\n"], "sre_parse": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\"Internal support module for sre\"\"\"\n\n\n\nimport sys\n\nfrom sre_constants import *\nfrom _sre import MAXREPEAT\n\nSPECIAL_CHARS=\".\\\\[{()*+?^$|\"\nREPEAT_CHARS=\"*+?{\"\n\nDIGITS=set(\"0123456789\")\n\nOCTDIGITS=set(\"01234567\")\nHEXDIGITS=set(\"0123456789abcdefABCDEF\")\n\nWHITESPACE=set(\" \\t\\n\\r\\v\\f\")\n\nESCAPES={\nr\"\\a\":(LITERAL,ord(\"\\a\")),\nr\"\\b\":(LITERAL,ord(\"\\b\")),\nr\"\\f\":(LITERAL,ord(\"\\f\")),\nr\"\\n\":(LITERAL,ord(\"\\n\")),\nr\"\\r\":(LITERAL,ord(\"\\r\")),\nr\"\\t\":(LITERAL,ord(\"\\t\")),\nr\"\\v\":(LITERAL,ord(\"\\v\")),\nr\"\\\\\":(LITERAL,ord(\"\\\\\"))\n}\n\nCATEGORIES={\nr\"\\A\":(AT,AT_BEGINNING_STRING),\nr\"\\b\":(AT,AT_BOUNDARY),\nr\"\\B\":(AT,AT_NON_BOUNDARY),\nr\"\\d\":(IN,[(CATEGORY,CATEGORY_DIGIT)]),\nr\"\\D\":(IN,[(CATEGORY,CATEGORY_NOT_DIGIT)]),\nr\"\\s\":(IN,[(CATEGORY,CATEGORY_SPACE)]),\nr\"\\S\":(IN,[(CATEGORY,CATEGORY_NOT_SPACE)]),\nr\"\\w\":(IN,[(CATEGORY,CATEGORY_WORD)]),\nr\"\\W\":(IN,[(CATEGORY,CATEGORY_NOT_WORD)]),\nr\"\\Z\":(AT,AT_END_STRING),\n}\n\nFLAGS={\n\n\"i\":SRE_FLAG_IGNORECASE,\n\"L\":SRE_FLAG_LOCALE,\n\"m\":SRE_FLAG_MULTILINE,\n\"s\":SRE_FLAG_DOTALL,\n\"x\":SRE_FLAG_VERBOSE,\n\n\"a\":SRE_FLAG_ASCII,\n\"t\":SRE_FLAG_TEMPLATE,\n\"u\":SRE_FLAG_UNICODE,\n}\n\nclass Pattern:\n\n def __init__(self):\n  self. flags=0\n  self. open=[]\n  self. groups=1\n  self. groupdict={}\n def opengroup(self,name=None ):\n  gid=self. groups\n  self. groups=gid+1\n  if name is not None :\n   ogid=self. groupdict. get(name,None )\n   if ogid is not None :\n    raise error(\"redefinition of group name %s as group %d; \"\n    \"was group %d\"%(repr(name),gid,ogid))\n   self. groupdict[name]=gid\n  self. open. append(gid)\n  return gid\n def closegroup(self,gid):\n  self. open. remove(gid)\n def checkgroup(self,gid):\n  return gid <self. groups and gid not in self. open\n  \nclass SubPattern:\n\n def __init__(self,pattern,data=None ):\n  self. pattern=pattern\n  if data is None :\n   data=[]\n  self. data=data\n  self. width=None\n def __iter__(self):\n  return iter(self. data)\n  \n def dump(self,level=0):\n  nl=1\n  seqtypes=(tuple,list)\n  for op,av in self. data:\n   print(level *\"  \"+op,end=' ');nl=0\n   if op ==\"in\":\n   \n    print();nl=1\n    for op,a in av:\n     print((level+1)*\"  \"+op,a)\n   elif op ==\"branch\":\n    print();nl=1\n    i=0\n    for a in av[1]:\n     if i >0:\n      print(level *\"  \"+\"or\")\n     a. dump(level+1);nl=1\n     i=i+1\n   elif isinstance(av,seqtypes):\n    for a in av:\n     if isinstance(a,SubPattern):\n      if not nl:print()\n      a. dump(level+1);nl=1\n     else :\n      print(a,end=' ');nl=0\n   else :\n    print(av,end=' ');nl=0\n   if not nl:print()\n def __repr__(self):\n  return repr(self. data)\n def __len__(self):\n  return len(self. data)\n def __delitem__(self,index):\n  del self. data[index]\n def __getitem__(self,index):\n  if isinstance(index,slice):\n   return SubPattern(self. pattern,self. data[index])\n  return self. data[index]\n def __setitem__(self,index,code):\n  self. data[index]=code\n def insert(self,index,code):\n  self. data. insert(index,code)\n def append(self,code):\n  self. data. append(code)\n def getwidth(self):\n \n  if self. width:\n   return self. width\n  lo=hi=0\n  UNITCODES=(ANY,RANGE,IN,LITERAL,NOT_LITERAL,CATEGORY)\n  REPEATCODES=(MIN_REPEAT,MAX_REPEAT)\n  for op,av in self. data:\n   if op is BRANCH:\n    i=sys. maxsize\n    j=0\n    for av in av[1]:\n     l,h=av. getwidth()\n     i=min(i,l)\n     j=max(j,h)\n    lo=lo+i\n    hi=hi+j\n   elif op is CALL:\n    i,j=av. getwidth()\n    lo=lo+i\n    hi=hi+j\n   elif op is SUBPATTERN:\n    i,j=av[1]. getwidth()\n    lo=lo+i\n    hi=hi+j\n   elif op in REPEATCODES:\n    i,j=av[2]. getwidth()\n    lo=lo+int(i)*av[0]\n    hi=hi+int(j)*av[1]\n   elif op in UNITCODES:\n    lo=lo+1\n    hi=hi+1\n   elif op ==SUCCESS:\n    break\n  self. width=int(min(lo,sys. maxsize)),int(min(hi,sys. maxsize))\n  return self. width\n  \nclass Tokenizer:\n def __init__(self,string):\n  self. istext=isinstance(string,str)\n  self. string=string\n  self. index=0\n  self. __next()\n def __next(self):\n  if self. index >=len(self. string):\n   self. next=None\n   return\n  char=self. string[self. index:self. index+1]\n  \n  \n  if char and not self. istext:\n   char=chr(char[0])\n  if char ==\"\\\\\":\n   try :\n    c=self. string[self. index+1]\n   except IndexError:\n    raise error(\"bogus escape (end of line)\")\n   if not self. istext:\n    c=chr(c)\n   char=char+c\n  self. index=self. index+len(char)\n  self. next=char\n def match(self,char,skip=1):\n  if char ==self. next:\n   if skip:\n    self. __next()\n   return 1\n  return 0\n def get(self):\n  this=self. next\n  self. __next()\n  return this\n def getwhile(self,n,charset):\n  result=''\n  for _ in range(n):\n   c=self. next\n   if c not in charset:\n    break\n   result +=c\n   self. __next()\n  return result\n def tell(self):\n  return self. index,self. next\n def seek(self,index):\n  self. index,self. next=index\n  \ndef isident(char):\n return\"a\"<=char <=\"z\"or\"A\"<=char <=\"Z\"or char ==\"_\"\n \ndef isdigit(char):\n return\"0\"<=char <=\"9\"\n \ndef isname(name):\n\n if not isident(name[0]):\n  return False\n for char in name[1:]:\n  if not isident(char)and not isdigit(char):\n   return False\n return True\n \ndef _class_escape(source,escape):\n\n code=ESCAPES. get(escape)\n if code:\n  return code\n code=CATEGORIES. get(escape)\n if code and code[0]==IN:\n  return code\n try :\n  c=escape[1:2]\n  if c ==\"x\":\n  \n   escape +=source. getwhile(2,HEXDIGITS)\n   if len(escape)!=4:\n    raise ValueError\n   return LITERAL,int(escape[2:],16)&0xff\n  elif c ==\"u\"and source. istext:\n  \n   escape +=source. getwhile(4,HEXDIGITS)\n   if len(escape)!=6:\n    raise ValueError\n   return LITERAL,int(escape[2:],16)\n  elif c ==\"U\"and source. istext:\n  \n   escape +=source. getwhile(8,HEXDIGITS)\n   if len(escape)!=10:\n    raise ValueError\n   c=int(escape[2:],16)\n   chr(c)\n   return LITERAL,c\n  elif c in OCTDIGITS:\n  \n   escape +=source. getwhile(2,OCTDIGITS)\n   return LITERAL,int(escape[1:],8)&0xff\n  elif c in DIGITS:\n   raise ValueError\n  if len(escape)==2:\n   return LITERAL,ord(escape[1])\n except ValueError:\n  pass\n raise error(\"bogus escape: %s\"%repr(escape))\n \ndef _escape(source,escape,state):\n\n code=CATEGORIES. get(escape)\n if code:\n  return code\n code=ESCAPES. get(escape)\n if code:\n  return code\n try :\n  c=escape[1:2]\n  if c ==\"x\":\n  \n   escape +=source. getwhile(2,HEXDIGITS)\n   if len(escape)!=4:\n    raise ValueError\n   return LITERAL,int(escape[2:],16)&0xff\n  elif c ==\"u\"and source. istext:\n  \n   escape +=source. getwhile(4,HEXDIGITS)\n   if len(escape)!=6:\n    raise ValueError\n   return LITERAL,int(escape[2:],16)\n  elif c ==\"U\"and source. istext:\n  \n   escape +=source. getwhile(8,HEXDIGITS)\n   if len(escape)!=10:\n    raise ValueError\n   c=int(escape[2:],16)\n   chr(c)\n   return LITERAL,c\n  elif c ==\"0\":\n  \n   escape +=source. getwhile(2,OCTDIGITS)\n   return LITERAL,int(escape[1:],8)&0xff\n  elif c in DIGITS:\n  \n   if source. next in DIGITS:\n    escape=escape+source. get()\n    if (escape[1]in OCTDIGITS and escape[2]in OCTDIGITS and\n    source. next in OCTDIGITS):\n    \n     escape=escape+source. get()\n     return LITERAL,int(escape[1:],8)&0xff\n     \n   group=int(escape[1:])\n   if group <state. groups:\n    if not state. checkgroup(group):\n     raise error(\"cannot refer to open group\")\n    return GROUPREF,group\n   raise ValueError\n  if len(escape)==2:\n   return LITERAL,ord(escape[1])\n except ValueError:\n  pass\n raise error(\"bogus escape: %s\"%repr(escape))\n \ndef _parse_sub(source,state,nested=1):\n\n\n items=[]\n itemsappend=items. append\n sourcematch=source. match\n while 1:\n  itemsappend(_parse(source,state))\n  if sourcematch(\"|\"):\n   continue\n  if not nested:\n   break\n  if not source. next or sourcematch(\")\",0):\n   break\n  else :\n   raise error(\"pattern not properly closed\")\n   \n if len(items)==1:\n  return items[0]\n  \n subpattern=SubPattern(state)\n subpatternappend=subpattern. append\n \n \n while 1:\n  prefix=None\n  for item in items:\n   if not item:\n    break\n   if prefix is None :\n    prefix=item[0]\n   elif item[0]!=prefix:\n    break\n  else :\n  \n  \n   for item in items:\n    del item[0]\n   subpatternappend(prefix)\n   continue\n  break\n  \n  \n for item in items:\n  if len(item)!=1 or item[0][0]!=LITERAL:\n   break\n else :\n \n \n  set=[]\n  setappend=set. append\n  for item in items:\n   setappend(item[0])\n  subpatternappend((IN,set))\n  return subpattern\n  \n subpattern. append((BRANCH,(None ,items)))\n return subpattern\n \ndef _parse_sub_cond(source,state,condgroup):\n item_yes=_parse(source,state)\n if source. match(\"|\"):\n  item_no=_parse(source,state)\n  if source. match(\"|\"):\n   raise error(\"conditional backref with more than two branches\")\n else :\n  item_no=None\n if source. next and not source. match(\")\",0):\n  raise error(\"pattern not properly closed\")\n subpattern=SubPattern(state)\n subpattern. append((GROUPREF_EXISTS,(condgroup,item_yes,item_no)))\n return subpattern\n \n_PATTERNENDERS=set(\"|)\")\n_ASSERTCHARS=set(\"=!<\")\n_LOOKBEHINDASSERTCHARS=set(\"=!\")\n_REPEATCODES=set([MIN_REPEAT,MAX_REPEAT])\n\ndef _parse(source,state):\n\n subpattern=SubPattern(state)\n \n \n subpatternappend=subpattern. append\n sourceget=source. get\n sourcematch=source. match\n _len=len\n PATTERNENDERS=_PATTERNENDERS\n ASSERTCHARS=_ASSERTCHARS\n LOOKBEHINDASSERTCHARS=_LOOKBEHINDASSERTCHARS\n REPEATCODES=_REPEATCODES\n \n while 1:\n \n  if source. next in PATTERNENDERS:\n   break\n  this=sourceget()\n  if this is None :\n   break\n   \n  if state. flags&SRE_FLAG_VERBOSE:\n  \n   if this in WHITESPACE:\n    continue\n   if this ==\"#\":\n    while 1:\n     this=sourceget()\n     if this in (None ,\"\\n\"):\n      break\n    continue\n    \n  if this and this[0]not in SPECIAL_CHARS:\n   subpatternappend((LITERAL,ord(this)))\n   \n  elif this ==\"[\":\n  \n   set=[]\n   setappend=set. append\n   \n   \n   if sourcematch(\"^\"):\n    setappend((NEGATE,None ))\n    \n   start=set[:]\n   while 1:\n    this=sourceget()\n    if this ==\"]\"and set !=start:\n     break\n    elif this and this[0]==\"\\\\\":\n     code1=_class_escape(source,this)\n    elif this:\n     code1=LITERAL,ord(this)\n    else :\n     raise error(\"unexpected end of regular expression\")\n    if sourcematch(\"-\"):\n    \n     this=sourceget()\n     if this ==\"]\":\n      if code1[0]is IN:\n       code1=code1[1][0]\n      setappend(code1)\n      setappend((LITERAL,ord(\"-\")))\n      break\n     elif this:\n      if this[0]==\"\\\\\":\n       code2=_class_escape(source,this)\n      else :\n       code2=LITERAL,ord(this)\n      if code1[0]!=LITERAL or code2[0]!=LITERAL:\n       raise error(\"bad character range\")\n      lo=code1[1]\n      hi=code2[1]\n      if hi <lo:\n       raise error(\"bad character range\")\n      setappend((RANGE,(lo,hi)))\n     else :\n      raise error(\"unexpected end of regular expression\")\n    else :\n     if code1[0]is IN:\n      code1=code1[1][0]\n     setappend(code1)\n     \n     \n   if _len(set)==1 and set[0][0]is LITERAL:\n    subpatternappend(set[0])\n   elif _len(set)==2 and set[0][0]is NEGATE and set[1][0]is LITERAL:\n    subpatternappend((NOT_LITERAL,set[1][1]))\n   else :\n   \n    subpatternappend((IN,set))\n    \n  elif this and this[0]in REPEAT_CHARS:\n  \n   if this ==\"?\":\n    min,max=0,1\n   elif this ==\"*\":\n    min,max=0,MAXREPEAT\n    \n   elif this ==\"+\":\n    min,max=1,MAXREPEAT\n   elif this ==\"{\":\n    if source. next ==\"}\":\n     subpatternappend((LITERAL,ord(this)))\n     continue\n    here=source. tell()\n    min,max=0,MAXREPEAT\n    lo=hi=\"\"\n    while source. next in DIGITS:\n     lo=lo+source. get()\n    if sourcematch(\",\"):\n     while source. next in DIGITS:\n      hi=hi+sourceget()\n    else :\n     hi=lo\n    if not sourcematch(\"}\"):\n     subpatternappend((LITERAL,ord(this)))\n     source. seek(here)\n     continue\n    if lo:\n     min=int(lo)\n     if min >=MAXREPEAT:\n      raise OverflowError(\"the repetition number is too large\")\n    if hi:\n     max=int(hi)\n     if max >=MAXREPEAT:\n      raise OverflowError(\"the repetition number is too large\")\n     if max <min:\n      raise error(\"bad repeat interval\")\n   else :\n    raise error(\"not supported\")\n    \n   if subpattern:\n    item=subpattern[-1:]\n   else :\n    item=None\n   if not item or (_len(item)==1 and item[0][0]==AT):\n    raise error(\"nothing to repeat\")\n   if item[0][0]in REPEATCODES:\n    raise error(\"multiple repeat\")\n   if sourcematch(\"?\"):\n    subpattern[-1]=(MIN_REPEAT,(min,max,item))\n   else :\n    subpattern[-1]=(MAX_REPEAT,(min,max,item))\n    \n  elif this ==\".\":\n   subpatternappend((ANY,None ))\n   \n  elif this ==\"(\":\n   group=1\n   name=None\n   condgroup=None\n   if sourcematch(\"?\"):\n    group=0\n    \n    if sourcematch(\"P\"):\n    \n     if sourcematch(\"<\"):\n     \n      name=\"\"\n      while 1:\n       char=sourceget()\n       if char is None :\n        raise error(\"unterminated name\")\n       if char ==\">\":\n        break\n       name=name+char\n      group=1\n      if not name:\n       raise error(\"missing group name\")\n      if not isname(name):\n       raise error(\"bad character in group name\")\n     elif sourcematch(\"=\"):\n     \n      name=\"\"\n      while 1:\n       char=sourceget()\n       if char is None :\n        raise error(\"unterminated name\")\n       if char ==\")\":\n        break\n       name=name+char\n      if not name:\n       raise error(\"missing group name\")\n      if not isname(name):\n       raise error(\"bad character in group name\")\n      gid=state. groupdict. get(name)\n      if gid is None :\n       raise error(\"unknown group name\")\n      subpatternappend((GROUPREF,gid))\n      continue\n     else :\n      char=sourceget()\n      if char is None :\n       raise error(\"unexpected end of pattern\")\n      raise error(\"unknown specifier: ?P%s\"%char)\n    elif sourcematch(\":\"):\n    \n     group=2\n    elif sourcematch(\"#\"):\n    \n     while 1:\n      if source. next is None or source. next ==\")\":\n       break\n      sourceget()\n     if not sourcematch(\")\"):\n      raise error(\"unbalanced parenthesis\")\n     continue\n    elif source. next in ASSERTCHARS:\n    \n     char=sourceget()\n     dir=1\n     if char ==\"<\":\n      if source. next not in LOOKBEHINDASSERTCHARS:\n       raise error(\"syntax error\")\n      dir=-1\n      char=sourceget()\n     p=_parse_sub(source,state)\n     if not sourcematch(\")\"):\n      raise error(\"unbalanced parenthesis\")\n     if char ==\"=\":\n      subpatternappend((ASSERT,(dir,p)))\n     else :\n      subpatternappend((ASSERT_NOT,(dir,p)))\n     continue\n    elif sourcematch(\"(\"):\n    \n     condname=\"\"\n     while 1:\n      char=sourceget()\n      if char is None :\n       raise error(\"unterminated name\")\n      if char ==\")\":\n       break\n      condname=condname+char\n     group=2\n     if not condname:\n      raise error(\"missing group name\")\n     if isname(condname):\n      condgroup=state. groupdict. get(condname)\n      if condgroup is None :\n       raise error(\"unknown group name\")\n     else :\n      try :\n       condgroup=int(condname)\n      except ValueError:\n       raise error(\"bad character in group name\")\n    else :\n    \n     if not source. next in FLAGS:\n      raise error(\"unexpected end of pattern\")\n     while source. next in FLAGS:\n      state. flags=state. flags |FLAGS[sourceget()]\n   if group:\n   \n    if group ==2:\n    \n     group=None\n    else :\n     group=state. opengroup(name)\n    if condgroup:\n     p=_parse_sub_cond(source,state,condgroup)\n    else :\n     p=_parse_sub(source,state)\n    if not sourcematch(\")\"):\n     raise error(\"unbalanced parenthesis\")\n    if group is not None :\n     state. closegroup(group)\n    subpatternappend((SUBPATTERN,(group,p)))\n   else :\n    while 1:\n     char=sourceget()\n     if char is None :\n      raise error(\"unexpected end of pattern\")\n     if char ==\")\":\n      break\n     raise error(\"unknown extension\")\n     \n  elif this ==\"^\":\n   subpatternappend((AT,AT_BEGINNING))\n   \n  elif this ==\"$\":\n   subpattern. append((AT,AT_END))\n   \n  elif this and this[0]==\"\\\\\":\n   code=_escape(source,this,state)\n   subpatternappend(code)\n   \n  else :\n   raise error(\"parser error\")\n   \n return subpattern\n \ndef fix_flags(src,flags):\n\n if isinstance(src,str):\n  if not flags&SRE_FLAG_ASCII:\n   flags |=SRE_FLAG_UNICODE\n  elif flags&SRE_FLAG_UNICODE:\n   raise ValueError(\"ASCII and UNICODE flags are incompatible\")\n else :\n  if flags&SRE_FLAG_UNICODE:\n   raise ValueError(\"can't use UNICODE flag with a bytes pattern\")\n return flags\n \ndef parse(str,flags=0,pattern=None ):\n\n source=Tokenizer(str)\n \n if pattern is None :\n  pattern=Pattern()\n pattern. flags=flags\n pattern. str=str\n p=_parse_sub(source,pattern,0)\n p. pattern. flags=fix_flags(str,p. pattern. flags)\n \n tail=source. get()\n if tail ==\")\":\n  raise error(\"unbalanced parenthesis\")\n elif tail:\n  raise error(\"bogus characters at end of regular expression\")\n  \n if flags&SRE_FLAG_DEBUG:\n  p. dump()\n  \n if not (flags&SRE_FLAG_VERBOSE)and p. pattern. flags&SRE_FLAG_VERBOSE:\n \n \n  return parse(str,p. pattern. flags)\n  \n return p\n \ndef parse_template(source,pattern):\n\n\n s=Tokenizer(source)\n sget=s. get\n p=[]\n a=p. append\n def literal(literal,p=p,pappend=a):\n  if p and p[-1][0]is LITERAL:\n   p[-1]=LITERAL,p[-1][1]+literal\n  else :\n   pappend((LITERAL,literal))\n sep=source[:0]\n if isinstance(sep,str):\n  makechar=chr\n else :\n  makechar=chr\n while 1:\n  this=sget()\n  if this is None :\n   break\n  if this and this[0]==\"\\\\\":\n  \n   c=this[1:2]\n   if c ==\"g\":\n    name=\"\"\n    if s. match(\"<\"):\n     while 1:\n      char=sget()\n      if char is None :\n       raise error(\"unterminated group name\")\n      if char ==\">\":\n       break\n      name=name+char\n    if not name:\n     raise error(\"missing group name\")\n    try :\n     index=int(name)\n     if index <0:\n      raise error(\"negative group number\")\n    except ValueError:\n     if not isname(name):\n      raise error(\"bad character in group name\")\n     try :\n      index=pattern. groupindex[name]\n     except KeyError:\n      raise IndexError(\"unknown group name\")\n    a((MARK,index))\n   elif c ==\"0\":\n    if s. next in OCTDIGITS:\n     this=this+sget()\n     if s. next in OCTDIGITS:\n      this=this+sget()\n    literal(makechar(int(this[1:],8)&0xff))\n   elif c in DIGITS:\n    isoctal=False\n    if s. next in DIGITS:\n     this=this+sget()\n     if (c in OCTDIGITS and this[2]in OCTDIGITS and\n     s. next in OCTDIGITS):\n      this=this+sget()\n      isoctal=True\n      literal(makechar(int(this[1:],8)&0xff))\n    if not isoctal:\n     a((MARK,int(this[1:])))\n   else :\n    try :\n     this=makechar(ESCAPES[this][1])\n    except KeyError:\n     pass\n    literal(this)\n  else :\n   literal(this)\n   \n i=0\n groups=[]\n groupsappend=groups. append\n literals=[None ]*len(p)\n if isinstance(source,str):\n  encode=lambda x:x\n else :\n \n \n  encode=lambda x:x. encode('latin-1')\n for c,s in p:\n  if c is MARK:\n   groupsappend((i,s))\n   \n  else :\n   literals[i]=encode(s)\n  i=i+1\n return groups,literals\n \ndef expand_template(template,match):\n g=match. group\n sep=match. string[:0]\n groups,literals=template\n literals=literals[:]\n try :\n  for index,group in groups:\n   literals[index]=s=g(group)\n   if s is None :\n    raise error(\"unmatched group\")\n except IndexError:\n  raise error(\"invalid group reference\")\n return sep. join(literals)\n \n \n"]}